/**
 * @file ccl_configureClocks.c
 * Configuration of system and peripheral clocks.
 *
 * Copyright (C) 2018 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   ccl_triggerTransitionToModeDRUN
 *   ccl_configureClocks
 *
 * Local functions
 */

/*
 * Include files
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "MPC5748G.h"

#include "typ_types.h"
#include "cfl_configureFlash.h"
#include "ccl_configureClocks.h"


/*
 * Defines
 */
 
/** Enumeration of MCU run modes (missing in MPC5748G.h). */
#define MC_ME_MCTL_DRUN 0x03

/** Bit field access for slow oscillator registers (missing in MPC5748G.h). */
#define XOSC_CTL_OSCDIV_MASK    0x1F00u
#define XOSC_CTL_OSCDIV_SHIFT   8u
#define XOSC_CTL_OSCDIV_WIDTH   5u
#define XOSC_CTL_OSCDIV(x)      (((uint32_t)(((uint32_t)(x)) << XOSC_CTL_OSCDIV_SHIFT)) \
                                 & XOSC_CTL_OSCDIV_MASK                                 \
                                )


/*
 * Local type definitions
 */
 
 
/*
 * Local prototypes
 */
 
 
/*
 * Data definitions
 */
 
 
/*
 * Function implementation
 */

/**
 * Perform a mode transition of the micro controller towards DRUN. It doesn't matter if the
 * MCU is already running in DRUN. On return DRUN is the active mode. The function will
 * never return if the mode transition is not happening for whatever reasons.
 */
void ccl_triggerTransitionToModeDRUN(void)
{
    /* See RM, 38.3.2. According to the RM we need to first check that the memory
       controller is not in a state change, then we command the mode change and finally we
       wait for its completion. An assertion checks the reached mode. */
    while((PMCDIG->MCR & PMCDIG_MCR_LP_ST_CHG_IN_PRGRS_MASK) != 0)
        ;
    MC_ME->MCTL = MC_ME_MCTL_TARGET_MODE(MC_ME_MCTL_DRUN) | MC_ME_MCTL_KEY(0x5af0u);
    MC_ME->MCTL = MC_ME_MCTL_TARGET_MODE(MC_ME_MCTL_DRUN) | MC_ME_MCTL_KEY(0xa50fu);
    while((MC_ME->GS & MC_ME_GS_S_MTRANS_MASK) != 0U)
        ;
    assert((MC_ME->GS & MC_ME_GS_S_CURRENT_MODE_MASK)
           == MC_ME_GS_S_CURRENT_MODE(MC_ME_MCTL_DRUN)
          );
} /* End of ccl_triggerTransitionToModeDRUN */



/**
 * Configure system clock sources and paths to clock receivers as appropriate for the
 * DEVKIT-MPC5748G. All clocks are set to the maximum. Maximum CPU performance is reached.
 * Low power settings or low EM emissions are not considered.\n
 *   Note, there's no error handling implemented. The function depends on no variable input
 * data and will fail only in case of hardware problems. In this case it'll like be stuck
 * and never return (from either an assertion or an endless wait for mode completion).
 *   @remark
 * This code is based on the startup code, which is generated by the NXP S32 Design Studio
 * if the wizard is used to create a new MPC5748G project.
 */
void ccl_configureClocks(void)
{
    /* The RAM controller operates without wait states after reset. To safely enable the
       maximum system clock of 160 MHz we first change to the 1-wait state mode. This
       is requested by RM 10.2.1, SRAM Controller (PRAMC). We repeat the operation for all
       three controllers. 
         Note, PRAMCx_PRCR1, is 0x200 after reset (see RM 72.1) */
    PRAMC_0->PRCR1 = PRAMC_0->PRCR1 | PRAMC_PRCR1_FT_DIS(1);
    PRAMC_1->PRCR1 = PRAMC_1->PRCR1 | PRAMC_PRCR1_FT_DIS(1);
    PRAMC_2->PRCR1 = PRAMC_2->PRCR1 | PRAMC_PRCR1_FT_DIS(1);

    /* Configure the clock sources, which can either be taken directly
       as system clock or be multiplied by the PLL. */
    
    /* Configure the fast internal RC Oscillator (FIRC). See RM, section 27.3.1. */
    FIRC->CTL = FIRC_CTL_FIRCDIV(0u /* divide by n+1 */);

    /* The FIRC is always enabled after reset. The enable bit is read only, the FIRC can't
       be switched off. See RM, section 38.3.10. */
#if 0
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_FIRCON(1u);
#endif

/// @todo Enable all sources at once?
    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure the slow internal RC oscillator (SIRC). See RM, 26.3.1. */
    SIRC->CTL = SIRC_CTL_SIRCDIV(0u /* divide by n+1 */);

    /* Enable the SIRC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_SXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure FXOSC, see RM section 29. */
    const uint32_t XOSC_CTL = XOSC->CTL;
    XOSC->CTL = XOSC_CTL_OSCBYP(0u /* 0: run oscillator, 1: use crystal input as clock */)
                | (XOSC_CTL_EOCV_MASK & XOSC_CTL)
                | XOSC_CTL_I_OSC(1u) /* Reset possible interrupt flag */
                | XOSC_CTL_OSCM(0u /* 0: full swing pierce mode, 1: loop controlled pierce
                                      mode */
                               )
                | XOSC_CTL_OSCDIV(0u /* divide by n+1 */);

    /* Enable XOSC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_FXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure SXOSC, see RM section 28. */
    const uint32_t SXOSC_CTL = SXOSC->CTL;
    SXOSC->CTL = SXOSC_CTL_ALC(true)
                 | (SXOSC_CTL_EOCV_MASK & SXOSC_CTL)
                 | SXOSC_CTL_M_OSC(0) /* No interrupt on stable oscillation */
                 | SXOSC_CTL_OSCDIV(0u /* divide by n+1 */);

    /* Enable SXOSC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_SXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure FXOSC, see RM section 29. It is then used as input to the PLL, which will
       become the system and peripheral clock. Our crystal frequency is 40 Mhz*/
    MC_CGM->AC5_SC = MC_CGM_AC5_SC_SELCTL(1u);

    /* The PLL is configured. The VCO needs to be in the range 600-1200MHz. We use 40 MHz
       crystal by 2 (PREDIV) times 32 (MFD), yielding a VCO frequency output of
       40Mhz/2*32=640MHz. The output divider RFDPHI is chosen to be 4 so that we eventually
       have 160Mhz system clock. */
    PLLDIG->PLLDV = PLLDIG_PLLDV_PREDIV(2 /* TBC in RM and documented */)
                    | PLLDIG_PLLDV_MFD(32u)
                    | PLLDIG_PLLDV_RFDPHI1(1u /* div by 2^(n+1) */)
                    | PLLDIG_PLLDV_RFDPHI(1u /* div by 2^(n+1) */);

    /* Sigma delta modulation is disabled. Write MFN. */
/// @todo Check source: Mismatch between register name and field macro. Comment doesn't fit to MFN but value would fit to register PLLFM. What's meant? What's correct?
    PLLDIG->PLLFM = PLLDIG_PLLFD_MFN(0u);

    /* Write denominator fractional loop divider */
    PLLDIG->PLLCAL3 = PLLDIG_PLLCAL3_MFDEN(9999u /* TBC */);

    /* Enable PLL. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_PLLON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* All clock soures are running. Now connect the system clocks to the principal clock
       source, the PLL. */
    
    /* Select the system clock source in a read modify write access to register DRUN_MC. */
    MC_ME->DRUN_MC = MC_ME->DRUN_MC
                     & ~MC_ME_GS_S_SYSCLK_MASK
                     | MC_ME_GS_S_SYSCLK(2u /* clock source is PLL, PHI_0 */);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* S160 clock */
    MC_CGM->SC_DC0 = MC_CGM_SC_DC0_DIV(0u /* divide by n+1 */)
                     | MC_CGM_SC_DC0_DE(1u /* enable */);

    /* S80 clock */
    MC_CGM->SC_DC1 = MC_CGM_SC_DC1_DIV(1u /* divide by n+1 */)
                     | MC_CGM_SC_DC1_DE(1u /* enable */);

    /* S40 clock */
    MC_CGM->SC_DC2 = MC_CGM_SC_DC2_DIV(3u /* divide by n+1 */)
                     | MC_CGM_SC_DC2_DE(1u /* enable */);

    /* F40, F80 and FS80 are not configurable. */

    /* FS80 clock */
    MC_CGM->SC_DC5 = MC_CGM_SC_DC5_DIV(1u /* divide by n+1 */)
                     | MC_CGM_SC_DC5_DE(1u /* enable */);

    /* Connect the peripherals to the appropriate system clocks. See RM 31, MC_CGM.*/

    /* Ethernet clock (ENET0_CLK and ENET1_CLK). See RM 9.4.3.6, 31.3.29 and 42. */
    MC_CGM->AC2_SC = MC_CGM_AC2_SC_SELCTL(0u /* 0: F40, 1: external clock */);

    /* Secure Digital Host Controller (uSDHC) clock. See RM 31.3.32 and 49. */
    MC_CGM->AC4_SC = MC_CGM_AC4_SC_SELCTL(0u /* 0: F40, 1: external clock */);

    /* CLKOUT_0, RM 31.2 */
    MC_CGM->AC6_SC = MC_CGM_AC6_SC_SELCTL(3u /* S160 clock. See RM 31.3.34 */);
    MC_CGM->AC6_DC0 = MC_CGM_AC6_DC0_DIV(15u /* divide by n+1, RM 31.3.36 */)
                      | MC_CGM_AC6_DC0_DE(1u /* 1: enable */);

    /* CLKOUT_1, RM 31.2
         SELCTL:
         0 FXOSC
         2: SXOSC
         6: Z2 clock
         14: PLL 1 */
    MC_CGM->CLKOUT1_SC = MC_CGM_CLKOUT1_SC_SELCTL(0u /*  See RM 31.3.1 */);
    MC_CGM->CLKOUT1_DC = MC_CGM_CLKOUT1_DC_DIV(79u /* divide by n+1 */)
                         | MC_CGM_CLKOUT1_DC_DE(1u /* 1: enable */);

    /* SPI0, RM 31.3.6 */
    MC_CGM->AC8_SC = MC_CGM_AC8_SC_SELCTL(0u /* 0: F40, 1: FXOSC */);

    /* FlexCAN0, RM 31.3.8 */
    MC_CGM->AC9_SC = MC_CGM_AC9_SC_SELCTL(0u /* 0: FS80, 1: FXOSC */);

    /* The peripherals are clocked in all RUN, DRUN and SAFE mode but not in RESET. See RM,
       38.3.21. Enabling the peripheral clocks in run configuration 0 means that no
       peripheral-specific clock enabling needs to be done later - after reset all
       peripherals refer by default to run configuration 0 (out of eight available
       configurations). */
    MC_ME->RUN_PC[0] = 0xfcu;

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Flash configuration depends on chosen system clock and is therefore done here, in
       the same context: At reset the flash controller initializes with a conservative,
       safe setting for wait states and pipelining. Now, after choosing the clock rate we
       can adjust to the recommended settings for this clock. The recommendations for 160
       MHz system clock can be found in the MPC5748G Microcontroller Data Sheet, section
       6.3.6, Flash read wait state and address pipeline control settings, Table 34.
         Note, these changes can't be done by normal register writes. The code execution
       must itself not depend on the flash, we call a routine, which is running in some RAM
       area. */
    cfl_configureFlash(/* RWSC_waitStates */ 4, /* APC_pipelining */ 1);

} /* end of ccl_configureClocks */
