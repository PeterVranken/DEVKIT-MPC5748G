/**
 * @file ccl_configureClocks.c
 * Configuration of system and peripheral clocks.
 *
 * Copyright (C) 2018-2023 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   ccl_triggerTransitionToModeDRUN
 *   ccl_configureClocks
 * Local functions
 */

/*
 * Include files
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "MPC5748G.h"

#include "typ_types.h"
#include "cfl_configureFlash.h"
#include "ccl_configureClocks.h"


/*
 * Defines
 */
 
/** Enumeration of MCU run modes (missing in MPC5748G.h). */
#define MC_ME_MCTL_DRUN 0x03

/** Bit field access for slow oscillator registers (missing in MPC5748G.h). */
#define XOSC_CTL_OSCDIV_MASK    0x1F00u
#define XOSC_CTL_OSCDIV_SHIFT   8u
#define XOSC_CTL_OSCDIV_WIDTH   5u
#define XOSC_CTL_OSCDIV(x)      (((uint32_t)(((uint32_t)(x)) << XOSC_CTL_OSCDIV_SHIFT)) \
                                 & XOSC_CTL_OSCDIV_MASK                                 \
                                )


/*
 * Local type definitions
 */
 
 
/*
 * Local prototypes
 */
 
 
/*
 * Data definitions
 */
 
 
/*
 * Function implementation
 */

/**
 * Perform a mode transition of the micro controller towards DRUN. It doesn't matter if the
 * MCU is already running in DRUN. On return DRUN is the active mode. The function will
 * never return if the mode transition is not happening for whatever reasons.
 */
void ccl_triggerTransitionToModeDRUN(void)
{
    /* See RM, 38.3.2. According to the RM we need to first check that the memory
       controller is not in a state change, then we command the mode change and finally we
       wait for its completion. An assertion checks the reached mode. */
    while((PMCDIG->MCR & PMCDIG_MCR_LP_ST_CHG_IN_PRGRS_MASK) != 0)
        ;
    MC_ME->MCTL = MC_ME_MCTL_TARGET_MODE(MC_ME_MCTL_DRUN) | MC_ME_MCTL_KEY(0x5af0u);
    MC_ME->MCTL = MC_ME_MCTL_TARGET_MODE(MC_ME_MCTL_DRUN) | MC_ME_MCTL_KEY(0xa50fu);
    while((MC_ME->GS & MC_ME_GS_S_MTRANS_MASK) != 0U)
        ;
    assert((MC_ME->GS & MC_ME_GS_S_CURRENT_MODE_MASK)
           == MC_ME_GS_S_CURRENT_MODE(MC_ME_MCTL_DRUN)
          );
} /* End of ccl_triggerTransitionToModeDRUN */



/**
 * Configure system clock sources and paths to clock receivers as appropriate for the
 * DEVKIT-MPC5748G. All clocks are set to the maximum. Maximum CPU performance is reached.
 * Low power settings or low EM emissions are not considered.\n
 *   Note, there's no error handling implemented. The function depends on no variable input
 * data and will fail only in case of hardware problems. In this case it'll like be stuck
 * and never return (from either an assertion or an endless wait for mode completion).
 *   @remark
 * This code is based on the startup code, which is generated by the NXP S32 Design Studio
 * if the wizard is used to create a new MPC5748G project.
 */
void ccl_configureClocks(void)
{
    /* The RAM controller operates without wait states after reset. To safely enable the
       maximum system clock of 160 MHz we first change to the 1-wait state mode. This is
       requested by RM 10.2.1, SRAM Controller (PRAMC). The same hint is given in RM 6.2.
       We repeat the operation for all three controllers.
         Caution, we didn't find a recommendation for the read burst optimization. It is
       turned on after reset and we leave it in this state. No statement has been found
       whether this setting is clock frequency dependent, i.e. whether we should better
       disable the optimization for our high clock speed. See RM 72.3.1.
         Note, PRAMCx_PRCR1, is 0x200 after reset (see RM 72.1) */
    PRAMC_0->PRCR1 = PRAMC_0->PRCR1 | PRAMC_PRCR1_FT_DIS(1);
    PRAMC_1->PRCR1 = PRAMC_1->PRCR1 | PRAMC_PRCR1_FT_DIS(1);
    PRAMC_2->PRCR1 = PRAMC_2->PRCR1 | PRAMC_PRCR1_FT_DIS(1);

    /* Configure the clock sources, which can either be taken directly
       as system clock or be multiplied by the PLL. */
    
    /* Configure the fast internal RC Oscillator (FIRC). See RM, section 27.3.1. */
    FIRC->CTL = FIRC_CTL_FIRCDIV(0u /* divide by n+1 */);

    /* The FIRC is always enabled after reset. The enable bit is read only, the FIRC can't
       be switched off. See RM, section 38.3.10. */
#if 0
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_FIRCON(1u);
#endif

/// @todo Enable all sources at once?
    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure the slow internal RC oscillator (SIRC). See RM, 26.3.1. */
    SIRC->CTL = SIRC_CTL_SIRCDIV(0u /* divide by n+1 */);

    /* Enable the SIRC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_SXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure FXOSC, see RM section 29. */
    const uint32_t XOSC_CTL = XOSC->CTL;
    XOSC->CTL = XOSC_CTL_OSCBYP(0u /* 0: run oscillator, 1: use crystal input as clock */)
                | (XOSC_CTL_EOCV_MASK & XOSC_CTL)
                | XOSC_CTL_I_OSC(1u) /* Reset possible interrupt flag */
                | XOSC_CTL_OSCM(0u /* 0: full swing pierce mode, 1: loop controlled pierce
                                      mode */
                               )
                | XOSC_CTL_OSCDIV(0u /* divide by n+1 */);

    /* Enable XOSC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_FXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure SXOSC, see RM section 28. */
    const uint32_t SXOSC_CTL = SXOSC->CTL;
    SXOSC->CTL = SXOSC_CTL_ALC(true)
                 | (SXOSC_CTL_EOCV_MASK & SXOSC_CTL)
                 | SXOSC_CTL_M_OSC(0) /* No interrupt on stable oscillation */
                 | SXOSC_CTL_OSCDIV(0u /* divide by n+1 */);

    /* Enable SXOSC. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_SXOSCON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Configure FXOSC, see RM section 29. It is then used as input to the PLL, which will
       become the system and peripheral clock. Our crystal frequency is 40 Mhz*/
    MC_CGM->AC5_SC = MC_CGM_AC5_SC_SELCTL(1u);

    /* Some preprocessor check will help to keep the static definitions in the header file
       consistent with the actual configuration made here. */
#if CCL_CORE_CLK != 160000000u  ||  CCL_CORE_CLK != CCL_PHI_0_CLK \
    ||  CCL_PHI_1_CLK != 80000000u
# error Inconsistencies found between public header file and actual clock configuration
#endif

    /* RM 25.5.4: The PLL is configured. The VCO needs to be in the range 600-1200MHz. We
       use 40 MHz crystal by 2 (PREDIV) times 32 (MFD), yielding a VCO frequency output of
       40Mhz/2*32=640MHz. The output divider RFDPHI is chosen to be 4 so that we eventually
       have 160MHz system clock.
         The secondary PLL output, PHI_1 or PLL_CLOCKOUT2, must not be greater than 80MHz
       (RM 9.9.1.2) and we set the divider to 8. Note, we have not found barely any
       reference to PHI_1 in the RM, it seems to be widely unused. The only found use case
       is the optional routing of the signal to the external signals CLOCKOUT0/1. */
    PLLDIG->PLLDV = PLLDIG_PLLDV_PREDIV(2 /* div by n, n=1..6 */)
                    | PLLDIG_PLLDV_MFD(32u /* times n, n=10..150 */)
                    | PLLDIG_PLLDV_RFDPHI1(2u /* div by 2^(n+1), n=0..4 */)
                    | PLLDIG_PLLDV_RFDPHI(1u /* div by 2^(n+1), n=0..4 */);

    /* Sigma delta modulation is disabled or "bypassed". We set the bypass bit. */
    PLLDIG->PLLFM = PLLDIG_PLLFM_SSCGBYP(1u);
    PLLDIG->PLLFD = PLLDIG_PLLFD_SMDEN(0u)
                    | PLLDIG_PLLFD_SDM2(0u)
                    | PLLDIG_PLLFD_SDM3(0u)
                    | PLLDIG_PLLFD_DTHDIS(1u /* 0: enable, 1: disabled */);

    /* Write denominator fractional loop divider */
    PLLDIG->PLLCAL3 = PLLDIG_PLLCAL3_MFDEN(9999u /* TBC */);

    /* Enable PLL. See RM, section 38.3.10. */
    MC_ME->DRUN_MC |= MC_ME_DRUN_MC_PLLON(1u);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* All clock soures are running. Now connect the system clocks to the principal clock
       source, the PLL. */
    
    /* Select the system clock source in a read modify write access to register DRUN_MC. */
    MC_ME->DRUN_MC = MC_ME->DRUN_MC
                     & ~MC_ME_GS_S_SYSCLK_MASK
                     | MC_ME_GS_S_SYSCLK(2u /* clock source is PLL, PHI_0 */);

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* S160 clock */
    MC_CGM->SC_DC0 = MC_CGM_SC_DC0_DIV(0u /* divide by n+1 */)
                     | MC_CGM_SC_DC0_DE(1u /* enable */);

    /* S80 clock */
    MC_CGM->SC_DC1 = MC_CGM_SC_DC1_DIV(1u /* divide by n+1 */)
                     | MC_CGM_SC_DC1_DE(1u /* enable */);

    /* S40 clock */
    MC_CGM->SC_DC2 = MC_CGM_SC_DC2_DIV(3u /* divide by n+1 */)
                     | MC_CGM_SC_DC2_DE(1u /* enable */);

    /* F80, F40 and F20 are not configurable. */

    /* FS80 clock */
    MC_CGM->SC_DC5 = MC_CGM_SC_DC5_DIV(1u /* divide by n+1 */)
                     | MC_CGM_SC_DC5_DE(1u /* enable */);

    /* Connect the peripherals to the appropriate system clocks. See RM 31, MC_CGM.*/

    /* Ethernet clock (ENET0_CLK and ENET1_CLK). See RM 9.4.3.6, 31.3.29 and 42. */
    MC_CGM->AC2_SC = MC_CGM_AC2_SC_SELCTL(0u /* 0: F40, 1: external clock */);

    /* Secure Digital Host Controller (uSDHC) clock. See RM 31.3.32 and 49. */
    MC_CGM->AC4_SC = MC_CGM_AC4_SC_SELCTL(0u /* 0: F40, 1: external clock */);

    /* CLKOUT_0, RM 31.2. The selector of the signal is ambiguously documented. In RM
       31.3.34 we see the choice of PLL_CLKOUT1 and PLL_CLOCKOUT2, while figure 31-9 names
       the same signals PHI_0 and PHI_1. The latter naming is found back in section 9,
       where the PLL and its outputs are shown in the clocking overview. */
    MC_CGM->AC6_SC = MC_CGM_AC6_SC_SELCTL(3u /* S160 clock. See RM 31.3.34 */);
    MC_CGM->AC6_DC0 = MC_CGM_AC6_DC0_DIV(15u /* divide by n+1, RM 31.3.36 */)
                      | MC_CGM_AC6_DC0_DE(1u /* 1: enable */);

    /* CLKOUT_1, RM 31.2
         SELCTL:
         0 FXOSC
         2: SXOSC
         6: Z2 clock
         14: PLL_CLOCKOUT1
         Caution, see before, CLKOUT_0, the description of the selector for the other
       clockout signal makes use of ambiguous names for the PLL output signals. If we
       compare, then it's most likely, that choice 14, "PLL_CLOCKOUT1", means PHI_0. */
    MC_CGM->CLKOUT1_SC = MC_CGM_CLKOUT1_SC_SELCTL(0u /*  See RM 31.3.1 */);
    MC_CGM->CLKOUT1_DC = MC_CGM_CLKOUT1_DC_DIV(79u /* divide by n+1 */)
                         | MC_CGM_CLKOUT1_DC_DE(1u /* 1: enable */);

    /* SPI0, RM 31.3.6 */
    MC_CGM->AC8_SC = MC_CGM_AC8_SC_SELCTL(0u /* 0: F40, 1: FXOSC */);

    /* FlexCAN0, RM 31.3.8 */
    MC_CGM->AC9_SC = MC_CGM_AC9_SC_SELCTL(0u /* 0: FS80, 1: FXOSC */);

    /* The peripherals are clocked in all RUN, DRUN and SAFE mode but not in RESET. See RM,
       38.3.21. Enabling the peripheral clocks in run configuration 0 means that no
       peripheral-specific clock enabling needs to be done later - after reset all
       peripherals refer by default to run configuration 0 (out of eight available
       configurations). */
    MC_ME->RUN_PC[0] = 0xFCu;

    /* Changes take effect after mode transition. See RM, 38.3.2. */
    ccl_triggerTransitionToModeDRUN();

    /* Flash configuration depends on chosen system clock and is therefore done here, in
       the same context: At reset the flash controller initializes with a conservative,
       safe setting for wait states and pipelining. Now, after choosing the clock rate we
       can adjust to the recommended settings for this clock. The recommendations for 160
       MHz system clock can be found in the MPC5748G Microcontroller Data Sheet, section
       6.3.6, Flash read wait state and address pipeline control settings, Table 34.
         Note, these changes can't be done by normal register writes. The code execution
       must itself not depend on the flash. We call a routine, which is running in some RAM
       area. */
    cfl_configureFlash(/* RWSC_waitStates */ 4, /* APC_pipelining */ 1);

} /* end of ccl_configureClocks */
