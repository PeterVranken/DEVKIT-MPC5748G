/**
 * @file cdr_interruptServiceHandlers.c
 * This file holds the collection of the ISRs needed to serve the CAN devices.\n
 *   Basically, ISRs are device dependent, but the registered handlers branch soon into
 * other functions, which implement most of the actual handler operation. This way, we have
 * a lot of code sharing between the devices. Still, the number of required registered
 * handler is huge.\n
 *   The large number of registered ISRs is generated by a number of macros, which take
 * device index and related information as macro and can then expand to the needed,
 * specific, registered ISR. Note, the definition of these macros resembles a normal
 * function implementation much more than a typical preprocessor macro. Consequently, we've
 * put them in the function section, where they belong from the logical aspect, rather
 * than in the define section.\n
 *   To enable the implementation of the interrupt services in a common, shared way, we
 * need some lookup tables for device specific settings or data. These are found here, too.
 *
 * Copyright (C) 2020 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   cdr_osRegisterInterrupts
 * Local functions
 *   isrError
 *   ISR_GROUP_ERROR (macro to produce error group ISR)
 *   isrBusOff
 *   ISR_GROUP_BUS_OFF (macro to produce group ISR for bus-off related events)
 *   isrRxFIFOOverflow
 *   isrRxFIFOWarning
 *   isrRxFIFOFramesAvailable
 *   ISR_GROUP_RX_FIFO (macro to produce FIFO group ISR)
 *   isrMailbox
 *   ISR_GROUP_MAILBOX (macro to produce mailbox group ISRs)
 */

/*
 * Include files
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "MPC5748G.h"
#include "cdr_MPC5748G_CAN.h"

#include "rtos.h"
#include "cdr_canDriverAPI.h"
#include "cdr_interruptServiceHandlers.h"


/*
 * Defines
 */


/*
 * Local type definitions
 */


/*
 * Local prototypes
 */

/* Prototypes for all ISRs on all enabled devices. */
#define PROTOTYPES_OF_CAN_ISRS(canDev)              \
static void isrGroupRxFIFO_##canDev(void);          \
/* static void isrGroupError_##canDev(void);   */       \
static void isrGroupMB0_3_##canDev(void);           \
static void isrGroupMB4_7_##canDev(void);           \
static void isrGroupMB8_11_##canDev (void);         \
static void isrGroupMB12_15_##canDev(void);         \
static void isrGroupMB16_31_##canDev(void);         \
static void isrGroupMB32_63_##canDev(void);         \
static void isrGroupMB64_95_##canDev(void);

#if CDR_ENABLE_USE_OF_CAN_0 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_7)
#endif
#undef PROTOTYPES_OF_CAN_ISRS


/*
 * Data definitions
 */


/*
 * Function implementation
 */

/**
 * This is the ISR to handle the FLEXCAN_0_ESR interrupt. It reports that at least one of
 * the Error Bits (BIT1ERR, BIT0ERR, ACKERR. CRCERR, FRMERR or STFERR) is set. (See RM
 * 43.4.9, p. 1733.) The handler counts the event, records the cause and optionally invokes
 * a notification callback for further processing in the client code.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnErr
 * The notification callback into the client code of the driver. Can be NULL to indicate
 * "no notification requested".
 *   @param ESR1
 * The value of the status register ESR1 as found on entry into the ISR.
 */
static void isrError( CAN_Type * const pDevice
                    , cdr_canDeviceData_t * const pDeviceData
                    , cdr_osCallbackOnError_t osCallbackOnErr
                    , uint32_t ESR1
                    )
{
    assert((ESR1 & CAN_ESR1_ERRINT_MASK) != 0);

    /* We record the situation in a global counter. */
    const unsigned int noErr = pDeviceData->noErrEvents+1;
    if(noErr != 0)
        pDeviceData->noErrEvents = noErr;

    /* Check error condition. */
    const uint32_t errMask = CAN_ESR1_STFERR_MASK | CAN_ESR1_FRMERR_MASK | CAN_ESR1_CRCERR_MASK
                             | CAN_ESR1_BIT0ERR_MASK | CAN_ESR1_BIT1ERR_MASK
                             | CAN_ESR1_ACKERR_MASK
                             ;

    /* We record the last recently seen error bits in a global variable. */
    _Static_assert((errMask & 0xffff) == errMask, "Invalid truncation to 16 Bit");
    pDeviceData->lastErrEvent = (uint16_t)(ESR1 & errMask);

    /* Reset the interrupt and overflow flag prior to doing the notification. This
       enables the hardware to catch the next problem already while the callback is
       executing.
         RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
       status and error bits. Acknowledge the IRQ by w1c.
         Note, this doesn't affect the status and error bits. These had already been
       negated by the read of the ESR1. */
    pDevice->ESR1 = CAN_ESR1_ERRINT_MASK | CAN_ESR1_ERROVR_MASK; /* Clear bits by "w1c" */

    /* Do a notification of the client code if configured. */
    if(osCallbackOnErr != NULL)
        osCallbackOnErr(/* isCanFD */ false, ESR1);

} /* End of isrError */




#define ISR_GROUP_ERROR(canDev)                                                            \
/**                                                                                        \
 * Common ISR for the two Error interrupts (INTERR and INTERR_FAST). It looks for the      \
 * causing IRQ and branches in the dedicated handler. Interrupt acknowledge needs to be    \
 * done in the dedicated handler.                                                          \
 */                                                                                        \
static void isrGroupError_##canDev(void)                                                   \
{                                                                                          \
    CAN_Type * const pDevice = (canDev);                                                   \
                                                                                           \
    /* Read the cause of the error. RM 43.4.9, p. 1727ff. Note, the error bits (not */     \
    /* the interrupt flags and the over overflow bit) are reset by this read. */           \
    const uint32_t ESR1 = pDevice->ESR1;                                                   \
                                                                                           \
    if((ESR1 & CAN_ESR1_ERRINT_MASK) != 0)                                                 \
    {                                                                                      \
        isrError( pDevice                                                                  \
                , &cdr_canDriverData[cdr_canDev_##canDev]                                  \
                , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupError.osCallbackOnError \
                , ESR1                                                                     \
                );                                                                         \
    }                                                                                      \
    else if((ESR1 & CAN_ESR1_ERRINT_FAST_MASK) != 0)                                       \
        assert(false); /* FD not supported, ISR not implemented. */                        \
    else                                                                                   \
        assert(false);                                                                     \
                                                                                           \
} /* End of isrGroupError_##canDev */



/**
 * This is the ISR to handle the enter/leave bus off state interrupts (ESR1[BOFF_INT] and
 * ESR1[BOFFDONEINT], see RM 43.4.9, p. 1733 and RM 23.1.2 INTC interrupt sources, Table
 * 23-1, p.532. The handler counts occurances, maintains the bus off state for the device
 * and optionally invokes a notification callback for further processing in the client
 * code.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnBusOff
 * The notification callback into the client code of the driver. Can be NULL to indicate
 * "no notification requested".
 *   @param ESR1
 * The value of the status register ESR1 as found on entry into the ISR.
 *   @remark
 * Our CAN driver has enabled the optio auto-recover from a bus-off state. Therefore,
 * letting the ISR record and notify the situation may already be sufficient. We don't need
 * to actually do something.
 */
static void isrBusOff( CAN_Type * const pDevice
                     , cdr_canDeviceData_t * const pDeviceData
                     , cdr_osCallbackOnError_t osCallbackOnBusOff
                     , uint32_t ESR1
                     )
{
    assert((ESR1 & (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_BOFFDONEINT_MASK)) != 0);

    if((ESR1 & CAN_ESR1_BOFFINT_MASK) != 0)
    {
        /* This IRQ notifies entering the bus off state. */
        pDeviceData->isBusOff = true;

        /* We record the situation in a global counter. */
        const unsigned int noErr = pDeviceData->noBusOffEvents+1;
        if(noErr != 0)
            pDeviceData->noBusOffEvents = noErr;

        /* Reset the interrupt flag prior to doing the notification. This enables the
           hardware to catch the next problem already while the callback is executing.
             RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
           status and error bits. Acknowledge the IRQ by w1c.
             Note, this doesn't affect the status and error bits. These had already been
           negated by the read of the ESR1. */
        pDevice->ESR1 = CAN_ESR1_BOFFINT_MASK; /* Clear bits by "w1c" */
    }
    else
    {
        /* This IRQ notifies leaving the bus off state, returning to normal operation. */
        assert((ESR1 & CAN_ESR1_BOFFDONEINT_MASK) != 0);
        pDeviceData->isBusOff = false;

        /* Reset the interrupt flag prior to doing the notification. This enables the
           hardware to catch the next problem already while the callback is executing.
             RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
           status and error bits. Acknowledge the IRQ by w1c.
             Note, this doesn't affect the status and error bits. These had already been
           negated by the read of the ESR1. */
        pDevice->ESR1 = CAN_ESR1_BOFFDONEINT_MASK; /* Clear bits by "w1c" */

    } /* End if(Enter or leave bus-off state?) */

    /* Do a notification of the client code if configured. */
    if(osCallbackOnBusOff != NULL)
        osCallbackOnBusOff(/* enteringBusOff */ pDeviceData->isBusOff, ESR1);

} /* End of isrBusOff */




#define ISR_GROUP_BUS_OFF(canDev)                                                            \
/**                                                                                          \
 * Common ISR for the bus off related interrupts (BOFFERR, BOFFDONEINT, TWRNINT and          \
 * RWRNINT). It looks for the causing IRQ and branches in the dedicated handler. Interrupt   \
 * acknowledge needs to be done in the dedicated handler.                                    \
 */                                                                                          \
static void isrGroupBusOff_##canDev(void)                                                    \
{                                                                                            \
    CAN_Type * const pDevice = (canDev);                                                     \
                                                                                             \
    /* Read the cause of the error. RM 43.4.9, p. 1727ff. Note, the error bits (not */       \
    /* the interrupt flags and the over overflow bit) are reset by this read. */             \
    const uint32_t ESR1 = pDevice->ESR1;                                                     \
                                                                                             \
    if((ESR1 & (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_BOFFDONEINT_MASK)) != 0)                    \
    {                                                                                        \
        isrBusOff( pDevice                                                                   \
                 , &cdr_canDriverData[cdr_canDev_##canDev]                                   \
                 , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupBusOff.osCallbackOnBusOff\
                 , ESR1                                                                      \
                 );                                                                          \
    }                                                                                        \
    else if((ESR1 & CAN_ESR1_TWRNINT_MASK) != 0)                                             \
        assert(false); /* This IRQ is not enabled in our driver. */                          \
    else if((ESR1 & CAN_ESR1_RWRNINT_MASK) != 0)                                             \
        assert(false); /* This IRQ is not enabled in our driver. */                          \
    else                                                                                     \
        assert(false);                                                                       \
                                                                                             \
} /* End of isrGroupBusOff_##canDev */



/**
 * This is the ISR to handle the situation that a received CAN message can't be placed into
 * the Rx FIFO because it is still full. The message is lost. The ISR records the situation
 * but can recover from the data loss.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOOverflow( CAN_Type * const pDevice
                             , cdr_canDeviceData_t * const pDeviceData
                             )
{
    /* For now, we just record the situation in a global counter. */
    const unsigned int noErr = pDeviceData->noRxFIFOOverflowEvents+1;
    if(noErr != 0)
        pDeviceData->noRxFIFOOverflowEvents = noErr;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOOverflow = CAN_IFLAG1_BUF7I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOOverflow) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOOverflow; /* Clear bit by "w1c" */

} /* End of isrRxFIFOOverflow */




/**
 * This is the ISR to handle the situation that Rx FIFO is nearly full. A message is
 * however not lost yet. The ISR just records the situation but doesn't take an action.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOWarning( CAN_Type * const pDevice
                            , cdr_canDeviceData_t * const pDeviceData
                            )
{
    /* For now, we just record the situation in a counter. */
    const unsigned int noWarn = pDeviceData->noRxFIFOWarningEvents+1;
    if(noWarn != 0)
        pDeviceData->noRxFIFOWarningEvents = noWarn;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOWarn = CAN_IFLAG1_BUF6I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOWarn) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOWarn; /* Clear bit by "w1c" */

} /* End of isrRxFIFOWarning */




/**
 * This is the principal ISR of the Rx FIFO. It is called on completion of an reception.
 * The ISR fetches the payload and some additional information from the CAN device's
 * registers and invokes a callback to some external code, that does do the further
 * evalutaion of the received message data.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnRx
 * The notification callback into the client code of the driver.
 */
static void isrRxFIFOFramesAvailable( CAN_Type * const pDevice
                                    , cdr_canDeviceData_t * const pDeviceData
                                    , cdr_osCallbackOnRx_t osCallbackOnRx
                                    )
{
    /* RM 43.4.43, p. 1785: The FIFO is read through the first mailbox in the device RAM.
         Note, the fields inside the C/S word are a bit differently defined as for normal
       mailboxes and we need to apply other access macros. */
    volatile cdr_mailbox_t * const pRxMB = cdr_getMailboxByIdx(pDevice, /* idxMB */ 0);

    /* The ISR doesn't need to loop over all messages currently held in the FIFO. The HW
       maintains the flag coherently with the FIFO contents. If several messages are
       contained then it'll re-assert the flag and we will enter this ISR immediately
       again. (See RM 43.5.8, p. 1810) */
    const uint32_t irqMaskRxFIFO = CAN_IFLAG1_BUF5I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFO) != 0);

    /* Record the Rx situation in a counter. */
    ++ pDeviceData->noRxMsgsFIFO;

    const uint32_t csWord = pRxMB->csWord
                 , canIdWord = pRxMB->canId;
    const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
    const unsigned int idHit = (csWord & CAN_FIFOCS_IDHIT_MASK) >> CAN_FIFOCS_IDHIT_SHIFT
                     , DLC = (csWord & CAN_FIFOCS_DLC_MASK) >> CAN_FIFOCS_DLC_SHIFT
                     , timeStamp = (csWord & CAN_FIFOCS_TIME_STAMP_MASK)
                                   >> CAN_FIFOCS_TIME_STAMP_SHIFT
                     , canId = isExtID? (canIdWord & CAN_FIFOID_ID_EXT_MASK)
                                        >> CAN_FIFOID_ID_EXT_SHIFT
                                      : (canIdWord & CAN_FIFOID_ID_STD_MASK)
                                        >> CAN_FIFOID_ID_STD_SHIFT
                     ;

    /* Copy received bytes into local buffer for callback invokation. We copy
       unconditionally. Having conditional code or a byte loop would not save any time. */
    assert(DLC <= 8);
    uint32_t payload_u32[2];
    payload_u32[0] = pRxMB->payload_u32[0];
    payload_u32[1] = pRxMB->payload_u32[1];

    /* Acknowledge the IRQ. For normal MBs, we need to do this prior to reading the
       timer (which unlocks the MB and would enable a re-assertion of the interrupt
       flag). */
    pDevice->IFLAG1 = irqMaskRxFIFO; /* Clear bit by "w1c" */

    /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
       (side-effect of reading). We are ready for next reception while the user
       notification callback is running in parallel. See 43.5.7.3 Mailbox lock mechanism,
       p. 1808ff, for more details. */
    (void)pDevice->TIMER;

    /* Invoke the callback for further data processing.
         Note, a NULL Pointer check is not needed at run-time. We have double
       checked the configuration at driver initialization time. (Which won't hinder
       us from having an assertion here.) */
    assert(osCallbackOnRx != NULL);
    (*osCallbackOnRx)( /* hMB */ idHit
                     , isExtID
                     , canId
                     , DLC
                     , (const uint8_t *)&payload_u32[0]
                     , timeStamp
                     );
} /* End of isrRxFIFOFramesAvailable */



#define ISR_GROUP_RX_FIFO(canDev)                                                           \
/**                                                                                         \
 * Common ISR for all of the Rx FIFO interrupts. It looks for the causing IRQ and branches  \
 * in the dedicated handler. Interrupt acknowledge needs to be done in the dedicated        \
 * handler.                                                                                 \
 */                                                                                         \
static void isrGroupRxFIFO_##canDev(void)                                                   \
{                                                                                           \
    CAN_Type * const pDevice = (canDev);                                                    \
    if((pDevice->IFLAG1 & CAN_IFLAG1_BUF5I_MASK) != 0)                                      \
    {                                                                                       \
        isrRxFIFOFramesAvailable                                                            \
                    ( pDevice                                                               \
                    , &cdr_canDriverData[cdr_canDev_##canDev]                               \
                    , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupFIFO.osCallbackOnRx  \
                    );                                                                      \
    }                                                                                       \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF6I_MASK) != 0)                                 \
        isrRxFIFOWarning(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                 \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF7I_MASK) != 0)                                 \
        isrRxFIFOOverflow(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                \
    else                                                                                    \
        assert(false);                                                                      \
                                                                                            \
} /* End of isrGroupRxFIFO_##canDev */



/**
 * This is the common part of the implementation of all mailbox ISRs. It is called on
 * completion of a reception or transmission.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pIFLAG
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here related register IFLAG1/2/3 of the CAN device by reference.
 *   @param idxMBFrom
 * This is the mailbox index of the first mailbox, in the group, which possibly requested
 * the IRQ. It is the index of the mailbox, whose interrupt flag is found with \a maskFrom
 * in flag register * \a pIFLAG.
 *   @param offsMBIdxToHdl
 * For normal mailboxes, their handle value is larger than their index in the hardware
 * array. (Because the lower index range designates the FIFI filter entries, which are more
 * than the mailboxes that are substituted by the FIFO.) Here, we have the offset between
 * the two - needed for the feedback to the client code.
 *   @param maskFrom
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the first
 * mailbox, which possibly requested the IRQ.
 *   @param maskTo
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the last
 * mailbox in the given group, which possibly requested the IRQ.
 *   @param pIrqConfig
 * The user provided configuration of the applicable interrupt group is passed by
 * reference. It is required to identify the notification callback into the client code.
 */
static void isrMailbox( CAN_Type * const pDevice
                      , volatile uint32_t *pIFLAG
                      , unsigned int idxMBFrom
                      , unsigned int offsMBIdxToHdl
                      , uint32_t maskFrom
                      , uint32_t maskTo
                      , const cdr_irqConfig_t * const pIrqConfig
                      )
{
    while(true)
    {
        /* Check mailbox candidate for newly received input. */
        if((*pIFLAG & maskFrom) == 0)
        {
            /* This is not the causing mailbox - try next one. */
            if(maskFrom == maskTo)
            {
                /* This code must be never reached. We are in the ISR but don't see any of
                   the related interrupt flags set. All we can do is ignoring the interrupt
                   request. Evidently, there's not even a flag bit to reset. */
                assert(false);
                return;
            }
            else
            {
                /* This is not the causing mailbox - try next one. */
                ++ idxMBFrom;
                maskFrom <<= 1;
                continue;
            }
        } /* End if(Did we identify the interrupt requesting mailbox?) */

        /* If we get here then we have found the causing mailbox. It is mailbox
           idxMBFrom. */
        volatile cdr_mailbox_t * const pMB = cdr_getMailboxByIdx(pDevice, idxMBFrom);

        /* Read the mailbox CODE: It tells whether we have an Rx or Tx message and what
           happened. See RM 43.4.40, p. 1771ff, Tables 43-8 and 43-9, for the different
           status codes. */
        const uint32_t csWord = pMB->csWord
                     , canIdWord = pMB->canId;
        const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
        const unsigned int DLC = (csWord & CAN_MBCS_DLC_MASK) >> CAN_MBCS_DLC_SHIFT
                         , timeStamp = (csWord & CAN_MBCS_TIME_STAMP_MASK)
                                       >> CAN_MBCS_TIME_STAMP_SHIFT
                         , canId = isExtID? (canIdWord & CAN_MBID_ID_EXT_MASK)
                                            >> CAN_MBID_ID_EXT_SHIFT
                                          : (canIdWord & CAN_MBID_ID_STD_MASK)
                                            >> CAN_MBID_ID_STD_SHIFT
                         ;
        const uint32_t CODE = (csWord & CAN_MBCS_CODE_MASK) >> CAN_MBCS_CODE_SHIFT;
        const bool isRx = (CODE & 0x8) == 0;

        /* Inside the ISR, the busy bit in CODE should never be asserted. */
        /// @todo The polling function occasionally saw the interrupt flag set but CODE
        // still signalling "busy with move-in". So this may happen here, too. In which
        // case we would return from interrupt without acknowledging the interrupt - such
        // that it is raised immediately again (or a while loop, busy waiting for
        // CODE[0]=0?) Effectively, not acknowledging the IRQ is the same as a buys-wait
        // loop but with much longer cycle time. So the local busy wait surely is the
        // better way. Maybe, we will never see this effect due to the latency time of the
        // interrupt - should we then still implement the loop? What about delayed IRQ
        // processing, so that we hit the move-in of the successor message?
        assert((CODE & 0x1) == 0);

        /* For Rx messages, we save the payload data prior to acknowledgingthe reception at
           the HW. */
        uint32_t payload_u32[2]; /* Definition as u32 ensures a safe alignment. */
        if(isRx)
        {
            /* We have an Rx mailbox interrupt. */
            assert(CODE == 2 /* FULL */  ||  CODE == 6 /* OVERRUN */);

            /* Copy received bytes into local buffer for callback invokation. We copy
               unconditionally. Having conditional code or a byte loop would not save any
               time. */
            assert(DLC <= 8);
            payload_u32[0] = pMB->payload_u32[0];
            payload_u32[1] = pMB->payload_u32[1];
        }

        /* RM 43.4.12/13/21, p. 1735ff: Acknowledge the IRQ. We need to do this prior to
           reading the timer (which unlocks the MB and would enable a re-assertion of the
           interrupt flag). */
        *pIFLAG = maskFrom; /* Clear bit by "w1c" */

        /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
           (side-effect of reading). See 43.5.7.3 Mailbox lock mechanism, p. 1808ff for
           more details.
             From now on, the mailbox is ready for next reception/transmission. At least
           for Tx, it is essential that we release it prior to invokingthe notification
           callback into the client code: The client could implement a buffering strategy
           that wants to re-use the mailboxe immediately again for the subsequent message.
           For Rx, it just better to do this before notifying; mailbox hardware and
           callback software can run in parallel. */
        (void)pDevice->TIMER;

        /* Down here, no access to the device hardware is allowed any more. */

        /* The index of the mailbox in the device requires a simple transformation to
           become the mailbox handle. */
        const unsigned int hMB = idxMBFrom + offsMBIdxToHdl;

        if(isRx)
        {
            /* We have an Rx mailbox interrupt. */

            /* Invoke the callback in the client code for further data processing.
                 Note, a NULL Pointer check is not needed at run-time. We have double
               checked the configuration at driver initialization time. (Which won't hinder
               us from having an assertion here.) */
            assert(pIrqConfig->osCallbackOnRx != NULL);
            (*pIrqConfig->osCallbackOnRx)( hMB
                                         , isExtID
                                         , canId
                                         , DLC
                                         , (const uint8_t *)&payload_u32[0]
                                         , timeStamp
                                         );
        }
        else
        {
            /* We have a Tx mailbox interrupt. */

            assert(CODE == 8 /* INACTIVE */  ||  CODE == 9 /* ABORT */);

            /* Invoke the callback in the client code for further data processing.
                 Note, a NULL Pointer check is not needed at run-time. We have double
               checked the configuration at driver initialization time. (Which won't hinder
               us from having an assertion here.) */
            assert(pIrqConfig->osCallbackOnRx != NULL);
            (*pIrqConfig->osCallbackOnTx)( hMB
                                         , isExtID
                                         , canId
                                         , DLC
                                         , /* isAborted */ CODE == 9
                                         , timeStamp
                                         );
        }
    }
} /* End of isrMailbox */




#define ISR_GROUP_MAILBOX(canDev, idxIFLAG, idxFrom, idxTo)                                 \
/**                                                                                         \
 * Common ISR for the mailbox interrupts of mailboxes idxFrom till and including idxTo. It  \
 * branches in the common mailbox interrupt handler implementation with the information     \
 * about which CAN device and which mailbox group caused the reset. Interrupt acknowledge   \
 * needs to be done in the common mailbox handler. Splitting this ISR from the common       \
 * implementation of mailbox processing avoids code duplication for all mailbox interrupts. \
 */                                                                                         \
static void isrGroupMB##idxFrom##_##idxTo##_##canDev(void)                                  \
{                                                                                           \
    _Static_assert( (idxIFLAG) >= 1  &&  (idxIFLAG) <= 3                                    \
                    &&  (idxFrom) >= 0  &&  (idxFrom) <= 64                                 \
                    &&  (idxTo)-(idxFrom)+1 >= 4  &&  (idxTo)-(idxFrom)+1 <= 32             \
                    &&  ((idxTo)-(idxFrom)+1) % 4 == 0                                      \
                    &&  (idxFrom)/32 == (idxTo)/32                                          \
                    &&  cdr_canDev_##canDev < sizeOfAry(cdr_canDriverConfig)                \
                  , "Bad arguments passed to macro ISR_GROUP_MAILBOX to generate mailbox"   \
                    " ISR"                                                                  \
                  );                                                                        \
                                                                                            \
    const cdr_canDeviceConfig_t * const pDeviceConfig =                                     \
                                        &cdr_canDriverConfig[cdr_canDev_##canDev];          \
                                                                                            \
    /* The index of the mailbox in the device and the mailbox handle are related by a */    \
    /* non-zero offset if the FIFO is enabled. Needed for client notification. */           \
    const unsigned int MBHdlMinusIdx = 6u*pDeviceConfig->CTRL2_RFFN;                        \
                                                                                            \
    /* Here, we know very well, which device and interrupt we are. We can figure out, which \
       interrupt flag register to use with which masks and all of this without any runtime  \
       overhead: The macro arguments idxFrom and idxTo are constants and what looks like    \
       runtime computation in the source code is just loading a constant value into the     \
       register the compiled code. */                                                       \
    volatile uint32_t * const pIFLAG = &canDev->IFLAG##idxIFLAG;                            \
    const uint32_t maskFrom = 1u << ((idxFrom)-32u*((idxIFLAG)-1u))                         \
                 , maskTo   = 1u << ((idxTo)  -32u*((idxIFLAG)-1u));                        \
    isrMailbox( canDev                                                                      \
              , pIFLAG                                                                      \
              , (idxFrom)                                                                   \
              , MBHdlMinusIdx                                                               \
              , maskFrom                                                                    \
              , maskTo                                                                      \
              , &pDeviceConfig->irqGroupMB##idxFrom##_##idxTo                               \
              );                                                                            \
} /* End of isrGroupMB##idxFrom##_##idxTo##_##canDev */



/* We need the ISRs for each device separately. This is done easiest by making the set of
   ISRs for a single device a define, which is then repeatedly applied. */
/// @todo Error interrupts (bus off, Rx and Tx Warning) have been promised in the
/// configuration but not been implemented yet
#define SET_OF_DEVICE_ISRS(idxCanDev)                                                       \
ISR_GROUP_RX_FIFO(CAN_##idxCanDev)                                                          \
ISR_GROUP_ERROR(CAN_##idxCanDev)                                                            \
ISR_GROUP_BUS_OFF(CAN_##idxCanDev)                                                          \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 0, /* idxTo */ 3)        \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 4, /* idxTo */ 7)        \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 8, /* idxTo */ 11)       \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 12, /* idxTo */ 15)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 16, /* idxTo */ 31)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 2, /* idxFrom */ 32, /* idxTo */ 63)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 3, /* idxFrom */ 64, /* idxTo */ 95)

#if CDR_ENABLE_USE_OF_CAN_0 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 7)
#endif

#undef ISR_GROUP_RX_FIFO
#undef ISR_GROUP_MAILBOX
#undef SET_OF_DEVICE_ISRS



/**
 * Our locally implemented interrupt handlers are registered at the operating system for
 * serving the mailbox and FIFO interrupts.
 *   @param idxCanDevice
 * The CAN device to register the interrupts for by index. The available index range
 * depends on the configuration of the set of enabled CAN devices, see e.g.
 * #CDR_ENABLE_USE_OF_CAN_0. The most convenient way to provide the appropriate index is
 * using enumeration cdr_canDevice_t.
 */
void cdr_osRegisterInterrupts(unsigned int idxCanDevice)
{
    assert(idxCanDevice < sizeOfAry(cdr_canDriverConfig));
    const cdr_canDeviceConfig_t * const pDeviceConfig = &cdr_canDriverConfig[idxCanDevice];

    /** Helper macro to maintian readability of initializer expression of next data object,
        a constant table of interrupt handlers. */
    #define SET_OF_CAN_ISRS(canDev)                 \
    { .isrGroupFIFO = isrGroupRxFIFO_##canDev,      \
      .isrGroupError = isrGroupError_##canDev,      \
      .isrGroupBusOff = isrGroupBusOff_##canDev,    \
      .isrGroupMB0_3 = isrGroupMB0_3_##canDev,      \
      .isrGroupMB4_7 = isrGroupMB4_7_##canDev,      \
      .isrGroupMB8_11 = isrGroupMB8_11_##canDev,    \
      .isrGroupMB12_15 = isrGroupMB12_15_##canDev,  \
      .isrGroupMB16_31 = isrGroupMB16_31_##canDev,  \
      .isrGroupMB32_63 = isrGroupMB32_63_##canDev,  \
      .isrGroupMB64_95 = isrGroupMB64_95_##canDev,  \
    },

    /** This is a table, which holds pointers to all required ISRs. It is just needed to have a
        function that registers these interrupts. The alternative would be a long list of
        dedicated calls of the register-function. Either solutions won't make a significant
        difference in terms of ROM consumption. */
    static const struct setOfCanISRs_t
    {
        void (*isrGroupFIFO)(void);   /** Hdlr for all Rx FIFO related interrupts. */
        void (*isrGroupError)(void);  /** Hdlr for all interrupts ERRINT and ERRINT_FAST. */
        void (*isrGroupBusOff)(void); /** Hdlr for all Bus off and warning interrupts. */
        void (*isrGroupMB0_3)(void);  /** Hdlr for all Rc/Tx interrupts of mailboxes 0..3. */
        void (*isrGroupMB4_7)(void);  /** Hdlr for all Rc/Tx interrupts of mailboxes 4..7. */
        void (*isrGroupMB8_11)(void); /** Hdlr for all Rc/Tx interrupts of mailboxes 8..11. */
        void (*isrGroupMB12_15)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 12..15. */
        void (*isrGroupMB16_31)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 16..31. */
        void (*isrGroupMB32_63)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 32..63. */
        void (*isrGroupMB64_95)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 64..95. */

    } mapDevIdxToISRGroup_[cdr_canDev_noCANDevicesEnabled] =
        {
#if CDR_ENABLE_USE_OF_CAN_0 == 1
            SET_OF_CAN_ISRS(CAN_0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
            SET_OF_CAN_ISRS(CAN_1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
            SET_OF_CAN_ISRS(CAN_2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
            SET_OF_CAN_ISRS(CAN_3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
            SET_OF_CAN_ISRS(CAN_4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
            SET_OF_CAN_ISRS(CAN_5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
            SET_OF_CAN_ISRS(CAN_6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
            SET_OF_CAN_ISRS(CAN_7)
#endif
    };
    #undef SET_OF_CAN_ISRS

    /* Interrupt offsets are taken from MCU reference manual, see 23.1.2 INTC interrupt
       sources, p. 523ff, Table 23-1.
         The interrupts are regularly defined, therefore we can compute the wanted
       number. The only exception is the very first IRQ, related to pretended network,
       which is available only in device CAN_0. */
    #define IDX_IRQ_CAN_FIFO(idxDev)                    (IDX_IRQ_CAN_MB(idxDev, /* idxMB */ 5))
    #define IDX_IRQ_CAN_ERROR(idxDev)                   (CAN0_Error_IRQn + 12*(idxDev))
    #define IDX_IRQ_CAN_BOFF_OR_TX_WARN(idxDev)         (CAN0_ORed_IRQn + 12*(idxDev))
    #define IDX_IRQ_CAN_MB(idxDev, idxMB)                                                     \
                            (CAN0_ORed_00_03_MB_IRQn + 12u*(idxDev)                           \
                             + ((idxMB)<16u? (idxMB)/4u: ((idxMB)<32u? 4u: (idxMB-32)/32u+5u))\
                            )

    /* A few sample tests. */
    _Static_assert( IDX_IRQ_CAN_ERROR(0) == CAN0_Error_IRQn
                    &&  IDX_IRQ_CAN_ERROR(7) == CAN7_Error_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(1) == CAN1_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(6) == CAN6_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(7) == CAN7_ORed_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 0) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 3) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 5) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 7) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(1, 4) == CAN1_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(2, 8) == CAN2_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 11) == CAN3_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 12) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 15) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(4, 16) == CAN4_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 17) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 31) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 32) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 33) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 32) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 63) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 64) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 95) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 0) == CAN7_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_FIFO(0) == IDX_IRQ_CAN_MB(0, 5)
                    &&  IDX_IRQ_CAN_FIFO(3) == IDX_IRQ_CAN_MB(3, 6)
                    &&  IDX_IRQ_CAN_FIFO(7) == IDX_IRQ_CAN_MB(7, 7)
                  , "Test of computation of IRQ vector numbers failed"
                  );

    /* Register our IRQ handlers. */
    assert(idxCanDevice < sizeOfAry(mapDevIdxToISRGroup_));

    /* Register the error interrupts. Actually, we just have ERRINT. The only other
       interrupt in this group, ERRINT_FAST, relates to CAN FD. */
    rtos_osRegisterInterruptHandler
            ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupError
            , /* processorID */   pDeviceConfig->irqGroupError.idxTargetCore
            , /* vectorNum */     IDX_IRQ_CAN_ERROR(idxCanDevice)
            , /* psrPriority */   pDeviceConfig->irqGroupError.irqPrio
            , /* isPreemptable */ true
            );

    /* Register the bus off interrupts. Actually, we only support BOFFINT and BOFFDONEINT.
       The two warning IRQs (error counter exceeds first watermark) are not handled and not
       enabled. */
    rtos_osRegisterInterruptHandler
            ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupBusOff
            , /* processorID */   pDeviceConfig->irqGroupBusOff.idxTargetCore
            , /* vectorNum */     IDX_IRQ_CAN_BOFF_OR_TX_WARN(idxCanDevice)
            , /* psrPriority */   pDeviceConfig->irqGroupBusOff.irqPrio
            , /* isPreemptable */ true
            );

    if(pDeviceConfig->isFIFOEnabled)
    {
        /* Register the FIFO interrupts. */
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupFIFO
                , /* processorID */   pDeviceConfig->irqGroupFIFO.idxTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO(idxCanDevice)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFO.irqPrio
                , /* isPreemptable */ true
                );
    }

    /* With enabled FIFO, the first mailboxes are not in normal operation and we must
       not register their interrupts. */
    const unsigned int idxFirstNormalMailbox = cdr_getIdxOfFirstNormalMailbox(pDeviceConfig);
    #define REGISTER_ISR(idxFrom, idxTo)                                                    \
    if(idxFirstNormalMailbox <= (idxTo))                                                    \
    {                                                                                       \
        rtos_osRegisterInterruptHandler                                                     \
            ( /* ISR */ mapDevIdxToISRGroup_[idxCanDevice].isrGroupMB##idxFrom##_##idxTo    \
            , /* processorID */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo.idxTargetCore  \
            , /* vectorNum */ IDX_IRQ_CAN_MB(idxCanDevice, /* idxMB */ (idxTo))             \
            , /* psrPriority */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo.irqPrio        \
            , /* isPreemptable */ true                                                      \
            );                                                                              \
    }
    REGISTER_ISR(/* idxFrom */ 0, /* idxTo */ 3)
    REGISTER_ISR(/* idxFrom */ 4, /* idxTo */ 7)
    REGISTER_ISR(/* idxFrom */ 8, /* idxTo */ 11)
    REGISTER_ISR(/* idxFrom */ 12, /* idxTo */ 15)
    REGISTER_ISR(/* idxFrom */ 16, /* idxTo */ 31)
    REGISTER_ISR(/* idxFrom */ 32, /* idxTo */ 63)
    REGISTER_ISR(/* idxFrom */ 64, /* idxTo */ 95)
    #undef REGISTER_ISR

    #undef IDX_IRQ_CAN_FIFO
    #undef IDX_IRQ_CAN_ERROR
    #undef IDX_IRQ_CAN_BOFF_OR_TX_WARN
    #undef IDX_IRQ_CAN_MB
} /* End of cdr_osRegisterInterrupts */



