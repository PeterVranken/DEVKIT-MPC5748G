/**
 * @file cdr_interruptServiceHandlers.c
 * This file holds the collection of the ISRs needed to serve the CAN devices.\n
 *   Basically, ISRs are device dependent, but the registered handlers branch soon into
 * other functions, which implement most of the actual handler operation. This way, we have
 * a lot of code sharing between the devices. Still, the number of required registered
 * handlers is huge.\n
 *   The large number of registered ISRs is generated by a number of macros, which take
 * device index and related information as argument and can then expand to the needed,
 * specific, registered ISR. Note, the definition of these macros resembles a normal
 * function implementation much more than a typical preprocessor macro. Consequently, we've
 * put them in the function section of this file, where they belong from the logical
 * aspect, rather than in the define section.
 *
 * Copyright (C) 2020 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   cdr_osRegisterInterrupts
 * Local functions
 *   isrError
 *   ISR_GROUP_ERROR (macro to produce error group ISR)
 *   isrBusOff
 *   ISR_GROUP_BUS_OFF (macro to produce group ISR for bus-off related events)
 *   isrRxFIFOOverflow
 *   isrRxFIFOWarning
 *   isrRxFIFOFramesAvailable
 *   ISR_GROUP_RX_FIFO (macro to produce FIFO group ISR)
 *   isrMailbox
 *   ISR_MAILBOX (macro to produce mailbox ISR)
 *   ISR_GROUP_MAILBOX (macro to produce mailbox group ISRs)
 */

/*
 * Include files
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "cde_canDriver.config.MCUDerivative.h"
#include "rtos.h"
#include "cdr_searchIFlag.h"
#include "cdr_canDriverAPI.h"
#include "cdr_interruptServiceHandlers_mcuMacros.h"
#include "cdr_interruptServiceHandlers.h"


/*
 * Defines
 */


/*
 * Local type definitions
 */


/*
 * Local prototypes
 */


/*
 * Data definitions
 */


/*
 * Function implementation
 */

/**
 * This is the ISR to handle the FLEXCAN_0_ESR interrupt. It reports that at least one of
 * the Error Bits (BIT1ERR, BIT0ERR, ACKERR. CRCERR, FRMERR or STFERR) is set. (See RM
 * 43.4.9, p. 1733.) The handler counts the event, records the cause and optionally invokes
 * a notification callback for further processing in the client code.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnErr
 * The notification callback into the client code of the driver. Can be NULL to indicate
 * "no notification requested".
 *   @param ESR1
 * The value of the status register ESR1 as found on entry into the ISR.
 */
static void isrError( CAN_Type * const pDevice
                    , cdr_canDeviceData_t * const pDeviceData
                    , cdr_osCallbackOnError_t osCallbackOnErr
                    , uint32_t ESR1
                    )
{
    assert((ESR1 & CAN_ESR1_ERRINT_MASK) != 0);

    /* We record the situation in a global counter. */
    const unsigned int noErr = pDeviceData->noErrEvents+1;
    if(noErr != 0)
        pDeviceData->noErrEvents = noErr;

    /* Check error condition. */
    const uint32_t errMask = CAN_ESR1_STFERR_MASK | CAN_ESR1_FRMERR_MASK | CAN_ESR1_CRCERR_MASK
                             | CAN_ESR1_BIT0ERR_MASK | CAN_ESR1_BIT1ERR_MASK
                             | CAN_ESR1_ACKERR_MASK
                             ;

    /* We record the last recently seen error bits in a global variable. */
    _Static_assert((errMask & 0xffff) == errMask, "Invalid truncation to 16 Bit");
    pDeviceData->lastErrEvent = (uint16_t)(ESR1 & errMask);

    /* Reset the interrupt and overflow flag prior to doing the notification. This
       enables the hardware to catch the next problem already while the callback is
       executing.
         RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
       status and error bits. Acknowledge the IRQ by w1c.
         Note, this doesn't affect the status and error bits. These had already been
       negated by the read of the ESR1. */
    pDevice->ESR1 = CAN_ESR1_ERRINT_MASK    /* Clear bit by "w1c" */
#if defined(MCU_MPC5748G)
                    | CAN_ESR1_ERROVR_MASK  /* Clear bit by "w1c" */
#endif
                    ;

    /* Do a notification of the client code if configured. */
    if(osCallbackOnErr != NULL)
        osCallbackOnErr(/* isCanFD */ false, ESR1);

} /* End of isrError */




#define ISR_GROUP_ERROR(canDev)                                                            \
/**                                                                                        \
 * Common ISR for the two Error interrupts (INTERR and INTERR_FAST). It looks for the      \
 * causing IRQ and branches in the dedicated handler. Interrupt acknowledge needs to be    \
 * done in the dedicated handler.                                                          \
 */                                                                                        \
static void isrGroupError_##canDev(void)                                                   \
{                                                                                          \
    CAN_Type * const pDevice = (canDev);                                                   \
                                                                                           \
    /* Read the cause of the error. RM 43.4.9, p. 1727ff. Note, the error bits (not */     \
    /* the interrupt flags and the over overflow bit) are reset by this read. */           \
    const uint32_t ESR1 = pDevice->ESR1;                                                   \
                                                                                           \
    if((ESR1 & CAN_ESR1_ERRINT_MASK) != 0)                                                 \
    {                                                                                      \
        isrError( pDevice                                                                  \
                , &cdr_canDriverData[cdr_canDev_##canDev]                                  \
                , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupError.osCallbackOnError \
                , ESR1                                                                     \
                );                                                                         \
    }                                                                                      \
    /* MPC5748G: FD not supported, ISR not implemented. MPC5775B/E: FD not available */    \
    /* else if((ESR1 & CAN_ESR1_ERRINT_FAST_MASK) != 0) */                                 \
    /*     assert(false);                               */                                 \
    else                                                                                   \
        assert(false);                                                                     \
                                                                                           \
} /* End of isrGroupError_##canDev */



/**
 * This is the ISR to handle the enter/leave bus off state interrupts (ESR1[BOFF_INT] and
 * ESR1[BOFFDONEINT], see RM 43.4.9, p. 1733 and RM 23.1.2 INTC interrupt sources, Table
 * 23-1, p.532. The handler counts occurances, maintains the bus off state for the device
 * and optionally invokes a notification callback for further processing in the client
 * code.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnBusOff
 * The notification callback into the client code of the driver. Can be NULL to indicate
 * "no notification requested".
 *   @param ESR1
 * The value of the status register ESR1 as found on entry into the ISR.
 *   @remark
 * Our CAN driver has enabled the optio auto-recover from a bus-off state. Therefore,
 * letting the ISR record and notify the situation may already be sufficient. We don't need
 * to actually do something.
 */
static void isrBusOff( CAN_Type * const pDevice
                     , cdr_canDeviceData_t * const pDeviceData
                     , cdr_osCallbackOnError_t osCallbackOnBusOff
                     , uint32_t ESR1
                     )
{
#ifndef MCU_MPC5748G

    assert((ESR1 & CAN_ESR1_BOFFINT_MASK) != 0);

#else /* MPC5748G offers bus off done IRQ */

    assert((ESR1 & (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_BOFFDONEINT_MASK)) != 0);

    if((ESR1 & CAN_ESR1_BOFFINT_MASK) != 0)
    {
        /* This IRQ notifies entering the bus off state. */
        pDeviceData->isBusOff = true;
#endif
        /* We record the situation in a global counter. */
        const unsigned int noErr = pDeviceData->noBusOffEvents+1;
        if(noErr != 0)
            pDeviceData->noBusOffEvents = noErr;

        /* Reset the interrupt flag prior to doing the notification. This enables the
           hardware to catch the next problem already while the callback is executing.
             RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
           status and error bits. Acknowledge the IRQ by w1c.
             Note, this doesn't affect the status and error bits. These had already been
           negated by the read of the ESR1. */
        pDevice->ESR1 = CAN_ESR1_BOFFINT_MASK; /* Clear bits by "w1c" */
#ifdef MCU_MPC5748G
    }
    else
    {
        /* This IRQ notifies leaving the bus off state, returning to normal operation. */
        assert((ESR1 & CAN_ESR1_BOFFDONEINT_MASK) != 0);
        pDeviceData->isBusOff = false;

        /* Reset the interrupt flag prior to doing the notification. This enables the
           hardware to catch the next problem already while the callback is executing.
             RM 43.4.9, p. 1727ff: The error word contains the interrupt flag aside to the
           status and error bits. Acknowledge the IRQ by w1c.
             Note, this doesn't affect the status and error bits. These had already been
           negated by the read of the ESR1. */
        pDevice->ESR1 = CAN_ESR1_BOFFDONEINT_MASK; /* Clear bits by "w1c" */

    } /* End if(Enter or leave bus-off state?) */
#endif

    /* Do a notification of the client code if configured. */
    if(osCallbackOnBusOff != NULL)
    {
#ifdef MCU_MPC5748G
        osCallbackOnBusOff(/* enteringBusOff */ pDeviceData->isBusOff, ESR1);
#else
        osCallbackOnBusOff(/* enteringBusOff */ true, ESR1);
#endif
    }
} /* End of isrBusOff */



/* Sub-expression for generic implementation of ISR for interrut group bus off, which is
   required to support different MCU derivatives. */
#if defined(MCU_MPC5748G)
# define BOFFINT_MASK   (CAN_ESR1_BOFFINT_MASK | CAN_ESR1_BOFFDONEINT_MASK)
#elif defined(MCU_MPC5775B)  ||  defined(MCU_MPC5775E)
# define BOFFINT_MASK   (CAN_ESR1_BOFFINT_MASK)
#else
# error Implementation does not support selected MCU derivative
#endif


#define ISR_GROUP_BUS_OFF(canDev)                                                            \
/**                                                                                          \
 * Common ISR for the bus off related interrupts (BOFFERR, BOFFDONEINT, TWRNINT and          \
 * RWRNINT). It looks for the causing IRQ and branches in the dedicated handler. Interrupt   \
 * acknowledge needs to be done in the dedicated handler.                                    \
 */                                                                                          \
static void isrGroupBusOff_##canDev(void)                                                    \
{                                                                                            \
    CAN_Type * const pDevice = (canDev);                                                     \
                                                                                             \
    /* Read the cause of the error. RM 43.4.9, p. 1727ff. Note, the error bits (not */       \
    /* the interrupt flags and the over overflow bit) are reset by this read. */             \
    const uint32_t ESR1 = pDevice->ESR1;                                                     \
                                                                                             \
    if((ESR1 & BOFFINT_MASK) != 0)                                                           \
    {                                                                                        \
        isrBusOff( pDevice                                                                   \
                 , &cdr_canDriverData[cdr_canDev_##canDev]                                   \
                 , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupBusOff.osCallbackOnBusOff\
                 , ESR1                                                                      \
                 );                                                                          \
    }                                                                                        \
    else if((ESR1 & CAN_ESR1_TWRNINT_MASK) != 0)                                             \
        assert(false); /* This IRQ is not enabled in our driver. */                          \
    else if((ESR1 & CAN_ESR1_RWRNINT_MASK) != 0)                                             \
        assert(false); /* This IRQ is not enabled in our driver. */                          \
    else                                                                                     \
        assert(false);                                                                       \
                                                                                             \
} /* End of isrGroupBusOff_##canDev */



/**
 * This is the ISR to handle the situation that a received CAN message can't be placed into
 * the Rx FIFO because it is still full. The message is lost. The ISR records the situation
 * but can recover from the data loss.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOOverflow( CAN_Type * const pDevice
                             , cdr_canDeviceData_t * const pDeviceData
                             )
{
    /* For now, we just record the situation in a global counter. */
    const unsigned int noErr = pDeviceData->noRxFIFOOverflowEvents+1;
    if(noErr != 0)
        pDeviceData->noRxFIFOOverflowEvents = noErr;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOOverflow = CAN_IFLAG1_BUF7I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOOverflow) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOOverflow; /* Clear bit by "w1c" */

} /* End of isrRxFIFOOverflow */




/**
 * This is the ISR to handle the situation that Rx FIFO is nearly full. A message is
 * however not lost yet. The ISR just records the situation but doesn't take an action.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOWarning( CAN_Type * const pDevice
                            , cdr_canDeviceData_t * const pDeviceData
                            )
{
    /* For now, we just record the situation in a counter. */
    const unsigned int noWarn = pDeviceData->noRxFIFOWarningEvents+1;
    if(noWarn != 0)
        pDeviceData->noRxFIFOWarningEvents = noWarn;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOWarn = CAN_IFLAG1_BUF6I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOWarn) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOWarn; /* Clear bit by "w1c" */

} /* End of isrRxFIFOWarning */




/**
 * This is the principal ISR of the Rx FIFO. It is called on completion of an reception.
 * The ISR fetches the payload and some additional information from the CAN device's
 * registers and invokes a callback to some external code, that does do the further
 * evalutaion of the received message data.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param osCallbackOnRx
 * The notification callback into the client code of the driver.
 */
static void isrRxFIFOFramesAvailable( CAN_Type * const pDevice
                                    , cdr_canDeviceData_t * const pDeviceData
                                    , cdr_osCallbackOnRx_t osCallbackOnRx
                                    )
{
    /* RM 43.4.43, p. 1785: The FIFO is read through the first mailbox in the device RAM.
         Note, the fields inside the C/S word are a bit differently defined as for normal
       mailboxes and we need to apply other access macros. */
    volatile cdr_mailbox_t * const pRxMB = cdr_getMailboxByIdx(pDevice, /* idxMB */ 0);

    /* The ISR doesn't need to loop over all messages currently held in the FIFO. The HW
       maintains the flag coherently with the FIFO contents. If several messages are
       contained then it'll re-assert the flag and we will enter this ISR immediately
       again. (See RM 43.5.8, p. 1810) */
    const uint32_t irqMaskRxFIFO = CAN_IFLAG1_BUF5I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFO) != 0);

    /* Record the Rx situation in a counter. */
    ++ pDeviceData->noRxMsgsFIFO;

    const uint32_t csWord = pRxMB->csWord
                 , canIdWord = pRxMB->canId;
    const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
    const unsigned int idHit = (csWord & CAN_FIFOCS_IDHIT_MASK) >> CAN_FIFOCS_IDHIT_SHIFT
                     , DLC = (csWord & CAN_FIFOCS_DLC_MASK) >> CAN_FIFOCS_DLC_SHIFT
                     , timeStamp = (csWord & CAN_FIFOCS_TIME_STAMP_MASK)
                                   >> CAN_FIFOCS_TIME_STAMP_SHIFT
                     , canId = isExtID? (canIdWord & CAN_FIFOID_ID_EXT_MASK)
                                        >> CAN_FIFOID_ID_EXT_SHIFT
                                      : (canIdWord & CAN_FIFOID_ID_STD_MASK)
                                        >> CAN_FIFOID_ID_STD_SHIFT
                     ;

    /* Copy received bytes into local buffer for callback invokation. We copy
       unconditionally. Having conditional code or a byte loop would not save any time. */
    assert(DLC <= 8);
    uint32_t payload_u32[2];
    payload_u32[0] = pRxMB->payload_u32[0];
    payload_u32[1] = pRxMB->payload_u32[1];

    /* Acknowledge the IRQ. For normal MBs, we need to do this prior to reading the
       timer (which unlocks the MB and would enable a re-assertion of the interrupt
       flag). */
    pDevice->IFLAG1 = irqMaskRxFIFO; /* Clear bit by "w1c" */

    /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
       (side-effect of reading). We are ready for next reception while the user
       notification callback is running in parallel. See 43.5.7.3 Mailbox lock mechanism,
       p. 1808ff, for more details. */
    (void)pDevice->TIMER;

    /* Invoke the callback for further data processing.
         Note, a NULL Pointer check is not needed at run-time. We have double
       checked the configuration at driver initialization time. (Which won't hinder
       us from having an assertion here.) */
    assert(osCallbackOnRx != NULL);
    (*osCallbackOnRx)( /* hMB */ idHit
                     , isExtID
                     , canId
                     , DLC
                     , (const uint8_t *)&payload_u32[0]
                     , timeStamp
                     );
} /* End of isrRxFIFOFramesAvailable */



#if defined(MCU_MPC5748G)
# define ISR_GROUP_RX_FIFO(canDev)                                                          \
/**                                                                                         \
 * Common ISR for all of the Rx FIFO interrupts. It looks for the causing IRQ and branches  \
 * in the dedicated handler. Interrupt acknowledge needs to be done in the dedicated        \
 * handler.                                                                                 \
 */                                                                                         \
static void isrGroupRxFIFO_##canDev(void)                                                   \
{                                                                                           \
    CAN_Type * const pDevice = (canDev);                                                    \
    if((pDevice->IFLAG1 & CAN_IFLAG1_BUF5I_MASK) != 0)                                      \
    {                                                                                       \
        isrRxFIFOFramesAvailable                                                            \
                    ( pDevice                                                               \
                    , &cdr_canDriverData[cdr_canDev_##canDev]                               \
                    , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupFIFO.osCallbackOnRx  \
                    );                                                                      \
    }                                                                                       \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF6I_MASK) != 0)                                 \
        isrRxFIFOWarning(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                 \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF7I_MASK) != 0)                                 \
        isrRxFIFOOverflow(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                \
    else                                                                                    \
        assert(false);                                                                      \
                                                                                            \
} /* End of isrGroupRxFIFO_##canDev */

#else /* MPC5775B/E */

# define ISR_GROUP_RX_FIFO(canDev)                                                          \
/**                                                                                         \
 * ISR for the Rx FIFO on-reception interrupt. It loads some context information and        \
 * branches into the shared implementation of the dedicated handler. Interrupt acknowledge  \
 * needs to be done in the dedicated handler.                                               \
 */                                                                                         \
static void isrRxFIFORx_##canDev(void)                                                      \
{                                                                                           \
    isrRxFIFOFramesAvailable                                                                \
                ( (canDev)                                                                  \
                , &cdr_canDriverData[cdr_canDev_##canDev]                                   \
                , cdr_canDriverConfig[cdr_canDev_##canDev].irqGroupFIFO.osCallbackOnRx      \
                );                                                                          \
} /* End of isrRxFIFORx_##canDev */                                                         \
                                                                                            \
                                                                                            \
/**                                                                                         \
 * ISR for the Rx FIFO warning interrupt. It loads some context information and branches    \
 * into the shared implementation of the dedicated handler. Interrupt acknowledge needs to  \
 * be done in the dedicated handler.                                                        \
 */                                                                                         \
static void isrRxFIFOWarning_##canDev(void)                                                 \
{                                                                                           \
    isrRxFIFOWarning((canDev), &cdr_canDriverData[cdr_canDev_##canDev]);                    \
                                                                                            \
} /* End of isrRxFIFOWarning_##canDev */                                                    \
                                                                                            \
                                                                                            \
/**                                                                                         \
 * ISR for the Rx FIFO overflow interrupt. It loads some context information and branches   \
 * into the shared implementation of the dedicated handler. Interrupt acknowledge needs to  \
 * be done in the dedicated handler.                                                        \
 */                                                                                         \
static void isrRxFIFOOverflow_##canDev(void)                                                \
{                                                                                           \
    isrRxFIFOOverflow((canDev), &cdr_canDriverData[cdr_canDev_##canDev]);                   \
                                                                                            \
} /* End of isrRxFIFOOverflow_##canDev */

#endif /* Which MCU derivative */



/**
 * This is the common part of the implementation of all mailbox ISRs. It is called on
 * completion of a reception or transmission.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pIFLAG
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here related register IFLAG1/2/3 of the CAN device by reference.
 *   @param idxMBFrom
 * This is the mailbox index of the first mailbox, in the group, which possibly requested
 * the IRQ. It is the index of the mailbox, whose interrupt flag is found with \a maskFrom
 * in flag register * \a pIFLAG.
 *   @param offsMBIdxToHdl
 * For normal mailboxes, their handle value is larger than their index in the hardware
 * array. (Because the lower index range designates the FIFI filter entries, which are more
 * than the mailboxes that are substituted by the FIFO.) Here, we have the offset between
 * the two - needed for the feedback to the client code.
 *   @param maskFrom
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the first
 * mailbox, which possibly requested the IRQ.
 *   @param maskTo
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the last
 * mailbox in the given group, which possibly requested the IRQ.
 *   @param pIrqConfig
 * The user provided configuration of the applicable interrupt group is passed by
 * reference. It is required to identify the notification callback into the client code.
 */
static void isrMailbox( CAN_Type * const pDevice
                      , volatile uint32_t * const pIFLAG
                      , uint32_t irqMask
                      , unsigned int idxMB
                      , unsigned int offsMBIdxToHdl
                      , const cdr_irqConfig_t * const pIrqConfig
                      )
{
    /* The IRQ causing mailbox has HW index idxMBFrom (which is due to a possible FFO not
       the handle visible to the client code. */
    volatile cdr_mailbox_t * const pMB = cdr_getMailboxByIdx(pDevice, idxMB);

    /* Read the mailbox CODE: It tells whether we have an Rx or Tx message and what
       happened. See RM 43.4.40, p. 1771ff, Tables 43-8 and 43-9, for the different
       status codes. */
    const uint32_t csWord = pMB->csWord
                 , canIdWord = pMB->canId;
    const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
    const unsigned int DLC = (csWord & CAN_MBCS_DLC_MASK) >> CAN_MBCS_DLC_SHIFT
                     , timeStamp = (csWord & CAN_MBCS_TIME_STAMP_MASK)
                                   >> CAN_MBCS_TIME_STAMP_SHIFT
                     , canId = isExtID? (canIdWord & CAN_MBID_ID_EXT_MASK)
                                        >> CAN_MBID_ID_EXT_SHIFT
                                      : (canIdWord & CAN_MBID_ID_STD_MASK)
                                        >> CAN_MBID_ID_STD_SHIFT
                     ;
    const uint32_t CODE = (csWord & CAN_MBCS_CODE_MASK) >> CAN_MBCS_CODE_SHIFT;
    const bool isRx = (CODE & 0x8) == 0;

    /* Inside the ISR, the busy bit in CODE should never be asserted. */
    assert((CODE & 0x1) == 0);

    /* For Rx messages, we save the payload data prior to acknowledging the reception at
       the HW. */
    uint32_t payload_u32[2]; /* Definition as u32 ensures a safe alignment. */
    if(isRx)
    {
        /* We have an Rx mailbox interrupt. */
        assert(CODE == 2 /* FULL */  ||  CODE == 6 /* OVERRUN */);

        /* Copy received bytes into local buffer for callback invocation. We copy
           unconditionally. Having conditional code or a byte loop would not save any
           time. */
        assert(DLC <= 8);
        payload_u32[0] = pMB->payload_u32[0];
        payload_u32[1] = pMB->payload_u32[1];
    }

    /* RM 43.4.12/13/21, p. 1735ff: Acknowledge the IRQ. We need to do this prior to
       reading the timer (which unlocks the MB and would enable a re-assertion of the
       interrupt flag). */
    assert((*pIFLAG & irqMask) != 0);
    *pIFLAG = irqMask; /* Clear bit by "w1c" */

    /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
       (side-effect of reading). See 43.5.7.3 Mailbox lock mechanism, p. 1808ff for
       more details.
         From now on, the mailbox is ready for next reception/transmission. At least
       for Tx, it is essential that we release it prior to invoking the notification
       callback into the client code: The client could implement a buffering strategy
       that wants to re-use the mailbox immediately again for the subsequent message.
       For Rx, it just better to do this before notifying; mailbox hardware and
       callback software can run in parallel. */
    (void)pDevice->TIMER;

    /* Down here, no access to the device hardware is allowed any more. */

    /* The index of the mailbox in the device requires a simple transformation to
       become the mailbox handle. */
    const unsigned int hMB = idxMB + offsMBIdxToHdl;

    if(isRx)
    {
        /* We have an Rx mailbox interrupt. */

        /* Invoke the callback in the client code for further data processing.
             Note, a NULL Pointer check is not needed at run-time. We have double
           checked the configuration at driver initialization time. (Which won't hinder
           us from having an assertion here.) */
        assert(pIrqConfig->osCallbackOnRx != NULL);
        (*pIrqConfig->osCallbackOnRx)( hMB
                                     , isExtID
                                     , canId
                                     , DLC
                                     , (const uint8_t *)&payload_u32[0]
                                     , timeStamp
                                     );
    }
    else
    {
        /* We have a Tx mailbox interrupt. */

        assert(CODE == 8 /* INACTIVE */  ||  CODE == 9 /* ABORT */);

        /* Invoke the callback in the client code for further data processing.
             Note, a NULL Pointer check is not needed at run-time. We have double
           checked the configuration at driver initialization time. (Which won't hinder
           us from having an assertion here.) */
        assert(pIrqConfig->osCallbackOnTx != NULL);
        (*pIrqConfig->osCallbackOnTx)( hMB
                                     , isExtID
                                     , canId
                                     , DLC
                                     , /* isAborted */ CODE == 9
                                     , timeStamp
                                     );
    }
} /* End of isrMailbox */




#if defined(MCU_MPC5775B)  ||  defined(MCU_MPC5775E)
# define ISR_MAILBOX(canDev, idxMB)                                                         \
/**                                                                                         \
 * Common ISR for the mailbox interrupts of mailbox idxMB. It branches in the common        \
 * mailbox interrupt handler implementation with the information about which CAN device and \
 * which mailbox caused the request. Interrupt acknowledge needs to be done in the common   \
 * mailbox handler. Splitting this ISR from the common implementation of mailbox processing \
 * avoids code duplication for all mailbox interrupts.                                      \
 */                                                                                         \
static void isrMB##idxMB##_##canDev(void)                                                   \
{                                                                                           \
    _Static_assert( (idxMB) >= 0  &&  (idxMB) <= 15                                         \
                    &&  cdr_canDev_##canDev < sizeOfAry(cdr_canDriverConfig)                \
                  , "Bad arguments passed to macro ISR_MAILBOX to generate mailbox ISR"     \
                  );                                                                        \
                                                                                            \
    const cdr_canDeviceConfig_t * const pDeviceConfig =                                     \
                                        &cdr_canDriverConfig[cdr_canDev_##canDev];          \
                                                                                            \
    /* The index of the mailbox in the device and the mailbox handle are related by a */    \
    /* non-zero offset if the FIFO is enabled. Needed for client notification. */           \
    const unsigned int MBHdlMinusIdx = cdr_getAdditionalCapacityDueToFIFO(pDeviceConfig);   \
                                                                                            \
    /* Here, we know very well, which device and interrupt we are. We know, which           \
       interrupt flag register to use with which mask. */                                   \
    volatile uint32_t * const pIFLAG = &canDev->IFLAG1;                                     \
    isrMailbox( canDev                                                                      \
              , pIFLAG                                                                      \
              , /* irqMask */ 1u<<idxMB                                                     \
              , idxMB                                                                       \
              , MBHdlMinusIdx                                                               \
              , &pDeviceConfig->irqMB##idxMB                                                \
              );                                                                            \
} /* End of isrMB##idxMB##_##canDev */

#endif /* MPC5775B/E only */



#define ISR_GROUP_MAILBOX(canDev, idxIFLAG, idxFrom, idxTo, sizeGrpAsPow2)                  \
/**                                                                                         \
 * Common ISR for the mailbox interrupts of mailboxes idxFrom till and including idxTo. It  \
 * branches in the common mailbox interrupt handler implementation with the information     \
 * about which CAN device and which mailbox group caused the request. Interrupt acknowledge \
 * needs to be done in the common mailbox handler. Splitting this ISR from the common       \
 * implementation of mailbox processing avoids code duplication for all mailbox interrupts. \
 */                                                                                         \
static void isrGroupMB##idxFrom##_##idxTo##_##canDev(void)                                  \
{                                                                                           \
    _Static_assert( (idxIFLAG) >= 1  &&  (idxIFLAG) <= 3                                    \
                    &&  (idxFrom) >= 0  &&  (idxFrom) <= 64                                 \
                    &&  (idxTo)-(idxFrom)+1 >= 4  &&  (idxTo)-(idxFrom)+1 <= 32             \
                    &&  (idxTo)-(idxFrom)+1 == 1u<<(sizeGrpAsPow2)                          \
                    &&  ((idxTo)-(idxFrom)+1) % 4 == 0                                      \
                    &&  (idxFrom)/32 == (idxTo)/32                                          \
                    &&  cdr_canDev_##canDev < sizeOfAry(cdr_canDriverConfig)                \
                  , "Bad arguments passed to macro ISR_GROUP_MAILBOX to generate mailbox"   \
                    " ISR"                                                                  \
                  );                                                                        \
                                                                                            \
    const cdr_canDeviceConfig_t * const pDeviceConfig =                                     \
                                        &cdr_canDriverConfig[cdr_canDev_##canDev];          \
                                                                                            \
    /* The index of the mailbox in the device and the mailbox handle are related by a */    \
    /* non-zero offset if the FIFO is enabled. Needed for client notification. */           \
    const unsigned int MBHdlMinusIdx = cdr_getAdditionalCapacityDueToFIFO(pDeviceConfig);   \
                                                                                            \
    /* Here, we know very well, which device and interrupt we are. We can figure out, which \
       interrupt flag register to use with which masks and all of this without any runtime  \
       overhead: The macro arguments idxFrom and idxTo are constants and what looks like    \
       runtime computation in the source code is just loading a constant value into the     \
       register or using an immediate shift distance in the compiled code. */               \
    _Static_assert                                                                          \
            ( offsetof(CAN_Type, IMASK##idxIFLAG)                                           \
              + 2*sizeof(uint32_t) == offsetof(CAN_Type, IFLAG##idxIFLAG)                   \
            , "Implementation doesn't match the register structure of the CAN device"       \
            );                                                                              \
    volatile uint32_t * const pIFLAG = &canDev->IFLAG##idxIFLAG                             \
                    , * const pIMASK = pIFLAG-2;                                            \
    const unsigned int shiftGrpInIFLAG = (idxFrom)-32u*((idxIFLAG)-1u);                     \
    const uint32_t maskedIFLAGRightAligned = (*pIFLAG & *pIMASK) >> shiftGrpInIFLAG;        \
    const unsigned int idxIrqInIFLAG = cdr_findAssertedBitInWord( maskedIFLAGRightAligned   \
                                                                , sizeGrpAsPow2             \
                                                                )                           \
                                       + shiftGrpInIFLAG;                                   \
    assert(idxIrqInIFLAG - shiftGrpInIFLAG <= (idxTo)-(idxFrom)+1);                         \
    isrMailbox( canDev                                                                      \
              , pIFLAG                                                                      \
              , /* irqMask */ 1u<<idxIrqInIFLAG                                             \
              , /* idxMB */ idxIrqInIFLAG + 32u*((idxIFLAG)-1u)                             \
              , MBHdlMinusIdx                                                               \
              , &pDeviceConfig->irqGroupMB##idxFrom##_##idxTo                               \
              );                                                                            \
} /* End of isrGroupMB##idxFrom##_##idxTo##_##canDev */



/* We need the ISRs for each device separately. This is done easiest by making the set of
   ISRs for a single device a define, which is then repeatedly applied. */
#if CDR_ENABLE_USE_OF_CAN_0 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
IMPLEMENTATION_OF_DEVICE_ISRS(/* idxFlexCAN_x */ 7)
#endif

#undef ISR_GROUP_RX_FIFO
#undef ISR_GROUP_MAILBOX



/**
 * Our locally implemented interrupt handlers are registered at the operating system for
 * serving the mailbox and FIFO interrupts.
 *   @param idxCanDevice
 * The CAN device to register the interrupts for by index. The available index range
 * depends on the configuration of the set of enabled CAN devices, see e.g.
 * #CDR_ENABLE_USE_OF_CAN_0. The most convenient way to provide the appropriate index is
 * using enumeration cdr_canDevice_t.
 */
void cdr_osRegisterInterrupts(unsigned int idxCanDevice)
{
    assert(idxCanDevice < sizeOfAry(cdr_canDriverConfig));
    const cdr_canDeviceConfig_t * const pDeviceConfig = &cdr_canDriverConfig[idxCanDevice];
    const unsigned int idxFlexCAN_x = cdr_mapIdxToCanDevice[idxCanDevice].idxFlexCAN_x;

    /** This is a table, which holds pointers to all required ISRs. It is just needed to have a
        function that registers these interrupts. The alternative would be a long list of
        dedicated calls of the register-function. Either solutions won't make a significant
        difference in terms of ROM consumption. */
    static const cdr_setOfCanDeviceISRs_t mapDevIdxToISRGroup_[cdr_canDev_noCANDevicesEnabled]=
    {
#if CDR_ENABLE_USE_OF_CAN_0 == 1
        SET_OF_DEVICE_ISRS(CAN_0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
        SET_OF_DEVICE_ISRS(CAN_1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
        SET_OF_DEVICE_ISRS(CAN_2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
        SET_OF_DEVICE_ISRS(CAN_3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
        SET_OF_DEVICE_ISRS(CAN_4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
        SET_OF_DEVICE_ISRS(CAN_5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
        SET_OF_DEVICE_ISRS(CAN_6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
        SET_OF_DEVICE_ISRS(CAN_7)
#endif
    };


    /* A few sample tests of macros for computation of IRQ numbers. */
#if defined(MCU_MPC5748G)
    _Static_assert( IDX_IRQ_CAN_ERROR(0) == CAN0_Error_IRQn
                    &&  IDX_IRQ_CAN_ERROR(7) == CAN7_Error_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(1) == CAN1_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(6) == CAN6_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(7) == CAN7_ORed_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 0) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 3) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 5) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 7) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(1, 4) == CAN1_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(2, 8) == CAN2_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 11) == CAN3_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 12) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 15) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(4, 16) == CAN4_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 17) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 31) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 32) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 33) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 32) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 63) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 64) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 95) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 0) == CAN7_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_FIFO(0) == IDX_IRQ_CAN_MB(0, 5)
                    &&  IDX_IRQ_CAN_FIFO(3) == IDX_IRQ_CAN_MB(3, 6)
                    &&  IDX_IRQ_CAN_FIFO(7) == IDX_IRQ_CAN_MB(7, 7)
                  , "Test of computation of IRQ vector numbers failed"
                  );
#else /* MPC5775B/E */
    _Static_assert( IDX_IRQ_CAN_ERROR(0) == CAN0_ESR2_IRQn
                    &&  IDX_IRQ_CAN_ERROR(3) == CAN3_ESR2_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(0) == CAN0_ESR1_IRQn
                    &&  IDX_IRQ_CAN_FIFO_RX(1) == CAN1_BUF5_IRQn
                    &&  IDX_IRQ_CAN_FIFO_WARN(2) == CAN2_BUF6_IRQn
                    &&  IDX_IRQ_CAN_FIFO_FULL(3) == CAN3_BUF7_IRQn
                  , "Test of computation of IRQ vector numbers failed"
                  );
#endif

    /* Register our IRQ handlers. */
    assert(idxCanDevice < sizeOfAry(mapDevIdxToISRGroup_));

    /* Register the error interrupts. Actually, we just have ERRINT. The only other
       interrupt in this group, ERRINT_FAST, relates to CAN FD. */
    rtos_osRegisterInterruptHandler
            ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupError
            , /* processorID */   pDeviceConfig->irqGroupError.idxTargetCore
            , /* vectorNum */     IDX_IRQ_CAN_ERROR(idxFlexCAN_x)
            , /* psrPriority */   pDeviceConfig->irqGroupError.irqPrio
            , /* isPreemptable */ true
            );

    /* Register the bus off interrupts. Actually, we only support BOFFINT and BOFFDONEINT.
       The two warning IRQs (error counter exceeds first watermark) are not handled and not
       enabled. */
    rtos_osRegisterInterruptHandler
            ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupBusOff
            , /* processorID */   pDeviceConfig->irqGroupBusOff.idxTargetCore
            , /* vectorNum */     IDX_IRQ_CAN_BOFF_OR_TX_WARN(idxFlexCAN_x)
            , /* psrPriority */   pDeviceConfig->irqGroupBusOff.irqPrio
            , /* isPreemptable */ true
            );

    if(pDeviceConfig->isFIFOEnabled)
    {
        /* Register the FIFO interrupts. */
#if defined(MCU_MPC5748G)
        /* The MPC5748G has one interrupt for all Rx FIFO events. */
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupFIFO
                , /* processorID */   pDeviceConfig->irqGroupFIFO.idxTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO(idxFlexCAN_x)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFO.irqPrio
                , /* isPreemptable */ true
                );
#else /* MPC5775B/E */
        /* The MPC5775B/E have three distinct interrupts for the Rx FIFO events.
           Regardless, there's only one related configuration item: All the three events
           are handled by the same core on same priority level. */
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrFIFORx
                , /* processorID */   pDeviceConfig->irqGroupFIFO.idxTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO_RX(idxFlexCAN_x)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFO.irqPrio
                , /* isPreemptable */ true
                );
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrFIFOWarning
                , /* processorID */   pDeviceConfig->irqGroupFIFO.idxTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO_WARN(idxFlexCAN_x)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFO.irqPrio
                , /* isPreemptable */ true
                );
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrFIFOOverflow
                , /* processorID */   pDeviceConfig->irqGroupFIFO.idxTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO_FULL(idxFlexCAN_x)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFO.irqPrio
                , /* isPreemptable */ true
                );
#endif
    }

    /* With enabled FIFO, the first mailboxes are not in normal operation and we must
       not register their interrupts. */
    const unsigned int idxFirstNormalMailbox = cdr_getIdxOfFirstNormalMailbox(pDeviceConfig);
    #define REGISTER_ISR_MB_GROUP(idxFrom, idxTo)                                           \
    if(idxFirstNormalMailbox <= (idxTo)                                                     \
       &&  pDeviceConfig->irqGroupMB##idxFrom##_##idxTo.irqPrio > 0                         \
      )                                                                                     \
    {                                                                                       \
        rtos_osRegisterInterruptHandler                                                     \
            ( /* ISR */ mapDevIdxToISRGroup_[idxCanDevice].isrGroupMB##idxFrom##_##idxTo    \
            , /* processorID */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo.idxTargetCore  \
            , /* vectorNum */ IDX_IRQ_CAN_MB(idxFlexCAN_x, /* idxMB */ (idxTo))             \
            , /* psrPriority */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo.irqPrio        \
            , /* isPreemptable */ true                                                      \
            );                                                                              \
    }
#if defined(MCU_MPC5775B)  ||  defined(MCU_MPC5775E)
    #define REGISTER_ISR_MB(idxMB)                                                          \
    if(idxFirstNormalMailbox <= (idxMB)  &&  pDeviceConfig->irqMB##idxMB.irqPrio > 0)       \
    {                                                                                       \
        rtos_osRegisterInterruptHandler                                                     \
            ( /* ISR */ mapDevIdxToISRGroup_[idxCanDevice].isrMB##idxMB                     \
            , /* processorID */ pDeviceConfig->irqMB##idxMB.idxTargetCore                   \
            , /* vectorNum */ IDX_IRQ_CAN_MB(idxFlexCAN_x, (idxMB))                         \
            , /* psrPriority */ pDeviceConfig->irqMB##idxMB.irqPrio                         \
            , /* isPreemptable */ true                                                      \
            );                                                                              \
    }
#endif

#if defined(MCU_MPC5748G)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 0, /* idxTo */ 3)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 4, /* idxTo */ 7)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 8, /* idxTo */ 11)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 12, /* idxTo */ 15)
#else /* MPC5775B/E */
    REGISTER_ISR_MB(/* idxMB */ 0)
    REGISTER_ISR_MB(/* idxMB */ 1)
    REGISTER_ISR_MB(/* idxMB */ 2)
    REGISTER_ISR_MB(/* idxMB */ 3)
    REGISTER_ISR_MB(/* idxMB */ 4)
    REGISTER_ISR_MB(/* idxMB */ 5)
    REGISTER_ISR_MB(/* idxMB */ 6)
    REGISTER_ISR_MB(/* idxMB */ 7)
    REGISTER_ISR_MB(/* idxMB */ 8)
    REGISTER_ISR_MB(/* idxMB */ 9)
    REGISTER_ISR_MB(/* idxMB */ 10)
    REGISTER_ISR_MB(/* idxMB */ 11)
    REGISTER_ISR_MB(/* idxMB */ 12)
    REGISTER_ISR_MB(/* idxMB */ 13)
    REGISTER_ISR_MB(/* idxMB */ 14)
    REGISTER_ISR_MB(/* idxMB */ 15)
    #undef REGISTER_ISR_MB
#endif
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 16, /* idxTo */ 31)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 32, /* idxTo */ 63)
#if defined(MCU_MPC5748G)
    REGISTER_ISR_MB_GROUP(/* idxFrom */ 64, /* idxTo */ 95)
#endif
    #undef REGISTER_ISR_MB_GROUP
} /* End of cdr_osRegisterInterrupts */



