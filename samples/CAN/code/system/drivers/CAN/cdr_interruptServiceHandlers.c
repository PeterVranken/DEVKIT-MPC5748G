/**
 * @file cdr_interruptServiceHandlers.c
 * This file holds the collection of the ISRs needed to serve the CAN devices.\n
 *   Basically, ISRs are device dependent, but the registered handlers branch soon into
 * other functions, which implement most of the actual handler operation. This way, we have
 * a lot of code sharing between the devices. Still, the number of required registered
 * handler is huge.\n
 *   The large number of registered ISRs is generated by a number of macros, which take
 * device index and related information as macro and can then expand to the needed,
 * specific, registered ISR. Note, the definition of these macros resembles a normal
 * function implementation much more than a typical preprocessor macro. Consequently, we've
 * put them in the function section, where they belong from the logical aspect, rather
 * than in the define section.\n
 *   To enable the implementation of the interrupt services in a common, shared way, we
 * need some lookup tables for device specific settings or data. These are found here, too.
 *
 * Copyright (C) 2020 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   cdr_osRegisterInterrupts
 * Local functions
 *   isrRxFIFOOverflow
 *   isrRxFIFOWarning
 *   isrRxFIFOFramesAvailable
 */

/*
 * Include files
 */

#include <stdint.h>
#include <stdbool.h>
#include <stdlib.h>
#include <stdio.h>
#include <assert.h>

#include "MPC5748G.h"
#include "cdr_MPC5748G_CAN.h"

#include "rtos.h"
#include "cdr_canDriver.h"
#include "cdr_interruptServiceHandlers.h"


/*
 * Defines
 */


/*
 * Local type definitions
 */


/*
 * Local prototypes
 */

/* Prototypes for all ISRs on all enabled devices. */
#define PROTOTYPES_OF_CAN_ISRS(canDev)              \
static void isrGroupRxFIFO_##canDev(void);          \
/* static void isrGroupError_##canDev(void);   */       \
static void isrGroupMB0_3_##canDev(void);           \
static void isrGroupMB4_7_##canDev(void);           \
static void isrGroupMB8_11_##canDev (void);         \
static void isrGroupMB12_15_##canDev(void);         \
static void isrGroupMB16_31_##canDev(void);         \
static void isrGroupMB32_63_##canDev(void);         \
static void isrGroupMB64_95_##canDev(void);

#if CDR_ENABLE_USE_OF_CAN_0 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
PROTOTYPES_OF_CAN_ISRS(CAN_7)
#endif
#undef PROTOTYPES_OF_CAN_ISRS


/*
 * Data definitions
 */


/*
 * Function implementation
 */

/**
 * This is the ISR to handle the situation that a received CAN message can't be placed into
 * the Rx FIFO because it is still full. The message is lost. The ISR records the situation
 * but can recover from the data loss.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOOverflow( CAN_Type * const pDevice
                             , cdr_canDeviceData_t * const pDeviceData
                             )
{
    /* For now, we just record the situation in a global counter. */
    const unsigned int noErr = pDeviceData->noRxFIFOOverflowEvents+1;
    if(noErr != 0)
        pDeviceData->noRxFIFOOverflowEvents = noErr;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOOverflow = CAN_IFLAG1_BUF7I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOOverflow) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOOverflow; /* Clear bit by "w1c" */

} /* End of isrRxFIFOOverflow */




/**
 * This is the ISR to handle the situation that Rx FIFO is nearly full. A message is
 * however not lost yet. The ISR just records the situation but doesn't take an action.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 */
static void isrRxFIFOWarning( CAN_Type * const pDevice
                            , cdr_canDeviceData_t * const pDeviceData
                            )
{
    /* For now, we just record the situation in a counter. */
    const unsigned int noWarn = pDeviceData->noRxFIFOWarningEvents+1;
    if(noWarn != 0)
        pDeviceData->noRxFIFOWarningEvents = noWarn;

    /* RM 43.4.13, p. 1736. Acknowledge the IRQ. */
    const uint32_t irqMaskRxFIFOWarn = CAN_IFLAG1_BUF6I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFOWarn) != 0);
    pDevice->IFLAG1 = irqMaskRxFIFOWarn; /* Clear bit by "w1c" */

} /* End of isrRxFIFOWarning */




/**
 * This is the principal ISR of the Rx FIFO. It is called on completion of an reception.
 * The ISR fetches the payload and some additional information from the CAN device's
 * registers and invokes a callback to some external code, that does do the further
 * evalutaion of the received message data.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceData
 * The ISR is shared between all CAN devices. The run-time data of the device to operate on
 * is passed in by reference.
 *   @param pDeviceConfig
 * The configuration data set of the given CAN device by reference.
 */
static void isrRxFIFOFramesAvailable( CAN_Type * const pDevice
                                    , cdr_canDeviceData_t * const pDeviceData
                                    , const cdr_canDeviceConfig_t * const pDeviceConfig
                                    )
{
    /* RM 43.4.43, p. 1785: The FIFO is read through the first mailbox in the device RAM.
         Note, the fields inside the C/S word are a bit differently defined as for normal
       mailboxes and we need to apply other access macros. */
    volatile cdr_mailbox_t * const pRxMB = cdr_osGetMailbox(pDevice, /* idxMB */ 0);

    /* The ISR doesn't need to loop over all messages currently held in the FIFO. The HW
       maintains the flag coherently with the FIFO contents. If several messages are
       contained then it'll re-assert the flag and we will enter this ISR immediately
       again. (See RM 43.5.8, p. 1810) */
    const uint32_t irqMaskRxFIFO = CAN_IFLAG1_BUF5I_MASK;
    assert((pDevice->IFLAG1 & irqMaskRxFIFO) != 0);

    /* Record the Rx situation in a counter. */
    ++ pDeviceData->noRxMsgsFIFO;

    const uint32_t csWord = pRxMB->csWord
                 , canIdWord = pRxMB->canId;
    const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
    const unsigned int idHit = (csWord & CAN_FIFOCS_IDHIT_MASK) >> CAN_FIFOCS_IDHIT_SHIFT
                     , DLC = (csWord & CAN_FIFOCS_DLC_MASK) >> CAN_FIFOCS_DLC_SHIFT
                     , timeStamp = (csWord & CAN_FIFOCS_TIME_STAMP_MASK)
                                   >> CAN_FIFOCS_TIME_STAMP_SHIFT
                     , canId = isExtID? (canIdWord & CAN_FIFOID_ID_EXT_MASK)
                                        >> CAN_FIFOID_ID_EXT_SHIFT
                                      : (canIdWord & CAN_FIFOID_ID_STD_MASK)
                                        >> CAN_FIFOID_ID_STD_SHIFT
                     ;

    /* Copy received bytes into local buffer for callback invokation. We copy
       unconditionally. Having conditional code or a byte loop would not save any time. */
    assert(DLC <= 8);
    uint32_t payload_u32[2];
    payload_u32[0] = pRxMB->payload_u32[0];
    payload_u32[1] = pRxMB->payload_u32[1];

    /* Acknowledge the IRQ. For normal MBs, we need to do this prior to reading the
       timer (which unlocks the MB and would enable a re-assertion of the interrupt
       flag). */
    pDevice->IFLAG1 = irqMaskRxFIFO; /* Clear bit by "w1c" */

    /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
       (side-effect of reading). We are ready for next reception while the user
       notification callback is running in parallel. See 43.5.7.3 Mailbox lock mechanism,
       p. 1808ff, for more details. */
    (void)pDevice->TIMER;

    /* Invoke the callback for further data processing.
         Note, a NULL Pointer check is not needed at run-time. We have double
       checked the configuration at driver initialization time. (Which won't hinder
       us from having an assertion here.) */
    assert(pDeviceConfig->osCallbackOnRx != NULL);
    (*pDeviceConfig->osCallbackOnRx)( /* hMsg */ idHit
                                  , isExtID
                                  , canId
                                  , DLC
                                  , (const uint8_t *)&payload_u32[0]
                                  , timeStamp
                                  );
} /* End of isrRxFIFOFramesAvailable */



#define ISR_GROUP_RX_FIFO(canDev)                                                           \
/**                                                                                         \
 * Common ISR for all of the Rx FIFO interrupts. It looks for the causing IRQ and branches  \
 * in the dedicated handler. Interrupt acknowledge needs to be done in the dedicated        \
 * handler.                                                                                 \
 */                                                                                         \
static void isrGroupRxFIFO_##canDev(void)                                                   \
{                                                                                           \
    CAN_Type * const pDevice = (canDev);                                                    \
    if((pDevice->IFLAG1 & CAN_IFLAG1_BUF5I_MASK) != 0)                                      \
    {                                                                                       \
        isrRxFIFOFramesAvailable( pDevice                                                   \
                                , &cdr_canDriverData[cdr_canDev_##canDev]                   \
                                , &cdr_canDriverConfig[cdr_canDev_##canDev]                 \
                                );                                                          \
    }                                                                                       \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF6I_MASK) != 0)                                 \
        isrRxFIFOWarning(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                 \
    else if((pDevice->IFLAG1 & CAN_IFLAG1_BUF7I_MASK) != 0)                                 \
        isrRxFIFOOverflow(pDevice, &cdr_canDriverData[cdr_canDev_##canDev]);                \
    else                                                                                    \
        assert(false);                                                                      \
                                                                                            \
} /* End of isrGroupRxFIFO_##canDev */



/**
 * This is the common part of the implementation of all mailbox ISRs. It is called on
 * completion of a reception or transmission.
 *   @param pDevice
 * The ISR is shared between all CAN devices. The device to operate on is passed in by
 * reference.
 *   @param pDeviceConfig
 * The configuration data set of the given CAN device by reference.
 *   @param pIFLAG
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here related register IFLAG1/2/3 of the CAN device by reference.
 *   @param idxMBOffset
 * This is the mailbox index of the first mailbox, in the group, which possibly requested
 * the IRQ. It is the index of the mailbox, whose interrupt flag is found with \a maskFrom
 * in flag register * \a pIFLAG.
 *   @param maskFrom
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the first
 * mailbox, which possibly requested the IRQ.
 *   @param maskTo
 * The ISR is shared between all mailboxes. The information to identify the IRQ requesting
 * mailbox is passed in. Here the bit mask to touch the interrupt flag of the last
 * mailbox in the given group, which possibly requested the IRQ.
 */
static void isrMailbox( CAN_Type * const pDevice
                      , const cdr_canDeviceConfig_t * const pDeviceConfig
                      , volatile uint32_t *pIFLAG
                      , unsigned int idxMBOffset
                      , uint32_t maskFrom
                      , uint32_t maskTo
                      )
{
    while(true)
    {
        /* Check mailbox candidate for newly received input. */
        if((*pIFLAG & maskFrom) == 0)
        {
            /* This is not the causing mailbox - try next one. */
            if(maskFrom == maskTo)
            {
                /* This code must be never reached. We are in the ISR but don't see any of
                   the related interrupt flags set. All we can do is ignoring the interrupt
                   request. Evidently, there's not even a flag bit to reset. */
                assert(false);
                return;
            }
            else
            {
                /* This is not the causing mailbox - try next one. */
                ++ idxMBOffset;
                maskFrom <<= 1;
                continue;
            }
        } /* End if(Did we identify the interrupt requesting mailbox?) */

        /* If we get here then we have found the causing mailbox. It is mailbox
           idxMBOffset. */
        volatile cdr_mailbox_t * const pMB = cdr_osGetMailbox(pDevice, idxMBOffset);

        /* Read the mailbox CODE: It tells whether we have an Rx or Tx message and what
           happened. See RM 43.4.40, p. 1771ff, Tables 43-8 and 43-9, for the different
           status codes. */
        const uint32_t csWord = pMB->csWord
                     , canIdWord = pMB->canId;
        const bool isExtID = (csWord & CAN_FIFOCS_IDE_MASK) != 0;
        const unsigned int DLC = (csWord & CAN_MBCS_DLC_MASK) >> CAN_MBCS_DLC_SHIFT
                         , timeStamp = (csWord & CAN_MBCS_TIME_STAMP_MASK)
                                       >> CAN_MBCS_TIME_STAMP_SHIFT
                         , canId = isExtID? (canIdWord & CAN_MBID_ID_EXT_MASK)
                                            >> CAN_MBID_ID_EXT_SHIFT
                                          : (canIdWord & CAN_MBID_ID_STD_MASK)
                                            >> CAN_MBID_ID_STD_SHIFT
                         ;
        const uint32_t CODE = (csWord & CAN_MBCS_CODE_MASK) >> CAN_MBCS_CODE_SHIFT;
        const bool isRx = (CODE & 0x8) != 0;


        /* RM 43.4.12/13/21, p. 1735ff: Acknowledge the IRQ. We need to do this prior to
           reading the timer (which unlocks the MB and would enable a re-assertion of the
           interrupt flag). */
        *pIFLAG = maskFrom; /* Clear bit by "w1c" */

        /* RM 43.4.4, p. 1721f: Read the timer register to unlock the evaluated mailbox
           (side-effect of reading). See 43.5.7.3 Mailbox lock mechanism, p. 1808ff for
           more details.
             From now on, the mailbox is ready for next reception/transmission. At least
           for Tx, it is essential that we release it prior to invokingthe notification
           callback into the client code: The client could implement a buffering strategy
           that wants to re-use the mailboxe immediately again for the subsequent message.
           For Rx, it just better to do this before notifying; mailbox hardware and
           callback software can run in parallel. */
        (void)pDevice->TIMER;

        /* Down here, no access to the device hardware is allowed any more. */

        if(isRx)
        {
            /* We have an Rx mailbox interrupt. */

            assert(CODE == 2 /* FULL */  ||  CODE == 6 /* OVERRUN */);

            /* Copy received bytes into local buffer for callback invokation. We copy
               unconditionally. Having conditional code or a byte loop would not save any
               time. */
            assert(DLC <= 8);
            uint32_t payload_u32[2]; /* Definition as u32 ensures a safe alignment. */
            payload_u32[0] = pMB->payload_u32[0];
            payload_u32[1] = pMB->payload_u32[1];

            /* Invoke the callback for further data processing.
                 Note, a NULL Pointer check is not needed at run-time. We have double
               checked the configuration at driver initialization time. (Which won't hinder
               us from having an assertion here.) */
            assert(pDeviceConfig->osCallbackOnRx != NULL);
            (*pDeviceConfig->osCallbackOnRx)( /* hMsg */ idxMBOffset
                                            , isExtID
                                            , canId
                                            , DLC
                                            , (const uint8_t *)&payload_u32[0]
                                            , timeStamp
                                            );
        }
        else
        {
            /* We have a Tx mailbox interrupt. */

            assert(CODE == 8 /* INACTIVE */  ||  CODE == 9 /* ABORT */);

            /* Invoke the callback for further data processing.
                 Note, a NULL Pointer check is not needed at run-time. We have double
               checked the configuration at driver initialization time. (Which won't hinder
               us from having an assertion here.) */
            assert(pDeviceConfig->osCallbackOnRx != NULL);
            (*pDeviceConfig->osCallbackOnTx)( /* hMsg */ idxMBOffset
                                            , isExtID
                                            , canId
                                            , DLC
                                            , /* isAborted */ CODE == 9
                                            , timeStamp
                                            );
        }
    }
} /* End of isrMailbox */




#define ISR_GROUP_MAILBOX(canDev, idxIFLAG, idxFrom, idxTo)                                 \
/**                                                                                         \
 * Common ISR for the mailbox interrupts of mailboxes idxFrom till and including idxTo. It  \
 * branches in the common mailbox interrupt handler implementation with the information     \
 * about which CAN device and which mailbox group caused the reset. Interrupt acknowledge   \
 * needs to be done in the common mailbox handler. Splitting this ISR from the common       \
 * implementation of mailbox processing avoids code duplication for all mailbox interrupts. \
 */                                                                                         \
static void isrGroupMB##idxFrom##_##idxTo##_##canDev(void)                                  \
{                                                                                           \
    _Static_assert( (idxIFLAG) >= 1  &&  (idxIFLAG) <= 3                                    \
                    &&  (idxFrom) >= 0  &&  (idxFrom) <= 64                                 \
                    &&  (idxTo)-(idxFrom)+1 >= 4  &&  (idxTo)-(idxFrom)+1 <= 32             \
                    &&  ((idxTo)-(idxFrom)+1) % 4 == 0                                      \
                    &&  (idxFrom)/32 == (idxTo)/32                                          \
                  , "Bad arguments passed to macro ISR_GROUP_MAILBOX to generate mailbox"   \
                    " ISR"                                                                  \
                  );                                                                        \
                                                                                            \
    /* Here, we know very well, which device and interrupt we are. We can figure out, which \
       interrupt flag register to use with which masks and all of this without any runtime  \
       overhead: The macro arguments idxFrom and idxTo are constants and what looks like    \
       runtime computation in the source code is just loading a constant value in the       \
       executed code. */                                                                    \
    volatile uint32_t * const pIFLAG = &canDev->IFLAG##idxIFLAG;                            \
    const uint32_t maskFrom = 1u << ((idxFrom)-32u*((idxIFLAG)-1u))                         \
                 , maskTo   = 1u << ((idxTo)  -32u*((idxIFLAG)-1u));                        \
                                                                                            \
    const cdr_canDeviceConfig_t * const pDeviceConfig =                                     \
                                            &cdr_canDriverConfig[cdr_canDev_##canDev];      \
    isrMailbox(canDev, pDeviceConfig, pIFLAG, (idxFrom), maskFrom, maskTo);                 \
                                                                                            \
} /* End of isrGroupMB##idxFrom##_##idxTo##_##canDev */



/* We need the ISRs for each device separately. This is done easiest by making the set of
   ISRs for a single device a define, which is then repeatedly applied. */
/// @todo Error interrupts (bus off, etc.) have been promised in the configuration but not
/// been implemented yet
#define SET_OF_DEVICE_ISRS(idxCanDev)                                                       \
ISR_GROUP_RX_FIFO(CAN_##idxCanDev)                                                          \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 0, /* idxTo */ 3)        \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 4, /* idxTo */ 7)        \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 8, /* idxTo */ 11)       \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 12, /* idxTo */ 15)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 1, /* idxFrom */ 16, /* idxTo */ 31)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 2, /* idxFrom */ 32, /* idxTo */ 63)      \
ISR_GROUP_MAILBOX(CAN_##idxCanDev, /* idxIFLAG */ 3, /* idxFrom */ 64, /* idxTo */ 95)

#if CDR_ENABLE_USE_OF_CAN_0 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
SET_OF_DEVICE_ISRS(/* idxCanDev */ 7)
#endif

#undef ISR_GROUP_RX_FIFO
#undef ISR_GROUP_MAILBOX
#undef SET_OF_DEVICE_ISRS



/**
 * Our locally implemented interrupt handlers are registered at the operating system for
 * serving the mailbox and FIFO interrupts.
 *   @param idxCanDevice
 * The CAN device to register the interrupts for by index. The available index range
 * depends on the configuration of the set of enabled CAN devices, see e.g.
 * #CDR_ENABLE_USE_OF_CAN_0. The most convenient way to provide the appropriate index is
 * using enumeration cdr_canDevice_t.
 */
void cdr_osRegisterInterrupts(unsigned int idxCanDevice)
{
    assert(idxCanDevice < sizeOfAry(cdr_canDriverConfig));
    const cdr_canDeviceConfig_t * const pDeviceConfig = &cdr_canDriverConfig[idxCanDevice];

    /** Helper macro to maintian readability of initializer expression of next data object,
        a constant table of interrupt handlers. */
    #define SET_OF_CAN_ISRS(canDev)                 \
    { .isrGroupFIFO = isrGroupRxFIFO_##canDev,      \
      .isrGroupError = NULL,                        \
      .isrGroupMB0_3 = isrGroupMB0_3_##canDev,      \
      .isrGroupMB4_7 = isrGroupMB4_7_##canDev,      \
      .isrGroupMB8_11 = isrGroupMB8_11_##canDev,    \
      .isrGroupMB12_15 = isrGroupMB12_15_##canDev,  \
      .isrGroupMB16_31 = isrGroupMB16_31_##canDev,  \
      .isrGroupMB32_63 = isrGroupMB32_63_##canDev,  \
      .isrGroupMB64_95 = isrGroupMB64_95_##canDev,  \
    },

    /** This is a table, which holds pointers to all required ISRs. It is just needed to have a
        function that registers these interrupts. The alternative would be a long list of
        dedicated calls of the register-function. Either solutions won't make a significant
        difference in terms of ROM consumption. */
    static const struct setOfCanISRs_t
    {
        void (*isrGroupFIFO)(void);   /** Hdlr for all Rx FIFO related interrupts. */
        void (*isrGroupError)(void);  /** Hdlr for all device error related interrupts. */
        void (*isrGroupMB0_3)(void);  /** Hdlr for all Rc/Tx interrupts of mailboxes 0..3. */
        void (*isrGroupMB4_7)(void);  /** Hdlr for all Rc/Tx interrupts of mailboxes 4..7. */
        void (*isrGroupMB8_11)(void); /** Hdlr for all Rc/Tx interrupts of mailboxes 8..11. */
        void (*isrGroupMB12_15)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 12..15. */
        void (*isrGroupMB16_31)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 16..31. */
        void (*isrGroupMB32_63)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 32..63. */
        void (*isrGroupMB64_95)(void);/** Hdlr for all Rc/Tx interrupts of mailboxes 64..95. */

    } mapDevIdxToISRGroup_[cdr_canDev_noCANDevicesEnabled] =
        {
#if CDR_ENABLE_USE_OF_CAN_0 == 1
            SET_OF_CAN_ISRS(CAN_0)
#endif
#if CDR_ENABLE_USE_OF_CAN_1 == 1
            SET_OF_CAN_ISRS(CAN_1)
#endif
#if CDR_ENABLE_USE_OF_CAN_2 == 1
            SET_OF_CAN_ISRS(CAN_2)
#endif
#if CDR_ENABLE_USE_OF_CAN_3 == 1
            SET_OF_CAN_ISRS(CAN_3)
#endif
#if CDR_ENABLE_USE_OF_CAN_4 == 1
            SET_OF_CAN_ISRS(CAN_4)
#endif
#if CDR_ENABLE_USE_OF_CAN_5 == 1
            SET_OF_CAN_ISRS(CAN_5)
#endif
#if CDR_ENABLE_USE_OF_CAN_6 == 1
            SET_OF_CAN_ISRS(CAN_6)
#endif
#if CDR_ENABLE_USE_OF_CAN_7 == 1
            SET_OF_CAN_ISRS(CAN_7)
#endif
    };
    #undef SET_OF_CAN_ISRS

    /* Interrupt offsets are taken from MCU reference manual, see 23.1.2 INTC interrupt
       sources, p. 523ff, Table 23-1.
         The interrupts are regularly defined, therefore we can compute the wanted
       number. The only exception is the very first IRQ, related to pretended network,
       which is available only in device CAN_0. */
    #define IDX_IRQ_CAN_FIFO(idxDev)                    (IDX_IRQ_CAN_MB(idxDev, /* idxMB */ 5))
    #define IDX_IRQ_CAN_ERROR(idxDev)                   (CAN0_Error_IRQn + 12*(idxDev))
    #define IDX_IRQ_CAN_BOFF_OR_TX_WARN(idxDev)         (CAN0_ORed_IRQn + 12*(idxDev))
    #define IDX_IRQ_CAN_MB(idxDev, idxMB)                                                     \
                            (CAN0_ORed_00_03_MB_IRQn + 12u*(idxDev)                           \
                             + ((idxMB)<16u? (idxMB)/4u: ((idxMB)<32u? 4u: (idxMB-32)/32u+5u))\
                            )

    /* A few sample tests. */
    _Static_assert( IDX_IRQ_CAN_ERROR(0) == CAN0_Error_IRQn
                    &&  IDX_IRQ_CAN_ERROR(7) == CAN7_Error_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(1) == CAN1_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(6) == CAN6_ORed_IRQn
                    &&  IDX_IRQ_CAN_BOFF_OR_TX_WARN(7) == CAN7_ORed_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 0) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 3) == CAN0_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 5) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(0, 7) == CAN0_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(1, 4) == CAN1_ORed_04_07_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(2, 8) == CAN2_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 11) == CAN3_ORed_08_11_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 12) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(3, 15) == CAN3_ORed_12_15_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(4, 16) == CAN4_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 17) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(5, 31) == CAN5_ORed_16_31_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 32) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(6, 33) == CAN6_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 32) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 63) == CAN7_ORed_32_63_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 64) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 95) == CAN7_ORed_64_95_MB_IRQn
                    &&  IDX_IRQ_CAN_MB(7, 0) == CAN7_ORed_00_03_MB_IRQn
                    &&  IDX_IRQ_CAN_FIFO(0) == IDX_IRQ_CAN_MB(0, 5)
                    &&  IDX_IRQ_CAN_FIFO(3) == IDX_IRQ_CAN_MB(3, 6)
                    &&  IDX_IRQ_CAN_FIFO(7) == IDX_IRQ_CAN_MB(7, 7)
                  , "Test of computation of IRQ vector numbers failed"
                  );

    /* Register our IRQ handlers. */
    assert(idxCanDevice < sizeOfAry(mapDevIdxToISRGroup_));
    if(pDeviceConfig->isFIFOEnabled)
    {
        /* Register the FIFO interrupts. */
        rtos_osRegisterInterruptHandler
                ( /* ISR */           mapDevIdxToISRGroup_[idxCanDevice].isrGroupFIFO
                , /* processorID */   pDeviceConfig->irqGroupFIFOTargetCore
                , /* vectorNum */     IDX_IRQ_CAN_FIFO(idxCanDevice)
                , /* psrPriority */   pDeviceConfig->irqGroupFIFOIrqPrio
                , /* isPreemptable */ true
                );
    }

    /* With enabled FIFO, the first mailboxes are not in normal operation and we must
       not register their interrupts. */
    const unsigned int idxFirstNormalMailbox = cdr_osGetIdxOfFirstMailbox(pDeviceConfig);
    #define REGISTER_ISR(idxFrom, idxTo)                                                    \
    if(idxFirstNormalMailbox <= (idxTo))                                                    \
    {                                                                                       \
        rtos_osRegisterInterruptHandler                                                     \
            ( /* ISR */ mapDevIdxToISRGroup_[idxCanDevice].isrGroupMB##idxFrom##_##idxTo    \
            , /* processorID */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo##TargetCore    \
            , /* vectorNum */ IDX_IRQ_CAN_MB(idxCanDevice, /* idxMB */ (idxTo))             \
            , /* psrPriority */ pDeviceConfig->irqGroupMB##idxFrom##_##idxTo##IrqPrio       \
            , /* isPreemptable */ true                                                      \
            );                                                                              \
    }
    REGISTER_ISR(/* idxFrom */ 0, /* idxTo */ 3)
    REGISTER_ISR(/* idxFrom */ 4, /* idxTo */ 7)
    REGISTER_ISR(/* idxFrom */ 8, /* idxTo */ 11)
    REGISTER_ISR(/* idxFrom */ 12, /* idxTo */ 15)
    REGISTER_ISR(/* idxFrom */ 16, /* idxTo */ 31)
    REGISTER_ISR(/* idxFrom */ 32, /* idxTo */ 63)
    REGISTER_ISR(/* idxFrom */ 64, /* idxTo */ 95)
    #undef REGISTER_ISR

    #undef IDX_IRQ_CAN_FIFO
    #undef IDX_IRQ_CAN_ERROR
    #undef IDX_IRQ_CAN_BOFF_OR_TX_WARN
    #undef IDX_IRQ_CAN_MB
} /* End of cdr_osRegisterInterrupts */



