//
// cde_canDataTables.c.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// Generate the data tables, which form the database for the callbacks of the dispatchers.
// The information from the DBC files about frames is provided throughthese (constant)
// tables to the callback implementation.
//
// Copyright (C) 2017-2020 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "<", ">"

import "lib/iterations.stg"
import "lib/mod.stg"
import "attributes.stg"
import "symbols.stg"
import "globalInterface.stg"

moduleDescription() ::= <<
 * This module contains data tables, which contain all relevant information from the CAN
 * network database files about frames and signals. Mainly the callback functions of the
 * event dispatchers will access the tables to implement the frame-indvidual behavior like
 * different timing patterns, different checksum protections, different size, etc.
>>


// This is one of the root templates; the complete C file is rendered.
//
dataTables_c(cluster,info) ::= <<
<! First put a file header with the reusable library template modC !>
<modC(["\n", moduleDescription()])>
<! The list of functions is put after the file frame shaped by modC !>
>>


// This is one of the root templates; the complete header file is rendered.
//
dataTables_h(cluster,info) ::= <<
<! First put a file header with the reusable library template modC !>
<modH(["\n", moduleDescription()])>
>>


@modH.includes() ::= <<
#include "<file.baseTypes_h>"
#include "<file.canApi_h>"
#include "cde_canStatistics.h"

>>


// Configure the templates mod.stg:modC/H, which shape the lists of included files.
@modC.includes() ::= <<
#include \<stdio.h>
#include \<stdlib.h>
#include \<string.h>
#include \<assert.h>

#include "<file.baseTypes_h>"
#include "<file.canApi_h>"
#include "cde_canStatistics.h"

>>

@modH.defines() ::= <<
/** Both, operating system and CAN interface use their handles for identification of a
    frame. The operating system uses separate handles for in- and outbound, while the CAN
    interface enginge has one solid handle space for all frames. This requires a mapping of
    the OS handle to the CAN interface handle.\n
      Here is the mapping for the inbound frames. */
#define CDE_MAP_HANDLE_RX_FRAME_OS_TO_CAN_IF(hOS)                                           \
            (assert((hOS) \< (CDE_NO_CAN_FRAMES_RECEIVED)+(BSW_IDX_FIRST_RX_MAILBOX)),       \
             (hOS)-(BSW_IDX_FIRST_RX_MAILBOX)                                               \
            )

/** Both, operating system and CAN interface use their handles for identification of a
    frame. The operating system uses separate handles for in- and outbound, while the CAN
    interface enginge has one solid handle space for all frames. This requires a mapping of
    CAN interface handle to OS handle.\n
      Here is the mapping for the inbound frames. */
#define CDE_MAP_HANDLE_RX_FRAME_CAN_IF_TO_OS(hIF)                                           \
            (assert((hIF)+(BSW_IDX_FIRST_RX_MAILBOX) \<= (BSW_IDX_LAST_RX_MAILBOX)),         \
             (hIF)+(BSW_IDX_FIRST_RX_MAILBOX)                                               \
            )

/** Our data tables with frame decriptions are separated in Rx and Tx frames. The interface
    engine has one solid handle space for all frames. This macro computes the array index of
    a received frame from the handle used by the engine. The index relates to array \a
    cde_canRxFrameAry. */
#define CDE_MAP_HANDLE_RX_FRAME_CAN_IF_TO_IDX_RX(idxFrCde)                                  \
            (assert((idxFrCde) \< sizeOfAry(cde_canRxFrameAry)),(idxFrCde))

/** Both, operating system and CAN interface use their handles for identification of a
    frame. The operating system uses separate handles for in- and outbound, while the CAN
    interface enginge has one solid handle space for all frames. This requires a mapping of
    the OS handle to the CAN interface handle.\n
      Here is the mapping for the outbound frames. */
#define CDE_MAP_HANDLE_TX_FRAME_OS_TO_CAN_IF(hOS)                                           \
            (assert((hOS) >= (BSW_IDX_FIRST_TX_MAILBOX)                                     \
                    &&  (hOS)-(BSW_IDX_FIRST_TX_MAILBOX)+(CDE_NO_CAN_FRAMES_RECEIVED)       \
                        \< (CDE_NO_CAN_FRAMES)                                               \
                   ),                                                                       \
             (hOS)-(BSW_IDX_FIRST_TX_MAILBOX)+(CDE_NO_CAN_FRAMES_RECEIVED)                  \
            )

/** Both, operating system and CAN interface use their handles for identification of a
    frame. The operating system uses separate handles for in- and outbound, while the CAN
    interface enginge has one solid handle space for all frames. This requires a mapping of
    CAN interface handle to OS handle.\n
      Here is the mapping for the outbound frames. */
#define CDE_MAP_HANDLE_TX_FRAME_CAN_IF_TO_OS(hIF)                                           \
            (assert((hIF) >= (CDE_NO_CAN_FRAMES_RECEIVED)                                   \
                    &&  (hIF)+(BSW_IDX_FIRST_TX_MAILBOX)                                    \
                        \<= (BSW_IDX_LAST_TX_MAILBOX)+(CDE_NO_CAN_FRAMES_RECEIVED)           \
                   ),                                                                       \
             (hIF)-(CDE_NO_CAN_FRAMES_RECEIVED)+(BSW_IDX_FIRST_TX_MAILBOX)                  \
            )

/** Our data tables with frame decriptions are separated in Rx and Tx frames. The interface
    engine has one solid handle space for all frames. This macro computes the array index of
    a sent frame from the handle used by the engine. The index relates to array \a
    cde_canTxFrameAry. */
#define CDE_MAP_HANDLE_TX_FRAME_CAN_IF_TO_IDX_TX(idxFrCde)                                  \
            (assert((idxFrCde)-(CDE_NO_CAN_FRAMES_RECEIVED) \< sizeOfAry(cde_canTxFrameAry)),\
             (idxFrCde)-(CDE_NO_CAN_FRAMES_RECEIVED)                                        \
            )

>>

@modC.defines() ::= <<
>>

@modH.typedefs() ::= <<
/** The decription of a CAN frame as required for implementation of its send/receive
    behavior in the callbacks of the event dispatchers. */
typedef struct cde_canFrame_t
{
    /** The CAN bus, which the reception event is simulated for. */
    unsigned int idxCanBus;

    /** Boolean information, whether \a canId designates an extended 29 Bit ID. */
    unsigned long isExtId;

    /** The CAN ID. */
    unsigned long canId;

    /** The send direction. Only transmitted, affected frames are listed; if it is not
        received then it is sent. */
    /// @todo Remove: Became obsolete due to separate tables for Rx and Tx
    <bt("bool_t")> isReceived;

    /** The size of the frame contents in Byte. */
    unsigned int size;

    /** An external function, which is called to unpack a received CAN frame into the
        global CAN API. */
    void (*fctUnpackApiFrame)(const uint8_t frameContentAry[]);

    /** An external function, which is called to pack the frame. */
    void (*fctPackApiFrame)(uint8_t frameContentAry[]);

    /** The transmission timing pattern to be applied to the frame. */
    <symbol.enumSendMode_t> sendMode;

    /** The index of the frame in its particular group. A group are all frames, which are
        implemented by the same (hand-coded) handler in the CAN interface. The index
        supports easy and efficient implementation of handler owned, frame related context
        data. */
    unsigned int idxHandlerCtxData;

    /** The pointer to the transmission info of the given frame in the global CAN API. */
    <symbol.structInfoTransmission_t> *pInfoTransmission;

    /** The nominal cycle time in ms if the frame is not purely event triggered. */
    unsigned int tiCycle;

    /** The minimum distance of reception events if the frame is event triggered. */
    unsigned int tiMinDistance;

} cde_canFrame_t;


/** The description of a CAN signal as required for the specific functionality of this
    applicatin: The user can select signals rather than frames for reception and sending. */
typedef struct cde_canSignal_t
{
    /** Name of signal. */
    const char *name;

    /** Reference to containg CAN frame: Index into table of all frames. */
    unsigned int idxCdeFrame;
    
    /** Reference to containg CAN frame: Table of Rx or Tx frames? */
    <bt("bool_t")> isReceived;
    
    /** Getter for signal: Has a signal independent, generic prototype and allows to read
        the signal value from the global API as uniform type \a float. */
    float (*getter)(void);

    /** Setter for signal: Has a signal independent, generic prototype and allows to set
        the signal value in the global API. */
    void (*setter)(float newValue);

} cde_canSignal_t;


>>

@modC.typedefs() ::= <<
>>

@modH.data() ::= <<
/** A global table with the description of all CAN frames which are received by the device.
    The description of the frames is as detailed as required for implementation of their
    send/receive behavior in the callbacks of the event dispatchers. */
extern const cde_canFrame_t cde_canRxFrameAry[CDE_NO_CAN_FRAMES_RECEIVED];

/** A global table with the description of all CAN frames which are sent by the device.
    The description of the frames is as detailed as required for implementation of their
    send/receive behavior in the callbacks of the event dispatchers. */
extern const cde_canFrame_t cde_canTxFrameAry[CDE_NO_CAN_FRAMES_SENT];

>>

@modC.data() ::= <<
/** A global table with the description of all CAN frames which are received by the device.
    The description of the frames is as detailed as required for implementation of their
    send/receive behavior in the callbacks of the event dispatchers. */
const cde_canFrame_t cde_canRxFrameAry[CDE_NO_CAN_FRAMES_RECEIVED] =
{<info.calc.idxCdtCanFrameAryEntry_set_1n><info.calc.idxCdtCanFrameAryEntry_sadd_1>
    <iteratePdusOfCluster(cluster,"received","canFrameAryEntry")><\\>
}; /* cde_canRxFrameAry */

/** A global table with the description of all CAN frames which are sent by the device.
    The description of the frames is as detailed as required for implementation of their
    send/receive behavior in the callbacks of the event dispatchers. */
const cde_canFrame_t cde_canTxFrameAry[CDE_NO_CAN_FRAMES_SENT] =
{<info.calc.idxCdtCanFrameAryEntry_set_1n><info.calc.idxCdtCanFrameAryEntry_sadd_1>
    <iteratePdusOfCluster(cluster,"sent","canFrameAryEntry")><\\>
}; /* cde_canTxFrameAry */

<verifyIdxRangeHandlerContextData()>

/** A global table with the description of all CAN signals as required for the specific
    functionality of this application: The user can select signals rather than frames for
    reception and sending. */
const cde_canSignal_t cde_canSignalAry[] =
{<info.calc.idxCdtCanFrameAryEntry_set_1n><info.calc.idxCdtCanFrameAryEntry_sadd_1>
    <iteratePdusOfCluster(cluster,"received","canSignalAryFrameEntry")><\\>
<info.calc.idxCdtCanFrameAryEntry_set_1n><info.calc.idxCdtCanFrameAryEntry_sadd_1>
    <iteratePdusOfCluster(cluster,"sent","canSignalAryFrameEntry")><\\>
}; /* cde_canSignalAry */

>>

@modH.prototypes() ::= <<
>>

@modC.prototypes() ::= <<
>>


// This project makes use of hand-written event handler for the processing of the frames.
// Usually, the handlers differ for in- and outbound frames and for the different
// transmission pattern. The implementation partly requires local data, like tick counters to
// implement the timing. To support the implementation of such a handler, we add an group
// index for each frame; where a group bundles all frames being processed of one handler.
// This index permits to have simple access to compact, frame-local data for each frame.
//   The implementation of the template mainly is the conditional code required to assign
// each frame to one of the groups or handlers. What it emits is just the index as a number
// literal.
idxHandlerContextData(pdu) ::= <<
<if(pdu.isReceived)><\\>
<if(isTrue.(attribVal.sendModeRegular))><info.calc.idxHdlCtxDataInRegular><\\>
<elseif(isTrue.(attribVal.sendModeEvent))><info.calc.idxHdlCtxDataInEvent><\\>
<elseif(isTrue.(attribVal.sendModeMixed))><info.calc.idxHdlCtxDataInMixed><\\>
<else><info.error.({Unexpected value <attribVal.sendMode> found for frame attribute <attribName.sendMode>})><\\>
<endif><\\>
<elseif(pdu.isSent)><\\>
<if(isTrue.(attribVal.sendModeRegular))><info.calc.idxHdlCtxDataOutRegular><\\>
<elseif(isTrue.(attribVal.sendModeEvent))><info.calc.idxHdlCtxDataOutEvent><\\>
<elseif(isTrue.(attribVal.sendModeMixed))><info.calc.idxHdlCtxDataOutMixed><\\>
<else><info.error.({Unexpected transmission direction})><\\>
<endif><\\>
<endif>
>>

// Some protective code against inconsistencies of different templates. The counting above
// in idxHandlerContextData needs to be implemented in consistency with the frame
// statistics implemented in cde_canStatistics.h.stg.
verifyIdxRangeHandlerContextData() ::= <<
#if (<info.calc.idxHdlCtxDataInRegular>) != CDE_NO_CAN_FRAMES_RECEIVED_REGULAR \
    ||  (<info.calc.idxHdlCtxDataInEvent>) != CDE_NO_CAN_FRAMES_RECEIVED_EVENT \
    ||  (<info.calc.idxHdlCtxDataInMixed>) != CDE_NO_CAN_FRAMES_RECEIVED_MIXED \
    ||  (<info.calc.idxHdlCtxDataOutRegular>) != CDE_NO_CAN_FRAMES_SENT_REGULAR \
    ||  (<info.calc.idxHdlCtxDataOutEvent>) != CDE_NO_CAN_FRAMES_SENT_EVENT \
    ||  (<info.calc.idxHdlCtxDataOutMixed>) != CDE_NO_CAN_FRAMES_SENT_MIXED
# error Invalid index ranges detected. Looks like an inconsistency in your code <\\>
        generation templates
#endif


>>


canFrameAryEntry(pdu) ::= <<
[<info.calc.idxCdtCanFrameAryEntry>] =
    { .idxCanBus = <define.busId>
    , .isExtId = <frame.isExtId>
    , .canId = <frame.id>
    , .isReceived = <frame.isReceived>
    , .size = <frame.size>
    , .fctUnpackApiFrame = <fct.unpackApiFrame>
    , .fctPackApiFrame = <fct.packApiFrame>
    , .sendMode = <attribVal.sendMode>
    , .idxHandlerCtxData = <idxHandlerContextData(pdu)>
    , .pInfoTransmission = &<define.referenceStructFrameSts>().<symbol.fieldInfoTransmission>
    , .tiCycle = <attribVal.sendPeriod>
    , .tiMinDistance = <attribVal.eventMinDistance>
    },<\n>
>>


canSignalAryFrameEntry(pdu) ::= <<
<iterateSignalsOfPdu(pdu,"all","all","canSignalAryEntry")><\\>
<info.calc.idxCdtCanFrameAryEntry_add_1>
>>
    
canSignalAryEntry(signal, kind) ::= <<
[<info.calc.idxCdtCanSignalAryEntry>] =
    { .name = "<symbol.signal>"
    , .idxCdeFrame = <info.calc.idxCdtCanFrameAryEntry_get>
    , .isReceived = <frame.isReceived>
    , .getter = <symbol.signalGetter>
    , .setter = <symbol.signalSetter>
    },<\n>
>>


