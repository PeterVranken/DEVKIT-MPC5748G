//
// test.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// Test and demonstrate the counter and numeric capabilities
//
// Copyright (C) 2015 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "<", ">"

import "lib/iterations.stg"

Cmd()::= "<{cycleTime_set_<first(first(cluster.busAry).frameAry).attribMap.sendPeriod>}>"
attribName()::=<<
<{send<"Period">}>
>>

test(cluster,info) ::= <<
<first(cluster.busAry).sortFrameAry.byName><\\>
<iterateFramesOfCluster(cluster,"all","renderFrame")>

<first(cluster.busAry).sortFrameAry.byId><\\>
<iterateFramesOfCluster(cluster,"all","renderFrame")>

<first(cluster.busAry).sortFrameAry.bySize><\\>
<iterateFramesOfCluster(cluster,"all","renderFrame")>

<first(cluster.busAry).sortFrameAry.sentFirst><\\>
<iterateFramesOfCluster(cluster,"all","renderFrame")>

<first(cluster.busAry).sortFrameAry.receivedFirst><\\>
<iterateFramesOfCluster(cluster,"all","renderFrame")>

<info.info.(["Initially we have ", info.noCalcNumbers, " numbers in the scratch pad"])>
Initially we have <info.noCalcNumbers> numbers in the scratch pad.
We initialize number "hex".
<info.calc.hex_set_0xffffffffffffffff><\\>
<info.info.(["Now we have ", info.noCalcNumbers, " number(s) in the scratch pad"])>
Now we have <info.noCalcNumbers> number(s) in the scratch pad:<info.calc:{name|<" "><name>}>
<info.calc.x_set_16n><\\>
<info.calc.y_set_23><\\>
<info.calc.z_set_y><\\>
<info.calc.x_add_z><\\>
x=<info.calc.x>
x=<info.calc.x>
y=<info.calc.y>
y=<info.calc.y>
z=<info.calc.z>
z=<info.calc.z>
<info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr_1><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr_1><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr_1><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr_1><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.calc.hex_asr_64><info.info.({hex=<info.calc.hex; format="0x%x">})><\\>
<info.info.({hex=<info.calc.hex>})><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({y=<info.calc.y>})><\\>
<info.info.({z=<info.calc.z>})><\\>
<info.calc.x_mul_3><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.calc.y_add_25n><\\>
<info.calc.x_mul_y><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.calc.x_smul_y><\\>
<info.info.({x, get: <info.calc.x_get>})><\\>
<info.info.({x, get: <info.calc.x_get>})><\\>
<info.info.({x, get: <info.calc.x_get>})><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({x, get: <info.calc.x_get>})><\\>
<info.calc.x_sadd_0><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({x>0: <info.calc.x_isG>})><\\>
<info.info.({x>0: <info.calc.x_isG_0>})><\\>
<info.info.({x\<0: <info.calc.x_isL>})><\\>
<info.info.({x\<0: <info.calc.x_isL_0>})><\\>
<info.info.({x>=0: <info.calc.x_isGE>})><\\>
<info.info.({x>=0: <info.calc.x_isGE_0>})><\\>
<info.info.({x\<=0: <info.calc.x_isLE>})><\\>
<info.info.({x\<=0: <info.calc.x_isLE_0>})><\\>
<info.info.({x==0: <info.calc.x_isE>})><\\>
<info.info.({x==0: <info.calc.x_isE_0>})><\\>
<info.info.({x==168: <info.calc.x_isE_168>})><\\>
<info.info.({x==-168: <info.calc.x_isE_168n>})><\\>
<info.info.({x!=0: <info.calc.x_isNE>})><\\>
<info.info.({x!=0: <info.calc.x_isNE_0>})><\\>
<info.info.({x!=168: <info.calc.x_isNE_168>})><\\>
<info.info.({x!=-168: <info.calc.x_isNE_168n>})><\\>
<info.info.({x>-168: <info.calc.x_isG_168n>})><\\>
<info.info.({x\<-168: <info.calc.x_isL_168n>})><\\>
<info.info.({x>=-168: <info.calc.x_isGE_168n>})><\\>
<info.info.({x\<=-168: <info.calc.x_isLE_168n>})><\\>
<info.info.({x>z: <info.calc.x_isG_z>})><\\>
<info.info.({x\<z: <info.calc.x_isL_z>})><\\>
<info.info.({x=<info.calc.x>})><\\>
<info.info.({z=<info.calc.z>})><\\>
<info.calc.z_div_2><\\>
<info.info.({z=<info.calc.z>})><\\>
<info.calc.({noFrames_set_<cluster.noFrames>})><\\>
<if(info.calc.noFrames_isG_0)>uint16 noFrames = <info.calc.noFrames>;
<else><info.error.("No frames are defined!")><endif><\\>

<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
<info.calc.x_set_1n><\\>
<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
<info.calc.x_set_0><\\>
<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
<info.calc.x_set_100><\\>
<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
<info.calc.x_set_50><\\>
<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
<info.calc.x_set_101><\\>
<if(info.calc.x_isL_0)><info.calc.xBad_set_1n><else><info.calc.xBad_set_0><endif><\\>
<if(info.calc.x_isG_100)><info.calc.xTooLarge_set_1n><else><info.calc.xTooLarge_set_0><endif><\\>
<info.calc.xBad_or_xTooLarge><\\>
<if(info.calc.xBad_isNE_0)>#error x (<info.calc.x>) is out of range [0; 100]<endif>
<\\>
Finally we have <info.noCalcNumbers> numbers in the scratch pad:<\\>
<info.calc:{name|<\n>  <name> = <info.calc.(name)> <\\>
                              = <info.calc.(name); format="0x%x">}>
<! The next line will print different values if there are still sticky operations !>
<info.info.(["Finally we have ", info.noCalcNumbers, " numbers in the scratch pad", info.calc:{name|, <name>=<info.calc.([name, "_get"])>}])>

<info.debug.("This is a debug message")>
<info.info.("This is an info message")>
<info.warn.("This is a warning and should be counted")>
<info.warn.(["This is another ", "warning", " and should be counted"])>
Iteration on command interpreter: \<<info.warn:{k|<k>}>\>
>>


//
//<info.test.hello>
//<info.test.("hello")>
//<info.test.greeting>
//<info.test.("greeting")>
//<info.test.(attribName())>
//
//<info.info.helloWorld>
//<info.warn.("helloWorld")>
//<info.info.({<["There are ", length(first(cluster.busAry).frameAry), " frames defined"]>})>
//<info.info.(["There are ", length(first(cluster.busAry).frameAry), " frames defined"])>
//<info.info.(attribName())>
//<info.info.({send<"Period">})>
//<info.info.(first(cluster.busAry).noFramesx)>
//
//Counter Map:
//mask<info.calc.mask_smul_2>: <info.calc.mask; format="%x">, <info.calc.mask; format="%x">, <info.calc.mask; format="%x">
//Max Long<info.calc.i_set_9223372036854775807>: <info.calc.i>
//Overrun: <info.calc.i_add_1><info.calc.i>
//Min Long<info.calc.i_set_9223372036854775807n>: <info.calc.i>
//Underrun: <info.calc.i_add_2n><info.calc.i>
//
//cnt0             : <info.calc.cnt0><info.calc.cnt0_add_5n>
//cnt0             : <info.calc.cnt0>
//cnt1             : <info.calc.cnt1>
//myCustomCounter99: <info.calc.myCustomCounter99>
//myCustomCounter  : <info.calc.myCustomCounter>
//CounterMap iteration:
//<info.calc:{k|key:<k>, value:<info.calc.(k)><\n>}>
//Repeated countermap iteration:
//<info.calc:{k|key:<k>, value:<info.calc.(k)><\n>}>
//
//attribName: <attribName()>
//Cycle Time: <first(first(cluster.busAry).frameAry).attribMap.(attribName())> ms
//Cmd: <Cmd()>
//info.calc.(Cmd()): <info.calc.(Cmd())>
//info.calc.cycleTime: <info.calc.cycleTime>
//info.calc.cycleTime: <info.calc.cycleTime>
//info.calc.cycleTime: <info.calc.cycleTime>
//
//Buses:<info.calc.cnt1_set>
//  <iterateBusesOfCluster(cluster,"renderBus")><\\>
//
//All Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"all","renderFrame")><\\>
//All Frames in lexical order:<info.calc.cnt1_set_1>
//  <iterateFramesOfClusterByName(cluster,"all","renderFrame")><\\>
//All Frames in inverse lexical order:<info.calc.cnt1_set_1>
//  <iterateFramesOfClusterByNameReverse(cluster,"all","renderFrame")><\\>
//All Frames in order of CAN ID:<info.calc.cnt1_set_1>
//  <iterateFramesOfClusterById(cluster,"all","renderFrame")><\\>
//All Frames in inverse order of CAN ID:<info.calc.cnt1_set_1>
//  <iterateFramesOfClusterByIdReverse(cluster,"all","renderFrame")><\\>
//All Frames in order of parsing:<info.calc.cnt1_set_1>
//  <cluster.frameInFileOrderAry:{frameRef|<frameRef.bus:{bus|<renderFrame(frameRef.frame)>}>}><\\>
//Transmitted Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"both","renderFrame")><\\>
//Foreign Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"foreign","renderFrame")><\\>
//Loopback Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"loopback","renderFrame")><\\>
//Inbound Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"received","renderFrame")><\\>
//Outbound Frames:<info.calc.cnt1_set_1>
//  <iterateFramesOfCluster(cluster,"sent","renderFrame")><\\>
//
//All PDUs:
//  <iteratePdusOfCluster(cluster,"all","renderPdu")><\\>
//Transmitted PDUs:
//  <iteratePdusOfCluster(cluster,"both","renderPdu")><\\>
//Foreign PDUs:
//  <iteratePdusOfCluster(cluster,"foreign","renderPdu")><\\>
//Loopback PDUs:
//  <iteratePdusOfCluster(cluster,"loopback","renderPdu")><\\>
//Inbound PDUs:
//  <iteratePdusOfCluster(cluster,"received","renderPdu")><\\>
//Outbound PDUs:
//  <iteratePdusOfCluster(cluster,"sent","renderPdu")><\\>
//
//All multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"all","renderMuxSSet")><\\>
//Transmitted multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"both","renderMuxSSet")><\\>
//Foreign multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"foreign","renderMuxSSet")><\\>
//Loopback multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"loopback","renderMuxSSet")><\\>
//Inbound multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"received","renderMuxSSet")><\\>
//Outbound multiplexed signal sets:
//  <iterateMuxSSetsOfCluster(cluster,"sent","renderMuxSSet")><\\>
//
//All signals:
//  <iterateSignalsOfCluster(cluster,"all","all","renderSignal")><\\>
//All transmitted signals:
//  <iterateSignalsOfCluster(cluster,"all","both","renderSignal")><\\>
//All foreign signals:
//  <iterateSignalsOfCluster(cluster,"all","foreign","renderSignal")><\\>
//All loopback signals:
//  <iterateSignalsOfCluster(cluster,"all","loopback","renderSignal")><\\>
//All inbound signals:
//  <iterateSignalsOfCluster(cluster,"all","received","renderSignal")><\\>
//All outbound signals:
//  <iterateSignalsOfCluster(cluster,"all","sent","renderSignal")><\\>
//
//All normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","all","renderSignal")><\\>
//Transmitted normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","both","renderSignal")><\\>
//Foreign normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","foreign","renderSignal")><\\>
//Loopback normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","loopback","renderSignal")><\\>
//Inbound normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","received","renderSignal")><\\>
//Outbound normal signals:
//  <iterateSignalsOfCluster(cluster,"normal","sent","renderSignal")><\\>
//
//All multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","all","renderSignal")><\\>
//Transmitted multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","both","renderSignal")><\\>
//Foreign multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","foreign","renderSignal")><\\>
//Loopback multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","loopback","renderSignal")><\\>
//Inbound multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","received","renderSignal")><\\>
//Outbound multiplex selector signals:
//  <iterateSignalsOfCluster(cluster,"muxSel","sent","renderSignal")><\\>
//
//All multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","all","renderSignal")><\\>
//Transmitted multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","both","renderSignal")><\\>
//Foreign multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","foreign","renderSignal")><\\>
//Loopback multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","loopback","renderSignal")><\\>
//Inbound multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","received","renderSignal")><\\>
//Outbound multiplexed signals:
//  <iterateSignalsOfCluster(cluster,"muxed","sent","renderSignal")>
//>>

renderBus(bus) ::= "<info.calc.cnt1>) <bus> with <bus.noFrames> frames and <bus.noAttribDefs> attribute definitions<\n>"
renderFrame(frame) ::= "<info.calc.cnt1>) <frame>, <frame.id> (<frame.id; format=\"0x%03x\">) on bus <bus><\n>"
renderPdu(pdu) ::= "<pdu>, in: <pdu.isReceived>, out: <pdu.isSent>, no signals: <pdu.noSignals><\n>"
renderMuxSSet(muxSSet) ::= <<
PDU: <pdu>, selector: <pdu.muxSelector>, switch value: <muxSSet.muxValue>, <\\>
  signals: <muxSSet.signalAry:{s|<s>}; wrap="\n", separator=", "><\n>
>>
renderSignal(signal,kind) ::= "<signal> (<kind><if(strcmpMuxed.(kind))> on <muxSSet.muxValue><endif>), in: <signal.isReceived>, out: <pdu.isSent><\n>"