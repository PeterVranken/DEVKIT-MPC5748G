This sample demonstrates how a CAN API can be designed, which perfectly
integrates with the MathWorks Embedded Coder. Our code generator
generates the CAN API and the specification of this API in terms of MATLAB
readable *.m scripts. 

The sample is completed by a Simulink model implementing some functional
software on top of the CAN stack and by some simple, hand coded test code.
The demo application compileIt/EmbeddedCoderAPIWithBusStruct.exe can be
built.

The CAN API itself is generated by our code generator as
output/cap_canApi.c/h. Each CAN bus is modelled as a C struct; each frame,
which is processed by the given network node is a field in this struct.
The field is a struct itself, it contains the transmission status and a
collection of the signal values of the frame. The collection of signal
values is in turn a struct.

The complete C struct is then described with MATLAB Simulink's Bus and
Signal objects. The objects are initialized in the MATLAB global workspace
when the generated script output/initEcBusObjects.m is run.

Note, the library templates required by the code generation process are
included with a statement like: import "lib/mod.stg". The launch script
sets the path such that these files are taken from the main sample
raceTechnology. To make this sample self-contained you'd copy the lib
folder from raceTechnology/templates to the local folder templates.

The use of the CAN API from a Simulink model is demonstrated with the
model pwr_computeEnginePower.mdl. The generated Bus and Signal objects are
attached such to the in- and outputs of the Simulink model that the
Embedded Coder perfectly knows how to access the CAN signals and the frame
transmission status in the API. Where "how to access" not only means to
read or write the values but also how to interpret them. The scaling of
the signals is natural part of the information in the Simulink.Signal
objects. No matter what the signal scalings are can the signals be
interconnected inside the model. The code generation process of Simulink
will sort all scaling issues out.

The complete CAN input is a single bus inport in the model. (It will
become several bus inports if several DBC files are input to the code
generation.) This bus encompasses the signal values of inbound frames and
the transmission states of all frames. A bus selector is used to pick the
signals and transmission states of interest.

There's a certain asymmetry between in- and output: We may select any
subset of input signals from a bus but we have to set all the signals,
when creating an output bus with a Simulink bus creator. Therefore it is
not reasonably possible to offer a complete output bus structure. A
typical Simulink model will not serve all the outbound frames on a bus
but only relate to a sub-set of them. Our API design offers frame related
Simulink.Bus objects and the model will have an outport for each handled
outbound frame.

Actually, a Simulink model may even contribute to only a subset
of signals of a frame. This is not considered by the current
implementation of the templates: A Simulink.Signal would be required for
any outbound signal. It's easy and straightforward to extend the
templates accordingly and the other sample raceTechnology demonstrates how
to do. A drawback in doing so is that the MATLAB global workspace is
flooded with Simulink.Signal objects.

The use of bus and signal objects in the model requires some detailed
knowledge. Most of this is documented in the header of the generated MATLAB
script output/initEcBusObjects.m.

The DBC file used in this sample is the same as in the same integrations
of comFramework's CAN interface. Hence, the specification of the
functionality of the Simulink model can be found in form of the hand coded
APSW in the sample integration of the CAN interface. See
http://svn.code.sf.net/p/comframe/code/canInterface/trunk/components/winSampleIntegration/code/APSW.

Note, the pack and unpack functions as essential part of the code generation
process are not included in the demo application. This sample focuses on
interfacing with the Embedded Coder but using the pack and unpack
functions is rather subject to interfacing with the lower layers of the CAN
stack. These functions would be used when integrating the code with a real
CAN hardware. Our demo application directly puts input signal values into
the generated API struct and reads the outputs of the APSW the same way.

The code generation of the CAN API can be repeated by running the Windows
script generateCode.cmd from this working directory. Repeating the code
generation should be tried as kind of installation test of the our code
generator application.

The code generation of the APSW with the Embedded Coder from the Simulink
model is possible with MATLAB 2009b. Delete the folders
pwr_computeEnginePower_ert_rtw and slpr, then open the model
pwr_computeEnginePower.mdl and type Ctrl-B. If you don't have MATLAB then
you will find the generated C code in the folders
pwr_computeEnginePower_ert_rtw and slprj.

Note, we only added those Embedded Coder generated files to SVN repository
and downloadable archive, which are required to build the demo
application. The other files and folders generated by the Embedded Coder
are missing, confuse the Coder and let it abort with a meaningless error
message. This is why you will have to completely delete the Embedded Coder
generated output prior to the first code generation.

If you want to run our code generator from another working folder then you
will have to modify the launch script: The Windows script references the
required resources by relative paths from here. Please, refer to
codeGenerator/doc/installation.txt, too.

To make the generated C sources compilable and testable we've added the
hand-coded compileIt/mai_main.c. The makefile is compatible with GNU make
3.81. To successfully run the build make and gcc need to be on the system
search path. The build has been tried with MinGW gcc.exe (GCC) 4.5.2 under
Windows 7 only; as a matter of experience other GCC versions and their
libraries, e.g. the 64 Bit port, are not perfectly compatible, just give
it a try. Note, C99 compliance is a must.

To build and execute the demo application type:

cd compileIt
make run

The demo application can be debugged using the script gdb.ps1. The GNU
debugger needs to be on the system search path.

All Windows scripts are trivial; porting them to Linux or Mac OS is
straightforward.
