//
// EmbeddedCoderInterface.m.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// The contents of the network databases are presented as a MATLAB script file for the
// Embedded Coder configuration. Embedded Coder is a C code generator from the Mathworks
// for model based software design and the generated configuration file specifies the CAN
// interface, which is generated by the other template cif.c.stg, to the Embedded Coder
// code generator so that both portions of generated C code directly fit together.
//
// Copyright (C) 2015 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "<", ">"

import "lib/typeMap.stg"
import "shared.stg"


ecInterface(cluster, info) ::= <<
% This is an interface specification for the Mathwork's Embedded Coder C code generator.
%
% This file has been created with <info.application> version <info.version>,
% see http://sourceforge.net/projects/comframe/
%
% The interface is generated from these network database files:
<listOfDbcFiles(cluster)><\\>
<cluster.busAry:renderBus()>
>>

listOfDbcFiles(cluster) ::= <<
<cluster.busAry:{b|%   <b.networkFile><\n>}>
>>


renderBus(bus) ::= <<

%
% CAN Bus <bus.name>
%

% Received Frames

<bus.frameAry:renderReceivedFrame()><\\>
% Sent Frames

<bus.frameAry:renderSentFrame()><\\>
% Unused Frames

<bus.frameAry:renderUnusedFrame()>
>>
 
renderSentFrame(frame) ::= "<if(frame.isSent)><renderFrame()><endif>"
renderReceivedFrame(frame) ::= "<if(frame.isReceived)><renderFrame()><endif>"
renderUnusedFrame(frame) ::= "<if(!frame.isSent && !frame.isReceived)><renderFrame()><endif>"
 
renderFrame() ::= <<
% Frame <frame.name>, <frame.id> (<frame.id; format="0x%03x">)
<frame.pduAry:renderPdu()>

>>
 
 
// Render the signal declarations for all signals of a PDU. The multiplex selector signal
// and the signals from the multiplexed signal sets are optional and will expand mostly to
// nothing.
renderPdu(pdu) ::= <<
<pdu.signalAry:renderSignal()><\\>
<pdu.muxSelector:renderSignal()><\\>
<pdu.muxSignalSetAry:{ss|<ss.signalAry:renderSignal()>}>
>>


// A map is used to translate the C target type into the Embedded Coder fixed point object.
fixPtTypeMap ::=
[
    "bool_t"   : "boolean",
    "uint8_t"  : {fixdt(0, 8,  <signal.factor>, <signal.offset>)},
    "uint16_t" : {fixdt(0, 16, <signal.factor>, <signal.offset>)},
    "uint32_t" : {fixdt(0, 32, <signal.factor>, <signal.offset>)},
    "uint64_t" : {fixdt(0, 64, <signal.factor>, <signal.offset>)},
    "sint8_t"  : {fixdt(1, 8,  <signal.factor>, <signal.offset>)},
    "sint16_t" : {fixdt(1, 16, <signal.factor>, <signal.offset>)},
    "sint32_t" : {fixdt(1, 32, <signal.factor>, <signal.offset>)},
    "sint64_t" : {fixdt(1, 64, <signal.factor>, <signal.offset>)},
    "float32_t": "single",
    "float64_t": "double",
    default    : "InternalError_BadTypeName"
]


renderSignal(signal) ::= <<
% Signal <cSigName()>
<cSigName()> = Simulink.Signal;
<cSigName()>.RTWInfo.StorageClass = 'ImportedExtern';
<cSigName()>.RTWInfo.Alias = '';
<cSigName()>.Description = ...
  <signalDescription(signal)>;
<cSigName()>.DataType = '<fixPtTypeMap.(signal.type)>';
<cSigName()>.Min = <signal.min>;
<cSigName()>.Max = <signal.max>;
<cSigName()>.DocUnits = '<signal.unit>';
<cSigName()>.Dimensions = 1;
<cSigName()>.Complexity = 'real';
<cSigName()>.SampleTime = -1;
<cSigName()>.SamplingMode = 'Sample based';
<cSigName()>.InitialValue = '';<\n>
>>


signalDescription(signal) ::= <<
[<if(signal.desc)>'<signal.desc>' char(10) ...<\n> <endif><\\>
 'Frame: <frame>, <frame.id> (<frame.id; format="0x%03x">).' char(10) ...
 'Signal: <signal>.' char(10) ...
 'Range (world values): <signal.min> ... <signal.max> [<signal.unit>].' char(10) ...
 'Scaling: WorldValue = <\\>
<if(signal.isVoidScaling)>BinaryValue<else><signal.factor>*BinaryValue + <signal.offset><endif> [<signal.unit>]' ...
]
>>

