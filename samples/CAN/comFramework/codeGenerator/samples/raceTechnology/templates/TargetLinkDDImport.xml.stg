//
// TargetLinkDDImport.xml.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// The contents of the network databases are presented as a TargetLink DataDictionary
// import file. TargetLink is a C code generator from dSPACE for model based software
// design and the generated import file specifies the CAN interface, which is generated by
// the other template cif.c.stg, to the TargetLink code generator so that both portions of
// generated C code directly fit together.
//
// Copyright (C) 2015-2016 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "$", "$"

import "lib/typeMap.stg"
import "lib/iterations.stg"
import "shared.stg"


tlDDImport(cluster, info) ::= <<
<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- This is an interface specification for the dSPACE TargetLink C code generator -->
<!-- Created with $info.application$ version $info.version$, see http://sourceforge.net/projects/comframe/ -->
<!-- The interface is generated from these network database files: -->
$listOfDbcFiles(cluster)$$\\$
<ddObj Name="Variables" Kind="VariableGroup" xmlns="http://www.dspace.de/DataDictionaryExtended" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  $cluster.busAry:renderBus()$$\\$
</ddObj>
>>

listOfDbcFiles(cluster) ::= <<
$cluster.busAry:{b|<!-- $b.networkFile$ -->$\n$}$
>>

renderBus(bus) ::= <<
<ddObj Name="CANBus_$bus.name$" Kind="VariableGroup">
  <ddObj Name="ReceivedFrames" Kind="VariableGroup">
    $iterateFramesOfBus(bus,"received","renderFrame")$$\\$
  </ddObj>
  <ddObj Name="SentFrames" Kind="VariableGroup">
    $iterateFramesOfBus(bus,"sent","renderFrame")$$\\$
  </ddObj>
  <ddObj Name="UnusedFrames" Kind="VariableGroup">
    $iterateFramesOfBus(bus,"foreign","renderFrame")$$\\$
  </ddObj>
</ddObj>$\n$
>>


renderFrame(frame) ::= <<
<ddObj Name="$frame.name$_$frame.id$_$frame.id; format="0x%03x"$" Kind="VariableGroup">
  $iterateSignalsOfFrame(frame,"all","all","renderSignal")$$\\$
</ddObj>$\n$
>>


renderSignal(signal,kind) ::= <<
<ddObj Name="$cSigName()$" Kind="Variable">
  <ddProperty Name="Description">$signalDescription(signal)$</ddProperty>
  <ddProperty Name="Class">EXTERN_GLOBAL</ddProperty>
  <ddProperty Name="Type">$bt(signal.type)$</ddProperty>
$if(signal.isVoidScaling)$
  <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
$else$
  <ddProperty Name="Scaling">./LocalScaling</ddProperty>
$endif$
  <ddProperty Name="Width"/>
  <ddProperty Name="Value"/>
  <ddProperty Name="Min">$signal.min$</ddProperty>
  <ddProperty Name="Max">$signal.max$</ddProperty>
  <ddProperty Name="Address"/>
  <ddProperty Name="NameTemplate">\$D</ddProperty>
$if(!signal.isVoidScaling)$
  <ddObj Name="LocalScaling" Kind="ScalingObject">
    <ddProperty Name="Description">Linear scaling</ddProperty>
    <ddProperty Name="ConversionType">LINEAR</ddProperty>
    <ddProperty Name="LSB">$signal.factor$</ddProperty>
    <ddProperty Name="Offset">$signal.offset$</ddProperty>
    <ddProperty Name="Format">%g</ddProperty>
    <ddProperty Name="Unit">$signal.unit$</ddProperty>
  </ddObj>
$endif$
</ddObj>$\n$
>>


signalDescription(signal) ::= <<
Frame: $frame$, $frame.id$ ($frame.id; format="0x%03x"$). $frame.desc; format="xml-encode"$&#10;  $\\$
Signal: $signal$. $signal.desc; format="xml-encode"$&#10;  $\\$
Range (world values): $signal.min$ ... $signal.max$ [$signal.unit$].&#10;  $\\$
Scaling: WorldValue = $\\$
$if(signal.isVoidScaling)$BinaryValue$else$$signal.factor$*BinaryValue + $signal.offset$$endif$ [$signal.unit$]
>>

