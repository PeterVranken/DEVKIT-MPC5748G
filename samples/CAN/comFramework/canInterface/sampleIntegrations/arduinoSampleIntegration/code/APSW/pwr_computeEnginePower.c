/**
 * @file pwr_computeEnginePower.c
 * This is a (trivial) example of the functional application software (APSW), which would
 * have to be integrated with the operating system and the CAN interface engine to a
 * complete operational software.\n
 *   The main characteristics of the APSW is that it is widely independent from the
 * platform and its I/O mechanisms. Maybe it uses some generic macros to access the
 * platform layer I/O (and the macro definiton becomes a substantial part of the code
 * integration) or a function or data absed API is defined.\n
 *   In this sample integration we assume a data based API, providing access to all in- and
 * output signals. We directly use the data structure as generated by the code generator as
 * such data based API.
 *
 * Copyright (C) 2015 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   pwr_computeEnginePwr
 *   pwr_checkUserLimits
 *   pwr_updateDisplay
 * Local functions
 */

/*
 * Include files
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>

#include "rtos_assert.h"
#include "pck_packCanFrame.h"
#include "dpy_display.h"
#include "apt_applicationTask.h"
#include "sim_simulateCanReception.h"
#include "pwr_computeEnginePower.h"


/*
 * Defines
 */

#ifndef M_PI
# define M_PI   3.14159265358979323846
#endif

/* The positions of the different error indicator characters in the status string. */
#define IDX_CHAR_TO     0
#define IDX_CHAR_DLC    1
#define IDX_CHAR_CHKSUM 2
#define IDX_CHAR_SQC    3
#define IDX_CHAR_BUSOFF 4
#define IDX_CHAR_LAST   4


/*
 * Local type definitions
 */


/*
 * Local prototypes
 */


/*
 * Data definitions
 */
 
/** The CAN error status for output on the display. The data is shared between the two APSW
    tasks, 10ms and 100ms. */
static volatile cbk_stsTransmission_t /* i.e. uint8 */ _stsCan = cbk_stsTransm_okay;

/** The task functions of the 100ms APSW task need to access the CAN API information owned
    by the 10ms APSW task in a critical section. To avoid overhead they make a copy and
    share the copied data. A maybe better design would be to have a single 100ms task
    function and to make this static struct an automatic variable of the function. */
static pck_PT_InfoPowerDisplay_1536_t _PT_InfoPowerDisplay_1536 =
{
    .checksum = 0,
    .sequenceCounter = 0,
    .power = (uint16_t)((0.0 /* W */ - -500000.0) / 32.0),
    .state = 0
};



/*
 * Function implementation
 */


/**
 * Increment the global error counters. The counters are found in the CAN API; it are data
 * change triggered frames and any change leads without any additional ado to broadcasting
 * the information via CAN.
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 */
static void updateGlobalErrCounters(boolean_t errDlc, boolean_t errChksum, boolean_t errSqc)
{
    /* Consider possible overrun and limit the counters. */
    if(errDlc)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noDlcErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noDlcErrors;
    }
    if(errChksum)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noCheckSumErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noCheckSumErrors;
    }
    if(errSqc)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noSqcErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noSqcErrors;
    }
} /* End of updateGlobalErrCounters */




/**
 * Simulation of the APSW: The step function to be regularly called every 10 ms. It
 * computes the current engine power from the CAN input, displays it and broadcasts it on
 * the CAN bus.
 */
void pwr_computeEnginePwr()
{
    /* Only compute a new value if the status of all required CAN input frames is alright. */
    boolean_t bSuccess = true;
    if(pck_API_PT_StateEcu01_1024.stsTransmission != cbk_stsTransm_okay)
    {
        bSuccess = false;

        /* Collect status indicator bits for LCDisplay. */
        _stsCan |= pck_API_PT_StateEcu01_1024.stsTransmission;

        /* Count the errors and report the status change with a data-change triggered frame
           on the CAN bus. */
        static cbk_stsTransmission_t stsTransmission_last_ = cbk_stsTransm_okay;
        if(pck_API_PT_StateEcu01_1024.stsTransmission != stsTransmission_last_)
        {
            /* The logic here using a last-value-variable shared for all error bits is not
               fully corrcet. If a new error appears additional to an already existing one
               then the already existing one is counted again. However, this is irrelevant
               in practice. */
            boolean_t errDlc = (pck_API_PT_StateEcu01_1024.stsTransmission
                                & cbk_stsTransm_errDLC
                               ) != 0
                    , errChksum = (pck_API_PT_StateEcu01_1024.stsTransmission
                                   & cbk_stsTransm_errChecksum
                                  ) != 0
                    , errSqc = (pck_API_PT_StateEcu01_1024.stsTransmission
                                & cbk_stsTransm_errSequence
                               ) != 0;
            updateGlobalErrCounters(errDlc, errChksum, errSqc);

            stsTransmission_last_ = pck_API_PT_StateEcu01_1024.stsTransmission;
        }
    }
    if(pck_API_PT_StateEcu02_1040.stsTransmission != cbk_stsTransm_okay)
    {
        bSuccess = false;

        /* Collect status indicator bits for LC display. There, the representation is not
           specific to the frame. The few characters of the LCD demand a condensed
           display. */ 
        _stsCan |= pck_API_PT_StateEcu01_1024.stsTransmission;

        /* Count the errors and report the status change with a data-change triggered frame
           on the CAN bus. */
        static cbk_stsTransmission_t stsTransmission_last_ = cbk_stsTransm_okay;
        if(pck_API_PT_StateEcu02_1040.stsTransmission != stsTransmission_last_)
        {
            boolean_t errDlc = (pck_API_PT_StateEcu02_1040.stsTransmission
                                & cbk_stsTransm_errDLC
                               ) != 0
                    , errChksum = (pck_API_PT_StateEcu02_1040.stsTransmission
                                   & cbk_stsTransm_errChecksum
                                  ) != 0
                    , errSqc = (pck_API_PT_StateEcu02_1040.stsTransmission
                                & cbk_stsTransm_errSequence
                               ) != 0;
            updateGlobalErrCounters(errDlc, errChksum, errSqc);

            stsTransmission_last_ = pck_API_PT_StateEcu02_1040.stsTransmission;
        }
    }

    if(bSuccess)
    {
        float torque =  PCK_PT_1040_TORQUE_BIN_TO_FLT
                                    (pck_API_PT_StateEcu02_1040.signals.torque)
            , speedOfRotation = PCK_PT_1024_SPEEDOFROTATION_BIN_TO_FLT
                                    (pck_API_PT_StateEcu01_1024.signals.speedOfRotation)
            , power = 2.0 * M_PI / 60.0 * torque * speedOfRotation;

        /* Broadcast the results on the CAN bus: Put the computed power result into the API
           of the sent frame. A range check is done to ensure safe encoding. If the double
           wouldn't fit then the state is set to overflow. */
        float powerSaturated;
        if(power > PCK_PT_1536_POWER_MAX)
        {
            powerSaturated = PCK_PT_1536_POWER_MAX;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 2 /* overflow */;
        }
        else if(power < PCK_PT_1536_POWER_MIN)
        {
            powerSaturated = PCK_PT_1536_POWER_MIN;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 2 /* overflow */;
        }
        else
        {
            /* Normal operation. */
            powerSaturated = power;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 0 /* valid */;
        }
        pck_API_PT_InfoPowerDisplay_1536.signals.power =
                                                PCK_PT_1536_POWER_FLT_TO_BIN(powerSaturated);
    }
    else
    {
        /* Preconditions not met, no result available. Broadcast this information. */
        pck_API_PT_InfoPowerDisplay_1536.signals.power = PCK_PT_1536_POWER_FLT_TO_BIN(0.0);
        pck_API_PT_InfoPowerDisplay_1536.signals.state = 1 /* invalid input */;
    }
} /* End of pwr_computeEnginePwr */




/**
 * Check the current speed of rotation and engine power against the user set limits.\n
 *   This operation is barely useful but has been specified just as an application of
 * purely data change triggered CAN frames: An inbound frame is received in the instance
 * the user has redefined the limits (via whatever human machine interface) but never else
 * and the check result is sent out only if it changes in at least one bit.\n
 *   The check is done regularly from the 100 ms task: This gives an example of code, where
 * the interface is served by a dispatcher in one application task but the dispatched data
 * is accessed by another task. While the concept of the CAN interface makes CAN processing
 * race condition free programming, remains the further data processing of course subject
 * to the usual techniques of sharing data between concurrent threads or processes.
 */
void pwr_checkUserLimits()
{
    /* This function simply looks into the affected CAN messages (using the global message
       API) and conduct its checks. The new check results are unconditionally written into
       the related outbound message. Whether it is sent or not is entirely decided by the
       underlying CAN interface engine, which looks for data changes as trigger.
         The concept of frequently looking at signal values to detect changes looks unusual
       and inefficient in the context of traditional hand-made C code. There, an event
       oriented coding paradigm is typically applied, where code is executed when something
       happens or is decided. In such an environment, we would probably have a set/get API
       to the signals of the frames and the set methods could set a frame-changed-flag and
       trigger sending this way. Our code generator can make such an interface with ease.
         However, the chosen style of the sample has the perspective of auto-generated C
       APSW code. Such code is mostly generated from a data flow oriented coding paradigm.
       All (parallel) operations of a network of function blocks are executed in the right
       (sequential) order and this is done unconditionally. The results of the operations
       have the meaning of samples of the signals in the network and such a sample is
       computed for each tick. Whether it changes or not in comparison to its predecessor
       is normally out of scope of the operations, always is the next sample written into
       the output variable. In such an environment it is most useful if the embedding code
       can detect value changes as required for data change driven CAN frames. */

    /* This code is run in the 100ms task but all CAN processing (in particular the update
       of the CAN API) is done in the prior 10ms task. We need mutual exclusion, when
       accessing the data. This exclusion can be done on a per frame base as there is
       anyway no data integrity defined across frames in CAN communication. */
    cli();
    _PT_InfoPowerDisplay_1536 = pck_API_PT_InfoPowerDisplay_1536.signals;
    sei();

    if(_PT_InfoPowerDisplay_1536.state == 0 /* valid */)
    {
        cli();
        uint16_t speedOfRotation = pck_API_PT_StateEcu01_1024.signals.speedOfRotation;
        pck_PT_UserLimits_2032_t PT_UserLimits_2032 = pck_API_PT_UserLimits_2032.signals;
        sei();

        /* The sequence counter is incremented in place by the API engine. We need to take
           a copy to retain the last value (or only copy selected signals below).
             Copying doesn't need to be necessarily done inside the critical section: An
           update of the counter by the preempting 10ms task won't happen now but may have
           happened at latest as a result of the previous 100ms tick (on data change only
           for this particular frame!) */
        pck_PT_LimitsPowerDisplay_1538_t PT_LimitsPowerDisplay_1538;
        PT_LimitsPowerDisplay_1538.sequenceCounter =
                                  pck_API_PT_LimitsPowerDisplay_1538.signals.sequenceCounter;

        /* Power could be updated recently, which means that all input had been validated.
           We can perform the checks. */
        float value = PCK_PT_1024_SPEEDOFROTATION_BIN_TO_FLT(speedOfRotation)
            , limit = PCK_PT_2032_MINSPEEDOFROTATION_BIN_TO_FLT
                                                    (PT_UserLimits_2032.minSpeedOfRotation);
        PT_LimitsPowerDisplay_1538.belowMinSpeedOfRotation = value < limit;

        limit = PCK_PT_2032_MAXSPEEDOFROTATION_BIN_TO_FLT
                                                (PT_UserLimits_2032.maxSpeedOfRotation);
        PT_LimitsPowerDisplay_1538.aboveMaxSpeedOfRotation = value > limit;

        /* Power: Limit is in kW, value in W. */
        value = 0.001 * PCK_PT_1536_POWER_BIN_TO_FLT(_PT_InfoPowerDisplay_1536.power);
        limit = PCK_PT_2032_MINPOWER_BIN_TO_FLT(PT_UserLimits_2032.minPower);
        PT_LimitsPowerDisplay_1538.belowMinPower = value < limit;

        limit = PCK_PT_2032_MAXPOWER_BIN_TO_FLT(PT_UserLimits_2032.maxPower);
        PT_LimitsPowerDisplay_1538.aboveMaxPower = value > limit;

        /* Copying the altered frame signals back into the API needs to be done inside the
           critical section. Since we had saved the sequence counter we can copy the
           complete object at once. */
        cli();
        pck_API_PT_LimitsPowerDisplay_1538.signals = PT_LimitsPowerDisplay_1538;
        sei();
    }
    else
    {
        /* No safe, validated input information is currently available, we don't do
           anything in this tick. */
           
    } /* End if(Power information safely available on the CAN bus?) */
    
} /* End of pwr_checkUserLimits */




/**
 * Update the information shown in the LCDisplay. This function is to called regularly from
 * the 100ms APSW task.
 */

void pwr_updateDisplay()
{
    cli();
    cbk_stsTransmission_t stsCan = _stsCan;
    sei();
    
    /* We merge the bus-off status in this variable to unify its handling and reporting.
       The global variable apt_canBusOff is owned by the same task and no critical section
       is required. */
    ASSERT((stsCan & 0x80) == 0);
    if(apt_canBusOff)
        stsCan |= 0x80;
    
    /* Update the CAN transmission status display whenever it changes - and hold it for a
       few ticks to make it better readable. */
    static uint8_t cntHoldStsCan_ = 1
                 , lastStsCan_ = cbk_stsTransm_okay;
    if(stsCan != lastStsCan_)
    {
        char strSts[IDX_CHAR_LAST+1+1] = "     ";
        if((stsCan & cbk_stsTransm_errTimeout) != 0)  strSts[IDX_CHAR_TO] = 'T';
        if((stsCan & cbk_stsTransm_errDLC) != 0)      strSts[IDX_CHAR_DLC] = 'D';
        if((stsCan & cbk_stsTransm_errChecksum) != 0) strSts[IDX_CHAR_CHKSUM] = 'C';
        if((stsCan & cbk_stsTransm_errSequence) != 0) strSts[IDX_CHAR_SQC] = 'S';
        if((stsCan & 0x80) != 0)                      strSts[IDX_CHAR_BUSOFF] = 'B';
        dpy_printStatus(strSts);
        cntHoldStsCan_ = 10; /* Unit 100ms */
        lastStsCan_ = stsCan;
    }
    else if(cntHoldStsCan_ > 1)
        -- cntHoldStsCan_;
#if SIM_DO_ERROR_SIMULATION == 0
    /* The simulation layer of this demonstration application will not inject any simulated
       CAN error. The display must never indicate any problem. In order to prove this we
       turn the code off that normally clears the display after the hold time; run the
       application for a long time and check for a still blank display.
         Caution: The bus-off 'B' is still cleared as we merge this bit here locally. */
#else
    else
    {
        dpy_printStatus("    ");
        lastStsCan_ = cbk_stsTransm_okay;
        cli();
        _stsCan = cbk_stsTransm_okay;
        sei();
    }
#endif    

    /* Print current power values on the LCDisplay. Do this at two rates: high update rate
       for the pseudo-analog display, low update rate for numeric display.
         The status is ignored; if it is not "valid" then the numeric value is still the
       best possible choice to display. The also shown speed of rotation value may be
       inconsistent in this case, it's the last recently received good value. We don't care
       about this. */
            
    /* The display expects power as an integer value in kW. */
    int16_t powerInKw_I16 = 4ul*_PT_InfoPowerDisplay_1536.power/125 - 500;
    /* The pseudo-analog display doesn't know negative values. They have to be truncated
       here. */
    uint8_t powerInKw_U8 = powerInKw_I16 >= 255
                           ? 255
                           : (powerInKw_I16 <= 0? 0: (uint8_t)powerInKw_I16)
                           ;
    dpy_printValueAsBar(/* value */ powerInKw_U8, /* fullScale */ 250);

    static uint8_t cntDispPwrNum_ = 1;
    if(cntDispPwrNum_ == 5)
    {
        cli();
        int16_t torque = pck_API_PT_StateEcu02_1040.signals.torque;
        sei();
        dpy_printTqAndPwr(torque/2, powerInKw_I16);
        cntDispPwrNum_ = 0;
    }
    ++ cntDispPwrNum_;

} /* End of pwr_updateDisplay */
