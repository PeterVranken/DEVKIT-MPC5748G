<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="" xml:lang="">
<head>
  <meta charset="utf-8" />
  <meta name="generator" content="pandoc" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes" />
  <title>readMe</title>
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    span.underline{text-decoration: underline;}
    div.column{display: inline-block; vertical-align: top; width: 50%;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
  </style>
  <!--[if lt IE 9]>
    <script src="//cdnjs.cloudflare.com/ajax/libs/html5shiv/3.7.3/html5shiv-printshiv.min.js"></script>
  <![endif]-->
</head>
<body>
<nav id="TOC" role="doc-toc">
<ul>
<li><a href="#arduino-engine-power-display-with-mathworks-embedded-coder"><span class="toc-section-number">1</span> Arduino Engine Power Display with MathWorks Embedded Coder</a>
<ul>
<li><a href="#scope"><span class="toc-section-number">1.1</span> Scope</a></li>
<li><a href="#application-design"><span class="toc-section-number">1.2</span> Application design</a>
<ul>
<li><a href="#folder-canshield"><span class="toc-section-number">1.2.1</span> Folder canShield</a></li>
<li><a href="#folder-apsw"><span class="toc-section-number">1.2.2</span> Folder APSW</a></li>
<li><a href="#folder-integration"><span class="toc-section-number">1.2.3</span> Folder integration</a></li>
<li><a href="#folder-codegen"><span class="toc-section-number">1.2.4</span> Folder codeGen</a></li>
<li><a href="#folder-rtos"><span class="toc-section-number">1.2.5</span> Folder RTOS</a></li>
</ul></li>
</ul></li>
</ul>
</nav>
<h1 data-number="1" id="arduino-engine-power-display-with-mathworks-embedded-coder"><span class="header-section-number">1</span> Arduino Engine Power Display with MathWorks Embedded Coder</h1>
<h2 data-number="1.1" id="scope"><span class="header-section-number">1.1</span> Scope</h2>
<p>This sample application implements a power display device for an automotive vehicle. It reads the current values of engine rotational speed and engine torque from the CAN bus and computes the current power of the engine. The power is displayed on Arduino’s LCD (2*16 characters) and broadcasted on the CAN bus.</p>
<p>The difference to the other Arduino sample integration is that the functional software – the APSW, all the computation of torques and powers – is not hand coded but model based. A MathWorks Simulink model specifies the functionality and it can use the code generator Embedded Coder to translate this specification into ready-to-use C code. This technique requires proper interfacing between the Simulink model and our CAN interface. The sample demonstrates how our code generator can produce an Embedded Coder script (*<em>.m</em>) so that it generates C code, which directly connects to the CAN interface.</p>
<p>The sample code comes along with all source files and build scripts (makefile based). It can be compiled for the Mega2560 board; other boards will need migration work and tiny boards won’t work at all because of the RAM consumption.</p>
<p>Those who don’t have the LyquidCristal shield for their Arduino Mega can still upload and run the sample: The computed power and some relevant status information (like CPU load and task overrun counters) are printed regularly to the console window of the Arduino IDE. (Serial connection must be opened at the IDE.) Please note, status information is printed only in DEBUG compilation.</p>
<p>The build requires an Arduino 1.0.6 installation and additionally the environment variable ARDUINO_HOME needs to point to this installation. The reason is that the GNU avr-gcc tools and the Arduino libraries are located by the makefile via this variable. GNU make 3.81 should be in the system search path, then the build command would be (Windows, other systems accordingly):</p>
<pre><code>cd &lt;...&gt;\comFramework\canInterface\components\arduinoSampleIntegrationEmbeddedCoder
make build</code></pre>
<p>to build the flashable hex file or</p>
<pre><code>cd &lt;...&gt;\comFramework\canInterface\components\arduinoSampleIntegrationEmbeddedCoder
make -s COM_PORT=COM10 upload</code></pre>
<p>to build and upload the application to a Arduino Mega board, which is connected to the specified COM port.</p>
<p>Note, on Windows systems you will need the MinGW port of make, not the Cygwin port. Many GCC distributions contain both variants, so it depends on your system search path, which one is run. Or consider typing <code>mingw32-make build</code>; in a Windows GCC distribution this should be a safe reference to the right implementation of make. The Cygwin variant uses another interface to the underlying shell and this interface is not compatible with our makefiles.</p>
<p>Arduino 1.6 won’t work out of the box; the Arduino people decided to no longer package the Arduino IDE with the GNU avr-gcc tools and the makefile will fail to locate these tools. You will have to modify the makefile or use your system search path settings to overcome this.</p>
<p>Caution, we’ve never tried this code with Arduino 1.6 so far!</p>
<h2 data-number="1.2" id="application-design"><span class="header-section-number">1.2</span> Application design</h2>
<p>This is a sample integration of comFramework’s CAN interface but not an Arduino sample. Arduino is just an easily available, commonly known, easy to use platform. We designed this application to demonstrate how an integration of the CAN interface into a real platform can look like. The actual capabilities of the application are secondary. Our CAN interface builds on the hardware driver layer. This means a CAN shield for Arduino.</p>
<h3 data-number="1.2.1" id="folder-canshield"><span class="header-section-number">1.2.1</span> Folder canShield</h3>
<p>So far the integration doesn’t go down to real CAN hardware. Instead a simulation frame has been shaped, which exposes a typical CAN hardware driver interface to the rest of the software. This interface looks like and behaves as a real hardware driver. The interrupt characteristics of the real hardware driver is simulated by using a random controlled, asynchronously running task of highest priority.</p>
<p>The simulation computes triangular curves of different frequencies for speed of rotation and engine torque. This leads to a dynamic but not exciting behavior of the application. The implementation uses floating point operations, which is acceptable as it is a simulation anyway and we still have lots of CPU power reserve. The drawback of using floating point operations is that we completely loose the feeling of how much CPU load is produced by the CAN interface and the related pack/unpack functions; much of the load will result from simulation and APSW.</p>
<p>The simulation code can inject the following kinds of CAN communication errors: Timeout, wrong data length code, bad checksum, bad sequence counter value, bus-off error (and recovery). The occurrence of the errors is random controlled; the probabilities can be adjusted by #define macros at compile time.</p>
<p>The fictive but realistic CAN shield API and the it feeding simulation code have been placed in folder code\canShield. If this application would be made a real CAN device then this folder would become obsolete and replaced by some adaptation of the remaining code to the actual CAN API.</p>
<h3 data-number="1.2.2" id="folder-apsw"><span class="header-section-number">1.2.2</span> Folder APSW</h3>
<p>The functional code, the application software or APSW, reads the current speed of rotation and engine torque values, computes the current engine power and updates the LCDisplay. It displays speed of rotation and power and the recognized CAN communication errors.</p>
<p>The APSW is made by model based design. A MathWorks Simulink model implements the APSW functionality and the MathWorks Embedded Coder generates C code from this model. The generated code is part of the sample and the code generation can be reproduced with MATLAB 2019b. To do so, delete the folder pwr_computeEnginePower_ert_rtw. Open MATLAB and run script initEcBusObjects.m. Open the model pwr_computeEnginePower.slx and type Ctrl-B. The C source code is (re-)generated in folder pwr_computeEnginePower_ert_rtw. Folder slprj is generated, too, but the files in this folder are not required for our purpose.</p>
<p>Note, MATLAB is a non open source tool and the code generation requires a licence. If you don’t have MATLAB then you will find the generated C code in the folder pwr_computeEnginePower_ert_rtw.</p>
<p>The CAN interface is specified to the Embedded Coder through file code\APSW\initEcBusObjects.m. This file is generated by the comFramework code generator from the DBC file. When executed by MATLAB it creates a set of Simulink Bus and Signal objects, which are attached to the in- and outports and in- and output signals of the Simulink model. This way, the Embedded Coder can generate C source code, which seamlessly links to the CAN interface we have generated. No additional hand-code is needed.</p>
<p>Note, the Embedded Coder has the full interface information. This includes the scaling of in- and output signals. The Embedded Coder is capable to do all operations on the signals just like that in fixed point operations. No floating point operations are involved.</p>
<p>The APSW is nearly identical to the code generator sample <a href="https://svn.code.sf.net/p/comframe/code/codeGenerator/trunk/samples/EmbeddedCoderAPIWithBusStruct" title="SVN Repo codeGenerator">EmbeddedCoderAPIWithBusStruct</a>. Refer to this sample and read file <em>readMe.txt</em> to get more details about the configuration of the Simulink/Embedded Coder model with help of MATLAB script files that are auto-coded from the DBC files.</p>
<p>The APSW code is located in folder code\APSW.</p>
<h3 data-number="1.2.3" id="folder-integration"><span class="header-section-number">1.2.3</span> Folder integration</h3>
<p>The folder code\integration contains those hand-coded parts of the application, which are needed to integrate the CAN interface with any real platform (or operating system). The tasks are defined that do the initialization of the CAN interface (frame and bus registration) and the regular clocking of the interface engine instances. Moreover, the handle mapping and the checksum and sequence counter update/validation, which are external to but required by the CAN interface engine are implemented here.</p>
<p>Please note: Handle mapping is always required by the CAN interface, (it’ll be a trivial identity in many environments like in our Arduino integration) but checksum and sequence counter update/validation are a matter of application specific configuration only.</p>
<p>The integration code contains the handling of bus errors, too. Although it strongly resembles the auto-generated code for frame handling (see below) and although it could be auto-generated, too, we decided for hand-coding. The reason simply is that the number of CAN buses is very low in comparison to the number of frames and that the CAN bus configuration typically doesn’t undergo frequent changes in the course of a software project. Maintaining this code through template programming as it would be required for auto-generated coding, won’t ever pay off.</p>
<h3 data-number="1.2.4" id="folder-codegen"><span class="header-section-number">1.2.4</span> Folder codeGen</h3>
<p>Most important is folder code\codeGen. It contains the configuration of the CAN interface for this application. This configuration is mainly determined by the code generation from the network database file(s). The transmission modes and all program flow for communication validation (timeouts, checksum and sequence counter support) are implemented here, controlled by the attributes in the network databases. Moreover, the global data API with the APSW, which is highly dependent on the network databases is implemented here, too.</p>
<p>All C sources and related header files in this folder are generated by the code generator.</p>
<h3 data-number="1.2.5" id="folder-rtos"><span class="header-section-number">1.2.5</span> Folder RTOS</h3>
<p>Last but not least we have folder RTOS. A popular open source real time operating system for Arduino has been placed here. Nothing special about this, maybe with the exception of file comFramework\canInterface\components\arduinoSampleIntegrationEmbeddedCoder\code\RTOS\rtosConfig\rtos.config.h, which configures the RTOS at compile time (number of tasks, required task communication objects, etc.).</p>
</body>
</html>
