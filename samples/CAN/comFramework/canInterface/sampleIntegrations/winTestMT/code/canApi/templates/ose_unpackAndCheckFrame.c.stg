//
// ose_unpackAndCheckFrame.c.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// The templates in this file will generate an end-to-end protection function for each CAN
// frame. Thes functions generated by this template have kept separate (with respect to
// template group file and generated target file) because the end-to-end protection
// functions are not of any general use but only required for our specific test
// application. The E2E check of a frame is done and only the Boolean test result is
// returned; different to the commonly usable functions generated by the other template
// group file e2e_frameProtection.c.stg, do these function give no access to the unpacked
// data. The reason for not exposing the unpacked data is that the function have a
// frame-independent signature, which permits holding them in a data table and having such
// a table permits building up the test application in a generic way.
//
// Copyright (C) 2017 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "<", ">"

import "lib/iterations.stg"
import "lib/mod.stg"
import "typeMap.stg"
import "symbols.stg"

moduleDescription() ::= <<
 * This module contains the set of functions for the end-to-end validation of the CAN
 * frames. A CRC checking function is generated for each CAN frame.
>>


// This is one of the root templates; the complete C file is rendered.
//
ose_e2eValidation_c(cluster,info) ::= <<
<! First put a file header with the reusable library template modC !>
<modC(["\n", moduleDescription()])>
<! The list of functions is put after the file frame shaped by modC !>
<iteratePdusOfCluster(cluster,"sent","fctsPdu")>
>>


// This is one of the root templates; the complete header file is rendered.
//
ose_e2eValidation_h(cluster,info) ::= <<
<! First put a file header with the reusable library template modC !>
<modH(["\n", moduleDescription()])>
>>


// Configure the templates mod.stg:modC/H, which shape the lists of included files.
@modC.includes() ::= <<
#include \<stdio.h>
#include \<stdlib.h>
#include \<string.h>
#include \<assert.h>

#include "<file.baseTypes_h>"
#include "cap_canApi.h"
#include "e2e_frameProtection.h"

>>


@modC.defines() ::= <<
>>


@modH.includes() ::= <<
#include "<file.baseTypes_h>"
#include "cap_canApi.h"

>>


@modH.defines() ::= <<
>>

@modH.prototypes() ::= <<
<iteratePdusOfCluster(cluster,"sent","fctsPduDecl")>
>>


// Generate the set of required functions for a single frame. Nothing is emitted for
// frames, which do not have a checksum field.
//   Note, the code generation for this does not support multiplexed signal sets!
fctsPdu(pdu) ::= <<
/**
 * Do unpacking and E2E validation of frame <frame>.\n
 *   The frame contents are locally unpacked. All signals of the frame, ending with the CRC
 * checksum, are read from this buffer and serialized into a temporary buffer. The CRC of
 * this buffer is computed and compared to the unpacked check value.
 *   @return
 * The function returns \a true if and only if the expected check value of the CRC is seen.
 * If so, E2E protection approves the correct data contents of the frame.
<if(!pdu.specialSignalMap.checksum)>
 *   @remark
 * Frame <frame> doesn't have a checksum defined. The function will
 * unconditionally unpack the frame into the target location \a *pFrameStruct and then
 * return \a true.
<endif>
 */
<bt("bool_t")> <fct.oseUnpackAndCheckFrame>(const <bt("uint8_t")> frameContent[<frame.size>])
{
<if(pdu.specialSignalMap.checksum)>
    /* Unpack the data locally. */
    <symbol.structFrame_t> frameStructLocal;
    <fct.unpackFrame>(&frameStructLocal, &frameContent[0]);
    
    /* Run the E2E validation on the unpacked frame and return the result. */
    return <fct.e2eCheckFrame>(&frameStructLocal);

<else>
    /* Frame <frame> doesn't have a checksum defined and no E2E validation is possible.
       Just return true. */
    return true;

<endif>
} /* End of <fct.oseUnpackAndCheckFrame> */



>>


// The declaration of the global functions of the module. Needs to be kept in sync with
// template fctsPdu(pdu).
fctsPduDecl(pdu) ::= <<
/** Unpack a frame and run E2E validation. */
extern <bt("bool_t")> <fct.oseUnpackAndCheckFrame>(const <bt("uint8_t")> frameContent[<frame.size>]);

>>
