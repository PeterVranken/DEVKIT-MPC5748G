<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: tsq_threadSafeQueue.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.4</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tsq__thread_safe_queue_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">tsq_threadSafeQueue.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;<a class="el" href="cde__can_dispatcher_engine_8config_8h_source.html">cde_canDispatcherEngine.config.h</a>&quot;</code><br />
</div>
<p><a href="tsq__thread_safe_queue_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a62447df8a42791310057bb6e76daff2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a62447df8a42791310057bb6e76daff2b">TSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a62447df8a42791310057bb6e76daff2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a29e2a04ba304a54ae2acdfd5889ee530"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a29e2a04ba304a54ae2acdfd5889ee530">TSQ_ASSERT</a>(booleanInvariant)&#160;&#160;&#160;<a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a0ee7efaec4622ead6b1dd85fbdf67038">CDE_ASSERT</a>(booleanInvariant)</td></tr>
<tr class="separator:a29e2a04ba304a54ae2acdfd5889ee530"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a909e8343e40af59a9ea3dcf71feae69a"><td class="memItemLeft" align="right" valign="top">typedef struct tsq_queue_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a></td></tr>
<tr class="separator:a909e8343e40af59a9ea3dcf71feae69a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a6c66ccd22aefffb351f15c98ccc186ab"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a6c66ccd22aefffb351f15c98ccc186ab">tsq_getSizeOfQueue</a> (unsigned int maxQueueLength, unsigned int maxElementSize, unsigned int alignOfElement)</td></tr>
<tr class="separator:a6c66ccd22aefffb351f15c98ccc186ab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8206086e0de46f6f03bb781e0380eb1a"><td class="memItemLeft" align="right" valign="top">struct <a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a8206086e0de46f6f03bb781e0380eb1a">tsq_createQueue</a> (void *pMemoryChunk, unsigned int maxQueueLength, unsigned int maxElementSize, unsigned int alignOfElement)</td></tr>
<tr class="separator:a8206086e0de46f6f03bb781e0380eb1a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaab1c273d7e5b5d44c2cbf7e64d3df12"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#aaab1c273d7e5b5d44c2cbf7e64d3df12">tsq_getMaxSizeOfElement</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:aaab1c273d7e5b5d44c2cbf7e64d3df12"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abf4d79d286ce2172f4869d5c0e1fdb79"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#abf4d79d286ce2172f4869d5c0e1fdb79">tsq_writeToTail</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue, const void *pData, unsigned int noBytes)</td></tr>
<tr class="separator:abf4d79d286ce2172f4869d5c0e1fdb79"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae676956ba613317146b668883e226288"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#ae676956ba613317146b668883e226288">tsq_allocTailElement</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:ae676956ba613317146b668883e226288"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a4f1097754f67ac58a90702a359ba83"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a6a4f1097754f67ac58a90702a359ba83">tsq_postTailElement</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:a6a4f1097754f67ac58a90702a359ba83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a037f4061c86f86ca71e643eed3b90727"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a037f4061c86f86ca71e643eed3b90727">tsq_readFromHead</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:a037f4061c86f86ca71e643eed3b90727"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54f8bf607d9dde2c22b28c70af26f83b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a54f8bf607d9dde2c22b28c70af26f83b">tsq_getNoQueuedElements</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:a54f8bf607d9dde2c22b28c70af26f83b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f752af895dc6676dd2b327ac6d2ccaa"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="tsq__thread_safe_queue_8h.html#a5f752af895dc6676dd2b327ac6d2ccaa">tsq_getMaximumQueueUsage</a> (<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *pQueue)</td></tr>
<tr class="separator:a5f752af895dc6676dd2b327ac6d2ccaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Definition of global interface of module <a class="el" href="tsq__thread_safe_queue_8c.html">tsq_threadSafeQueue.c</a></p>
<p>Copyright (C) 2016 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="a62447df8a42791310057bb6e76daff2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TSQ_ENABLE_API_QUEUE_DIAGNOSTICS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A diagnostic API reporting the usage of the queue can be useful for supporting the development of an application (dimensioning the queue sizes) but won't normally be required by the ready application. Therefore the compilation of this API can be configured using this switch. </p>

</div>
</div>
<a class="anchor" id="a29e2a04ba304a54ae2acdfd5889ee530"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TSQ_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">booleanInvariant</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a0ee7efaec4622ead6b1dd85fbdf67038">CDE_ASSERT</a>(booleanInvariant)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Many error conditions, which are static in the sense that they can only appear due to errors in the implementation code are checked by assertions. This relates to the implementation of the queue itself, but to the implementation of the client code, too. The most typical errors will be caught the first time the code is executed. This concept of static error checks makes it inevitable to have an assertion mechanism. Most platforms will offer an assertion. <a class="el" href="tsq__thread_safe_queue_8h.html#a29e2a04ba304a54ae2acdfd5889ee530">TSQ_ASSERT(boolean_t)</a> needs to expand to the assertion on your platform. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a909e8343e40af59a9ea3dcf71feae69a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct tsq_queue_t tsq_queue_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The queue object as an unknown type. The API operates with pointers to such objects. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a6c66ccd22aefffb351f15c98ccc186ab"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tsq_getSizeOfQueue </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignOfElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Prior to queue creation: Query the size of a queue object.</p>
<p>Query the size of a queue object.<br />
 This function is meant to be called prior to creation of a queue object. The caller of the constructor is in charge of allocating the memory for the object - the intended use case of the queue implementation is the embedded environment, which doesn't permit to allocate memory dynamically using <em>malloc</em>.<br />
 This function needs to be called with the same parameters as later the constructor. The constructor will silently assume that the memory chunk it receives from the caller will have the size computed by this method. The typical use case avoids the use of <em>malloc:</em> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct qElement_t;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define MAX_Q_LEN 10</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;const unsigned int sizeOfQ = tsq_getSizeOfQueue( MAX_Q_LEN</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                                               , sizeof(struct qElement_t)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                                               , _Alignof(struct qElement_t)</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;                                               );</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;// In this example be _Alignof(struct qElement_t) &lt;= _Alignof(unsigned int)</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;TSQ_ASSERT(_Alignof(struct qElement_t) &lt;= _Alignof(unsigned int));</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;_Alignas(unsigned int) char memoryChunk[sizeOfQ];</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;tsq_queue_t myNewQ = tsq_createQueue( memoryChunk</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                                    , MAX_Q_LEN</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                    , sizeof(struct qElement_t)</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;                                    , _Alignof(struct qElement_t)</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;                                    );</div>
</div><!-- fragment --><p> Alternatively, the embedded environment may offer a simple, uncritical memory allocation or partitioning API, most likely without a free function to avoid fragmentation and indeterministic timing behavior. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes required to construct a queue object with the passed parameters. Only this number is computed, nothing else happens, in particular no queue object is constructed. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. Any attempt to queue more than this number of elements (and without reading any meanwhile) will return an error at run-time. </td></tr>
    <tr><td class="paramname">maxElementSize</td><td>The maximum size of each element to be stored in the queue. In most situations the queue will hold elements of same size, then this size is meant. However, the write API permits to write a variable number of bytes into the queue, too. If variably sized elements are used then the maximum size needs to be specified here.<br />
 Note, variable size handling doesn't target saving of memory but saving of data copying effort. The constructor will allocate the maximum element size for all possible queue elements. </td></tr>
    <tr><td class="paramname">alignOfElement</td><td>The function operates without type information but needs to form an array of the elements. To safely do so it needs to anticipate the alignment required for such an element.<br />
 Usually this is the alignment of the element if it has a primitive type or the alignment of the largest field of the element if it is a struct.<br />
 If the caller's code is compiled as C11 then the best way to do is passing _Alignof(&lt;elementType&gt;).<br />
 <em>alignOfElement</em> is expected to be a power of two. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The memory chunk required by the constructor does not only need to have the right minimum size but, secondary, it needs to have the right alignment, which is the greater one of the alignment of an unsigned int and <em>alignOfElement</em>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="tsq__thread_safe_queue_8c.html#a8206086e0de46f6f03bb781e0380eb1a">tsq_createQueue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8206086e0de46f6f03bb781e0380eb1a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">struct <a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a>* tsq_createQueue </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemoryChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxElementSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>alignOfElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new queue object.</p>
<p>Create a new queue object. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the ready-to-use queue object. Effectively, this is the same pointer as <em>pMemoryChunk</em> but type casted for use as queue. If the caller uses dynamic memory management then he may free either his memory chunk or the returned pointer after use of the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemoryChunk</td><td>The caller is in charge of allocating memory for the new queue object. A memory chunk of required size or bigger is passed in by reference. The required size needs to queried with the other method <a class="el" href="tsq__thread_safe_queue_8c.html#a6c66ccd22aefffb351f15c98ccc186ab">tsq_getSizeOfQueue()</a> prior to the call of this constructor.<br />
 Besides the right size, the memory chunk needs to have the right alignment, which is the greater one of the alignment of an unsigned int and <em>alignOfElement</em>. If you use <em>malloc</em> to allocate the memory chunk than this should always be granted. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. Any attempt to queue more than this number of elements (and without reading any meanwhile) will return an error at run-time. </td></tr>
    <tr><td class="paramname">maxElementSize</td><td>The maximum size of each element to be stored in the queue. In most situations the queue will hold elements of same size, then this size is meant. However, the write API permits to write a variable number of bytes into the queue, too. If variably sized elements are used then the maximum size needs to be specified here.<br />
 Note, variable size handling doesn't target saving of memory but saving of data copying effort. The constructor will allocate the maximum element size for all possible queue elements. </td></tr>
    <tr><td class="paramname">alignOfElement</td><td>The function operates without type information but needs to form an array of the elements. To safely do so it needs to anticipate the alignment required for such an element.<br />
 Usually this is the alignment of the element if it has a primitive type or the alignment of the largest field of the element if it is a struct.<br />
 If the caller's code is compiled as C11 then the best way to do is passing _Alignof(&lt;elementType&gt;). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>There's no destructor for a queue object. The caller is responsible for providing the memory for the object and freeing this memory &ndash; if applicable &ndash; would be the only operation to delete a queue object after use. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="tsq__thread_safe_queue_8c.html#a6c66ccd22aefffb351f15c98ccc186ab">tsq_getSizeOfQueue()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aaab1c273d7e5b5d44c2cbf7e64d3df12"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tsq_getMaxSizeOfElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Query the maximum permitted size of a queueable element.</p>
<p>Query the maximum permitted size of a queueable element.<br />
 Please note, the returned value can differ from the element size, which had been demanded as parameter <em>maxElementSize</em> in the call of <a class="el" href="tsq__thread_safe_queue_8c.html#a8206086e0de46f6f03bb781e0380eb1a">tsq_createQueue()</a>. Due to alignment constraints the value returned by this method can be greater or equal to the value stated at queue creation time. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of bytes, which can be queued at once using either <a class="el" href="tsq__thread_safe_queue_8c.html#abf4d79d286ce2172f4869d5c0e1fdb79">tsq_writeToTail()</a> or which can be written to the memory chunk returned by <a class="el" href="tsq__thread_safe_queue_8c.html#ae676956ba613317146b668883e226288">tsq_allocTailElement()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The query relates to any object processed by this queue. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="abf4d79d286ce2172f4869d5c0e1fdb79"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool tsq_writeToTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a new element to the tail of the queue.</p>
<p>Append a new element to the tail of the queue. </p><dl class="section return"><dt>Returns</dt><dd>The operation can fail; the queue is implemented with a pre-determined maximum size and it can be currently full. Get <em>true</em> if the operation succeeds and <em>false</em> in case of a currently full queue. The elements themselves have a fixed maximum size. If the caller tries to write more bytes than this maximum the function will also return <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object to write to by reference. </td></tr>
    <tr><td class="paramname">pData</td><td>The pointer to the payload data of the appended element. This is an anonymous byte sequence to this method. memcpy is used to copy the data into the queue, which imposes no alignment requirements on the data. </td></tr>
    <tr><td class="paramname">noBytes</td><td>The number of bytes to write. If variable data sizes don't matter then you will pass the same value as specified as <em>maxElementSize</em> at queue creation time.<br />
 Note, the queue implementation doesn't record how many bytes are written into the appended elements. Most applications will anyway use a fixed size. If an application makes use of variable element sizes it should define the element such that the size information is part of this element.<br />
 Note, it's impossible to save memory by variable element sizes. The memory allocation at queue creation time will always assume the maximum size for each element.<br />
 If the number of bytes to write exceeds the fixed maximum size than the operation is rejected. No data will be copied to the queue. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void *tsq_allocTailElement(<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *) </dd>
<dd>
void *tsq_readFromHead(<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *) </dd></dl>

</div>
</div>
<a class="anchor" id="ae676956ba613317146b668883e226288"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tsq_allocTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the queue has currently room to append another element to the tail and return the available element in case.</p>
<p>Check if the queue has currently room to append another element to the tail and return the available element in case.<br />
 This method, together with the other method <a class="el" href="tsq__thread_safe_queue_8c.html#a6a4f1097754f67ac58a90702a359ba83">tsq_postTailElement()</a>, is an alternative API to write to the end of the queue. If <a class="el" href="tsq__thread_safe_queue_8c.html#ae676956ba613317146b668883e226288">tsq_allocTailElement()</a> returns a non NULL pointer then the caller can take any time to fill the queue element the return value points to without fearing any race conditions. After having the element filled he will use <em>tsq_postTailElement</em> to submit the element. From now on the element will be visible to the consumer at the end of the queue.<br />
 Using this API in contrast to <a class="el" href="tsq__thread_safe_queue_8c.html#abf4d79d286ce2172f4869d5c0e1fdb79">tsq_writeToTail()</a> can save a local copy of the produced data in the producers implementation.<br />
 The producer APIs to access the tail of the queue are not race condition free. A call of <em>tsq_writeToTail</em> must either<br />
</p><ul>
<li>return before the next call of the same method or<br />
</li>
<li>return before the invocation of <em>tsq_allocTailElement</em> or<br />
</li>
<li>be initiated after return from <em>tsq_postTailElement</em>.</li>
</ul>
<p>This means for a single producer context, that it can alternatingly use <em>tsq_writeToTail</em> and the pair of <em>tsq_allocTailElement</em> and <em>tsq_postTailElement</em>. For concurrent producer contexts it imposes the need for the implementation of mutual exclusion code at the caller's side. </p><dl class="section return"><dt>Returns</dt><dd>Get either the next available ring buffer element by reference or NULL if the queue is currently full.<br />
 The returned pointer is aligned as had been specified through <em>alignOfElement</em> at queue creation time. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer. There is no time limit in keeping the pointer (i.e. until data submission with <em>tsq_postTailElement</em>) and using the pointer can avoid the need for an additional local copy of the data during data production time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The calls of <em>tsq_allocTailElement</em> and <em>tsq_postTailElement</em> need to be done strictly alternatingly. It is not possible to reserve several elements by multiple calls of the former method and to submit them later by the same number of calls of the latter method. </dd>
<dd>
It is possible to use this method prior to <em>tsq_writeToTail</em> to query if the queue is currently full and to avoid a negative return value of that function. It's however disencouraged to do so. There is a little useless computation overhead in doing so and, more important, the pair of <em>tsq_allocTailElement</em> and <em>tsq_writeToTail</em> is not race condition free; a queue element could become free between the two calls &ndash; the strategy would be too conservative. </dd></dl>

</div>
</div>
<a class="anchor" id="a6a4f1097754f67ac58a90702a359ba83"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void tsq_postTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submit a queue element, which had been allocated with <em>tsq_allocTailElement</em>.</p>
<p>Submit a queue element, which had been allocated with <a class="el" href="tsq__thread_safe_queue_8c.html#ae676956ba613317146b668883e226288">tsq_allocTailElement()</a>.<br />
 From now on, the element is in the queue and visible to the consumer. The pointer, which had been got from <em>tsq_allocTailElement</em> is invalid and must no longer be used.<br />
 Please, find more details of using this API in the decription of the counterpart method <em>tsq_allocTailElement</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object, where the submitted element had been allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void *tsq_allocTailElement(<a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *) </dd></dl>

</div>
</div>
<a class="anchor" id="a037f4061c86f86ca71e643eed3b90727"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* tsq_readFromHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a meanwhile receivced new element from the head of the queue.</p>
<p>Read a meanwhile receivced new element from the head of the queue.<br />
 </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the newly received element if a new element has arrived. <em>NULL</em> is returned if no new element has been received since the previous invocation of this method.<br />
 The element, which is returned by reference is from now on owned by the data consumer, i.e. the caller of this method. It may use the pointer to read the data. The ownership only ends by getting another pointer to another element with a future invocation of this method. In particular, it does not end when a future call of this method returns <em>NULL</em>. The access of the owned element is race condition free for the owner of the pointer.<br />
 The returned pointer is aligned as had been specified through <em>alignOfElement</em> at queue creation time. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer without the need for first copying the data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object to be read from by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The consumer API is not reentrant. It is not possible to let concurrent consumer contexts read from the head of the queue. This holds even if the consumer code implements synchronization code, which ensures mutual exclusion from this method. This is because the method's effect persists after return from the method; the returned element is reserved to the caller until the next method invocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="tsq__thread_safe_queue_8c.html#abf4d79d286ce2172f4869d5c0e1fdb79">tsq_writeToTail(tsq_queue_t *, const void *, unsigned int)</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a54f8bf607d9dde2c22b28c70af26f83b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tsq_getNoQueuedElements </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of currently queued elements.</p>
<p>Get the number of currently queued elements.<br />
 The use of this method is not race condition free, producer and consumer can concurrently change the true value. The method should solely be used to get a picture of the use profile of the queue. No essential decision must be based on the result (like rising a warning at high watermark). The most meaningful result is gained if the method is called from the producer context and immediately after appending an element to the queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of currently queued elements. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object by reference. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In far the most environments the type <a class="el" href="tsq__thread_safe_queue_8c.html#a7307b1337a9fa850ee6af25c93c7b17f">atomicUnsignedInt_t</a> is an unsigned int. On exceptional platforms, where the atomic integer type is shorter than unsigned int the method must not be called from a context other than the producer's. The result would be undefined and an assertion can even fire. </dd>
<dd>
The compilation of this API can be turned on/off by configuration switch <a class="el" href="tsq__thread_safe_queue_8h.html#a62447df8a42791310057bb6e76daff2b">TSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd></dl>

</div>
</div>
<a class="anchor" id="a5f752af895dc6676dd2b327ac6d2ccaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int tsq_getMaximumQueueUsage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="tsq__thread_safe_queue_8h.html#a909e8343e40af59a9ea3dcf71feae69a">tsq_queue_t</a> *&#160;</td>
          <td class="paramname"><em>pQueue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum number of queued elements, which has ever been seen.</p>
<p>Get the maximum number of queued elements, which has been seen since creation of the queue object. </p><dl class="section return"><dt>Returns</dt><dd>Get the number. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueue</td><td>The queue object by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>In far the most environments the type <a class="el" href="tsq__thread_safe_queue_8c.html#a7307b1337a9fa850ee6af25c93c7b17f">atomicUnsignedInt_t</a> is an unsigned int. On exceptional platforms, where the atomic integer type is shorter than unsigned int the method must not be called from a context other than the producer's. The result would be undefined and even an assertion can fire. </dd>
<dd>
The compilation of this API can be turned on/off by configuration switch <a class="el" href="tsq__thread_safe_queue_8h.html#a62447df8a42791310057bb6e76daff2b">TSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="tsq__thread_safe_queue_8h.html">tsq_threadSafeQueue.h</a></li>
    <li class="footer">Generated on Wed Sep 12 2018 23:00:09 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
