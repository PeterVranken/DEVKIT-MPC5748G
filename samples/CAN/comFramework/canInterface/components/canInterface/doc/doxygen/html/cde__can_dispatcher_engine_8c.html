<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: cde_canDispatcherEngine.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.4</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('cde__can_dispatcher_engine_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">cde_canDispatcherEngine.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &quot;<a class="el" href="mem__malloc_8h_source.html">mem_malloc.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="tsq__thread_safe_queue_8h_source.html">tsq_threadSafeQueue.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="cde__can_dispatcher_engine_8h_source.html">cde_canDispatcherEngine.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae08f7606e166bbb77d0d10596eeb94f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ae08f7606e166bbb77d0d10596eeb94f5">TIMER_STATE_SINGLE_SHOT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ae08f7606e166bbb77d0d10596eeb94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb29b921ea84e61ea662a74390d667"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a63cb29b921ea84e61ea662a74390d667">TIMER_STATE_SINGLE_SHOT_AUTO_KILL</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:a63cb29b921ea84e61ea662a74390d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e094a1460f371bf6407f91afe9919b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a66e094a1460f371bf6407f91afe9919b">TIMER_STATE_SINGLE_SHOT_SUSPENDED</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="separator:a66e094a1460f371bf6407f91afe9919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04c6c784c9e2233898108b0c6ebfd59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad04c6c784c9e2233898108b0c6ebfd59">TIMER_STATE_KILLED</a>&#160;&#160;&#160;(-3)</td></tr>
<tr class="separator:ad04c6c784c9e2233898108b0c6ebfd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8577a626be854d86ce24db3919fa955a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a8577a626be854d86ce24db3919fa955a">pEvTimer</a>&#160;&#160;&#160;((<a class="el" href="cde__can_dispatcher_engine_8c.html#a0ef7bd37f26407c9b1ddefac14a4aace">event_t</a>*)&amp;memChunk)</td></tr>
<tr class="separator:a8577a626be854d86ce24db3919fa955a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ae5bde519079f247424915010bedc4c43"><td class="memItemLeft" align="right" valign="top">typedef struct objRef_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ae5bde519079f247424915010bedc4c43">objRef_t</a></td></tr>
<tr class="separator:ae5bde519079f247424915010bedc4c43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3563ea68c7dff56d5a82320a840107d"><td class="memItemLeft" align="right" valign="top">typedef struct bus_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad3563ea68c7dff56d5a82320a840107d">bus_t</a></td></tr>
<tr class="separator:ad3563ea68c7dff56d5a82320a840107d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a3142ab52b37789acf86454798bee92"><td class="memItemLeft" align="right" valign="top">typedef struct frame_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a3a3142ab52b37789acf86454798bee92">frame_t</a></td></tr>
<tr class="separator:a3a3142ab52b37789acf86454798bee92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e591e95d8f7af87ddca6f0db4ca2400"><td class="memItemLeft" align="right" valign="top">typedef struct cde_timer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a2e591e95d8f7af87ddca6f0db4ca2400">timer_t</a></td></tr>
<tr class="separator:a2e591e95d8f7af87ddca6f0db4ca2400"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af77ed3d3bb4d4e227ce395a721911d5e"><td class="memItemLeft" align="right" valign="top">typedef struct dispatcher_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#af77ed3d3bb4d4e227ce395a721911d5e">dispatcher_t</a></td></tr>
<tr class="separator:af77ed3d3bb4d4e227ce395a721911d5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef7bd37f26407c9b1ddefac14a4aace"><td class="memItemLeft" align="right" valign="top">typedef struct event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a0ef7bd37f26407c9b1ddefac14a4aace">event_t</a></td></tr>
<tr class="separator:a0ef7bd37f26407c9b1ddefac14a4aace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acb6c16a6f64e0a9f2ddffbaf901c181f"><td class="memItemLeft" align="right" valign="top">boolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#acb6c16a6f64e0a9f2ddffbaf901c181f">cde_initModule</a> (unsigned int noBuses, unsigned int maxNoFrames, unsigned int noDispatchers)</td></tr>
<tr class="separator:acb6c16a6f64e0a9f2ddffbaf901c181f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac8f085db228b1a9796ac1adb8302fa5e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ac8f085db228b1a9796ac1adb8302fa5e">cde_installMapOsHandleFrameToCdeIndex</a> (<a class="el" href="structcde__map_os_handle_frame_to_cde_index__t.html">cde_mapOsHandleFrameToCdeIndex_t</a> mapOsHandleFrameToCdeIndex)</td></tr>
<tr class="separator:ac8f085db228b1a9796ac1adb8302fa5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa99cde64bdcea6cf539f8b9538ede14b"><td class="memItemLeft" align="right" valign="top">boolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher</a> (unsigned int idxDispatcher, unsigned int maxQueueLength, unsigned int maxSizeOfDataElement, signed int tiTick)</td></tr>
<tr class="separator:aa99cde64bdcea6cf539f8b9538ede14b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5e2173ce8a1a3abc1209a66bae3e5e1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad5e2173ce8a1a3abc1209a66bae3e5e1">cde_registerBus</a> (unsigned int idxBus, unsigned int idxDispatcher, <a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> callback)</td></tr>
<tr class="separator:ad5e2173ce8a1a3abc1209a66bae3e5e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae899a59eb3b3d1850e97185b9c8510a7"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ae899a59eb3b3d1850e97185b9c8510a7">cde_registerFrame</a> (unsigned long canId, boolean_t isInbound, unsigned int idxBus, <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a> osHandleFrame, unsigned int idxDispatcher, <a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> callback)</td></tr>
<tr class="separator:ae899a59eb3b3d1850e97185b9c8510a7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae7df616ae04f1b58bb85ac13fc3378e1"><td class="memItemLeft" align="right" valign="top">boolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ae7df616ae04f1b58bb85ac13fc3378e1">cde_postBusEvent</a> (unsigned int idxBus, unsigned int kind, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:ae7df616ae04f1b58bb85ac13fc3378e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a50fb3a31b152444c3447ce0f131442"><td class="memItemLeft" align="right" valign="top">boolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a9a50fb3a31b152444c3447ce0f131442">cde_postFrameEvent</a> (unsigned int idxBus, <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a> osHandleFrame, unsigned int kind, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:a9a50fb3a31b152444c3447ce0f131442"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad3fcd8b689b65ae1333467c4ce2c4a37"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a44a7063040bcdd2c681b211bfe747dbd">cde_atomicUnsignedInt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad3fcd8b689b65ae1333467c4ce2c4a37">cde_getNoDispatcherQueueFullEvents</a> (unsigned int idxDispatcher, boolean_t reset)</td></tr>
<tr class="separator:ad3fcd8b689b65ae1333467c4ce2c4a37"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae9b8352ac0a7fee2ff2f56fdc7c93ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ae9b8352ac0a7fee2ff2f56fdc7c93ec5">cde_dispatcherMain</a> (unsigned int idxDispatcher)</td></tr>
<tr class="separator:ae9b8352ac0a7fee2ff2f56fdc7c93ec5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac6d4bf4ab065666f550650b8d6da80df"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a44a7063040bcdd2c681b211bfe747dbd">cde_atomicUnsignedInt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ac6d4bf4ab065666f550650b8d6da80df">cde_getNoQueueFullEvents</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, boolean_t reset)</td></tr>
<tr class="separator:ac6d4bf4ab065666f550650b8d6da80df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a38186542aa435f82407b1ba4e482b3"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a4a38186542aa435f82407b1ba4e482b3">cde_createPeriodicTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, signed int tiPeriod, <a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> callback, void *pUserContextData)</td></tr>
<tr class="separator:a4a38186542aa435f82407b1ba4e482b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24766b834705025156306c89189c0950"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, signed int tiFromNow, <a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> callback, void *pUserContextData, boolean_t killAtDueTime)</td></tr>
<tr class="separator:a24766b834705025156306c89189c0950"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9a069de593fb4d098988218e8e979bd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ab9a069de593fb4d098988218e8e979bd">cde_killTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, <a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> hTimer)</td></tr>
<tr class="separator:ab9a069de593fb4d098988218e8e979bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad011ccfe36717430b2fd24c65e70cc35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad011ccfe36717430b2fd24c65e70cc35">cde_suspendSingleShotTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, <a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> hTimer)</td></tr>
<tr class="separator:ad011ccfe36717430b2fd24c65e70cc35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a10490cf6b83da1ef9d40c5fb8404b62f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a10490cf6b83da1ef9d40c5fb8404b62f">cde_retriggerSingleShotTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, <a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> hTimer, signed int tiNewFromNow)</td></tr>
<tr class="separator:a10490cf6b83da1ef9d40c5fb8404b62f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ed0e33149a08c944f5b96cfbf7d160f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a0ed0e33149a08c944f5b96cfbf7d160f">cde_installCallback</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, <a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> newCallback)</td></tr>
<tr class="separator:a0ed0e33149a08c944f5b96cfbf7d160f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d2897423886fa64a631de16e2fe5813"><td class="memItemLeft" align="right" valign="top">unsigned long&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a8d2897423886fa64a631de16e2fe5813">cde_getCanId</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:a8d2897423886fa64a631de16e2fe5813"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0f36f93324ea09fb8284913e963d57d9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a0f36f93324ea09fb8284913e963d57d9">cde_getIdxFrame</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:a0f36f93324ea09fb8284913e963d57d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a930b265bccf412974afeb8fef955a5f0"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a930b265bccf412974afeb8fef955a5f0">cde_getIdxBus</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:a930b265bccf412974afeb8fef955a5f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a977d3cf3bbcc5558786732b15aec9a71"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a977d3cf3bbcc5558786732b15aec9a71">cde_getOsHandleFrame</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:a977d3cf3bbcc5558786732b15aec9a71"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac2292cf5c806c325a65062cf6f344f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#aac2292cf5c806c325a65062cf6f344f4">cde_getHandleTimer</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:aac2292cf5c806c325a65062cf6f344f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0f6d44f6c3395161206ea4c3ffbe4ac"><td class="memItemLeft" align="right" valign="top">boolean_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#ad0f6d44f6c3395161206ea4c3ffbe4ac">cde_isInboundTransmission</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:ad0f6d44f6c3395161206ea4c3ffbe4ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47e7083e2226c3f7da761ae85f82289d"><td class="memItemLeft" align="right" valign="top"><a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#a47e7083e2226c3f7da761ae85f82289d">cde_getKindOfEvent</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext)</td></tr>
<tr class="separator:a47e7083e2226c3f7da761ae85f82289d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa395ff7d9b660e5b358177808a35e4d9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="cde__can_dispatcher_engine_8c.html#aa395ff7d9b660e5b358177808a35e4d9">cde_getEventData</a> (const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *pContext, unsigned int *pSizeOfEvContentByteAry, const void **pEvContentByteAry)</td></tr>
<tr class="separator:aa395ff7d9b660e5b358177808a35e4d9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The dispatcher engine for CAN frames. This engine serves the CAN API implemented by the package.<br />
 The input of the engine is connected to the native API of the underlying system. Specific target platform integration is required. Normally, there will be an interrupt or interrupt triggered callback, which notifies CAN related events. Frame reception in the first place, but there may be more events like send acknowledge or error events.<br />
 The output of the engine is connected to the CAN API. For example if a CAN reception event is received than the received frame contents can be decoded and written into that API. This process is called dispatching because the API usually has a parallel design, with a distinct, dedicated connection point (by global data or functional) for each frame ID.<br />
 Both ends of the engine can be used from different CPU contexts, a thread-safe queue safely decouples both ends.</p>
<p>Copyright (C) 2015-2017 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae08f7606e166bbb77d0d10596eeb94f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63cb29b921ea84e61ea662a74390d667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT_AUTO_KILL&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66e094a1460f371bf6407f91afe9919b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT_SUSPENDED&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad04c6c784c9e2233898108b0c6ebfd59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_KILLED&#160;&#160;&#160;(-3)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a8577a626be854d86ce24db3919fa955a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define pEvTimer&#160;&#160;&#160;((<a class="el" href="cde__can_dispatcher_engine_8c.html#a0ef7bd37f26407c9b1ddefac14a4aace">event_t</a>*)&amp;memChunk)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="ae5bde519079f247424915010bedc4c43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct objRef_t  objRef_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The reference to a frame, bus or timer object. Used as parent of timers or as source of events. </p>

</div>
</div>
<a class="anchor" id="ad3563ea68c7dff56d5a82320a840107d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct bus_t  bus_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The internal representation of a registered bus. </p>

</div>
</div>
<a class="anchor" id="a3a3142ab52b37789acf86454798bee92"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct frame_t  frame_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The internal representation of a registered frame. </p>

</div>
</div>
<a class="anchor" id="a2e591e95d8f7af87ddca6f0db4ca2400"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct cde_timer_t  <a class="el" href="cde__can_dispatcher_engine_8c.html#a2e591e95d8f7af87ddca6f0db4ca2400">timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A timer object. </p><dl class="section remark"><dt>Remarks</dt><dd>The type designation "struct cde_timer_t" of this class is publically visible although the class as such is local to this module. </dd></dl>

</div>
</div>
<a class="anchor" id="af77ed3d3bb4d4e227ce395a721911d5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct dispatcher_t dispatcher_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a0ef7bd37f26407c9b1ddefac14a4aace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct event_t  event_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An event for the client code, i.e. the callback into the client code. For external events this is an element of the dispatcher's queue at the same time. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="acb6c16a6f64e0a9f2ddffbaf901c181f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean_t cde_initModule </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noBuses</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoFrames</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noDispatchers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initialize the module at application startup. The internal data structures are set up.<br />
 This function must be called once and only once. Re-initialization is forbidden due to the static, deterministic memory allocation concept. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>.<br />
 The function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. Anyhow, the system is not operational if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">noBuses</td><td>The number of buses, which will be registered. In many integrations of the CAN interface this will be zero: Buses need to be registered only if bus related events have to be processed (e.g. bus off errors).<br />
 Please note the difference to frames: For frames a maximum number is specified and any actual number up to this maximum can be registered. For buses the actual number is specified here and all of these buses need to be registered subsequently using <a class="el" href="cde__can_dispatcher_engine_8c.html#ad5e2173ce8a1a3abc1209a66bae3e5e1">cde_registerBus()</a>. </td></tr>
    <tr><td class="paramname">maxNoFrames</td><td>The maximum number of frames, which can be registered. The number of frames to be registered is deterministic but depends on the network database files. The recommendation is to pass a value, which is taken from the auto coded parts of the interface code. </td></tr>
    <tr><td class="paramname">noDispatchers</td><td>The intended number of dispatchers; minimum is one. How many dispatchers are used depends on the concept of the APSW. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Using this function is not an option but a must. You need to call it prior to any other call of this module and prior to accessing any of its global data objects. </dd>
<dd>
The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platform will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a class="anchor" id="ac8f085db228b1a9796ac1adb8302fa5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_installMapOsHandleFrameToCdeIndex </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structcde__map_os_handle_frame_to_cde_index__t.html">cde_mapOsHandleFrameToCdeIndex_t</a>&#160;</td>
          <td class="paramname"><em>mapOsHandleFrameToCdeIndex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Set the reference to the required external, integrator provided map, which associates the operating system's bus index and frame handle with the CAN interface engine's frame index. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">mapOsHandleFrameToCdeIndex</td><td>The reference to the external map. Both entries of the struct may be NULL if no mapping is required. See type defintion <a class="el" href="structcde__map_os_handle_frame_to_cde_index__t.html">cde_mapOsHandleFrameToCdeIndex_t</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa99cde64bdcea6cf539f8b9538ede14b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean_t cde_createDispatcher </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxSizeOfDataElement</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiTick</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a dispatcher.<br />
 The dispatcher delivers events to the client code, which is completely organized as set of callbacks, which implement the reaction on the events. The root of all is the initialization call, which is made for each registered bus or frame.<br />
 Events can be external events (their meaning is fully determined by the integration code) or internal timer events.<br />
 A dispatcher is single-threaded. There are no race conditions between callbacks, which makes the design of the event handling code easy and safe. If CAN events (reception mostly) are logically connected to several application tasks (e.g. fast frames are handled in a fast task, low frequent frames in a slower task) then one would create two dispatchers; one delegates the fast frames race condition free to one task and the other one the remainig frames also race condition free to the slower task.<br />
 The decoupling of the platform dependent CAN interface (typically interrupt driven) and the APSW (run in some regular periodic task context) is done with dispatcher queues, which have a threadsafe implementation. There is a one by one relation between dispatcher objects and their queues.<br />
 The OS' CAN interrupts can pass arbitrary information through these queues to the client code in the APSW. This can be CAN message contents and/or transmission status information. Therefore the size of the data elements in the queue is configurable. Each frame is associated with one particular dispatcher. The association is made during frame registration.<br />
 A typical use case would be a system with two queues. One has elements of 8 Byte and is associated with all inbound frames - it conveys the received CAN information - and the other one is associated with all outbound frames and has data elements of size 0. A contentless event signaled through this queue would just mean an acknowledge of having the frame sent.<br />
 However, if the platform would provide status information together with the CAN content bytes then the queue for inbound frames could decide to have e.g. 9 Byte elements: 8 content bytes plus a status byte. All memory allocation in the CAN interface is static and deterministic, which means for the queues that they allocate the maximum element size times the number of elements regardless of the later actual use of the queue.<br />
 In general, the data elements are opaque to the dispatcher engine. Filling the contents is done as part of the integration code and evaluating the data elements, too. (The former in the implementation of the OS' CAN interrupt handlers and the latter by appropriate configuration of the auto-coding of the callbacks.) The engine will just ensure proper delivery of the data element in the right frame or bus context. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>.<br />
 The function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. If the assertion doesn't fire throughout the development and test phase then it won't in the production code. Anyhow, the dispatcher must never be used if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxDispatcher</td><td>The dispatcher object is identified by a linear, zero based index. The integration code determines the number of dispatchers, thus the index range and it knows which queue to be applied for which purpose, so it is aware of the meaning of the index. The implementation doesn't make any difference between the dispatcher objects. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The implemented algorithms superimpose a fixed maximum queue length, which has to be specified at creation time. The maximum queue is greater or equal to one.<br />
 The length will be chosen by the integrator as little as possible. The basic consideration will be the worst case ratio of the rate of conveyed events and the frequency, which the engine is ticked with. The selection of the appropriate queue length in the development phase is supported by an overflow detection and reporting mechanism. </td></tr>
    <tr><td class="paramname">maxSizeOfDataElement</td><td>The maximum size of the content data of any later event in Byte. </td></tr>
    <tr><td class="paramname">tiTick</td><td>The processing of the queue needs to be done on a regular time base using function <em>cde_dispatcherMain</em>. The time distance between two calls of the clock function <a class="el" href="cde__can_dispatcher_engine_8c.html#ae9b8352ac0a7fee2ff2f56fdc7c93ec5">cde_dispatcherMain()</a> needs to be known for the timer operations and is passed in as <em>tiTick</em>.<br />
 The value needs to be a positive integer and should not be too large: No timing operation shorter or faster than the value passed in here will become possible. This relates to sending frames and checking timeouts of operations.<br />
 The unit is arbitrary but the chosen unit defines the unit of all other timer operations at the same time. Usually it'll be a Millisecond. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The static, deterministic memory allocation concept inhibits re-creation of a dispatcher. If one and the same dispatcher is created twice then the code fails by assertion and returns <em>false</em>. </dd>
<dd>
The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platforms will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a class="anchor" id="ad5e2173ce8a1a3abc1209a66bae3e5e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_registerBus </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of a bus: A bus is associated with a dispatcher and an event callback. The engine can be bound to some bus related notifications (e.g. bus-off interrupt) and the dispatcher will delegate the event to the callback. The added value of doing so is the change of CPU context. While the notification typically origins from an interrupt can the event handling be safely done in the race condition free application task context.<br />
 Bus registration is - different to frame registration - an option only and in many integrations it won't be applied. However, all buses specified in the module initialization <a class="el" href="cde__can_dispatcher_engine_8c.html#acb6c16a6f64e0a9f2ddffbaf901c181f">cde_initModule()</a> need to be registered using this function. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxBus</td><td>The zero based index of the bus. This index relates to the identification of buses, when later notifing an event at run-time with <a class="el" href="cde__can_dispatcher_engine_8c.html#ae7df616ae04f1b58bb85ac13fc3378e1">cde_postBusEvent()</a>. </td></tr>
    <tr><td class="paramname">idxDispatcher</td><td>The bus related events will be processed by one of the available dispatchers. All dispatchers are functionally identical but the integration code can configure them differently and assign them to different use case, most often to different application task contexts. The appropriate dispatcher for the registered bus is passed in by index. The index is the same as used in call <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>, when the dispatchers were created and configured.<br />
 The dispatcher, which is associated with the bus needs to be configured and initialized prior to this call of the bus registration. Please refer to <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>. </td></tr>
    <tr><td class="paramname">callback</td><td>The bus related callback. This callback is invoked the first time immediately after registration of the bus (and still from within this method), which permits to do further initialization there. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platform will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a class="anchor" id="ae899a59eb3b3d1850e97185b9c8510a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cde_registerFrame </td>
          <td>(</td>
          <td class="paramtype">unsigned long&#160;</td>
          <td class="paramname"><em>canId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t&#160;</td>
          <td class="paramname"><em>isInbound</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a>&#160;</td>
          <td class="paramname"><em>osHandleFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A CAN frame is registered at the engine for processing. The client code will call this function repeatedly in the initialization phase. Frame registration has the following aspects:<br />
 Primarily we need an association between the frame identifier as used by the platform (operating system) when signaling the reception or transmission of a frame and the frame index as used by the dispatcher engine. Most platforms have some kind of handle, which is an argument to the reception or transmission callback. This handle can be a linear, zero based index, a pointer or whatever. Normally this handle is returned from a register function in the operating system or it is known from the (static) configuration of the operating system. The dispatcher engine takes this handle as an anonymous 32 Bit value and maintains a mapping onto its internal frame object. The implementation of the mapping is an external function, which has to be provided by the integrator: The implementation strongly depends on the characteristics of the operating system's handle. It can be a null operation (if the handle is a zero based linear index), a simple lookup table (if the handles span a small range of numbers) or a true hash map (if nothing is known about the operating system handles). This registration function supports the external build-up of the map by invoking a previously agreed external function, see interface <a class="el" href="structcde__map_os_handle_frame_to_cde_index__t.html">cde_mapOsHandleFrameToCdeIndex_t</a> and function <a class="el" href="cde__can_dispatcher_engine_8c.html#ac8f085db228b1a9796ac1adb8302fa5e">cde_installMapOsHandleFrameToCdeIndex()</a> for details.<br />
 Secondary, the appropriate dispatcher for the registered frame is selected. The decision needs to be done prior to the frame registration by some external code, which is provided by the integrator. This code will typically decide based on the period time or permitted latency time of a frame or it'll select a specific dispatcher for specific frames (e.g. grouping those which implement a self-contained protocol like XCP). In simple systems there might be only a single dispatcher (and thus a single event queue) and the decision is trivial. This function is informed about the dispatcher to apply by means of an index.<br />
 The last element of the registration process is the call of the frame's callback. This callback is meant for initialization and will typically be used to do all further initialization. The advantage is that this further initialization can then already been done in the frame context; the receive callback can be installed, which has knowledge about the specific contents of this frame, a timeout counter can be armed with respect to the specific frame timing conditions, interface signal values can be initialized etc. The implementation of the callback is typically auto-coded and based on the information in the network database. </p><dl class="section return"><dt>Returns</dt><dd>Internally, the engine organizes all registered frames in an array. The linear, zero based index into this array is returned in case of success. Getting this index is basically redundant information since the indexes will be returned in strictly incremental order in each invocation of this method. Having the index may be useful if the client code of the interface is structured as hand-written code (the callbacks), which operates on auto-coded data tables. These tables are likely organized in arrays using the identical index space in order to avoid mapping or hashing strategies. Furthermore, the engine's index is not fully opaque as it appears in the mapping from engine to operating system handles when posting a frame related event.<br />
 <a class="el" href="cde__can_dispatcher_engine_8h.html#a0a1371615cb8b495fd3e3a822fe09c1b">CDE_INVALID_FRAME_INDEX</a> is returned in case of failures. Now the client code should assume that later transmission of the frame is not possible. Registering can mainly fail due to the static memory allocation. The preallocated memory can be exhausted. Therefore, the return value should be validated by assertion and the configuration of the heap would be updated if the assertion fires during the software test phase. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">canId</td><td>The frame's CAN ID. </td></tr>
    <tr><td class="paramname">isInbound</td><td>The transmission direction as a Boolean. </td></tr>
    <tr><td class="paramname">idxBus</td><td>The index of the bus the frame is transmitted on. On principle, buses are identified by a linear, zero based index. <em>idxBus</em> needs to be less than the number of buses specified at initialization time in <a class="el" href="cde__can_dispatcher_engine_8c.html#acb6c16a6f64e0a9f2ddffbaf901c181f">cde_initModule()</a>.<br />
 The bus index has relevance for the handle mapping only. The model is that - later at run-time - the CAN notification from the operating system identifies the affected frame by bus index and frame handle. Here, in the registration call, the pair of bus index and frame handle is passed to the agreed mapping setup function but not used beyond this. The value passed in for <em>idxBus</em> wouldn't care if the operating system's frame handle is unambiguous across all buses.<br />
 In particular, the bus index specified here doesn't necessarily need to correlate with a bus registration using cde_registerBus. In many environments there won't be the need for a bus registration at all (which enables dispatching events other than frame related). </td></tr>
    <tr><td class="paramname">osHandleFrame</td><td>The frame's handle as used (and issued) by the operating system. (The registration or configuration of the frame at the system precedes this registration call.) </td></tr>
    <tr><td class="paramname">idxDispatcher</td><td>The frame will be processed by one of the available dispatchers. All dispatchers are functionally identical but the integration code can configure them differently and assign them to different use case, most often to different application task contexts or different event sources. The appropriate dispatcher for the registered frame is passed in by index. The index is the same as used in call <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>, when the dispatchers were created and configured.<br />
 The dispatcher, which is associated with the frame needs to be configured and initialized prior to this call of the frame registration. Please refer to <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>. </td></tr>
    <tr><td class="paramname">callback</td><td>The frame related callback. This callback is invoked the first time immediately after registration of the frame, which permits to do further initialization there; in particular the function will consider to renew the callback registration with a more appropriate, regularly called runtime callback. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function must be preceded by the call of <a class="el" href="cde__can_dispatcher_engine_8c.html#ac8f085db228b1a9796ac1adb8302fa5e">cde_installMapOsHandleFrameToCdeIndex()</a>; this function depends on the external function specified in the former call. </dd>
<dd>
The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platform will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a class="anchor" id="ae7df616ae04f1b58bb85ac13fc3378e1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean_t cde_postBusEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A CAN bus related event is posted. It is put into the associated dispatcher's queue.<br />
 This function is invoked by the integration code. The call is typically used from within a CAN interrupt handler. The posted event normally is a bus state change or a bus error. The kind of postable events depends on the platform and the integration. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. The dispatcher's queue has a maximum length and the function will return false if it is full. In this case, the event is entirely ignored (besides the reporting of the queue-full event). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxBus</td><td>The index of the bus the event is related to. When registering the bus it had been associated with a particular dispatcher and the event will be put into this dispatcher's queue. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of event is passed to the client code, which reads the posted events from the other end of the queue. It is an enumeration, which is meaningless to the dispatcher engine or queue. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which evaluates the queued elements.<br />
 As a recommendation, the values of the enumeration <a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a> can be used as far as applicable. If other values are used then they should have no overlap with the values of <a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a>. Please refer to <a class="el" href="cde__can_dispatcher_engine_8h.html#ac0b1bbdeb32d64c909174ee84e669232">CDE_EV_FIRST_CUSTOM_EVENT</a>, too. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data, which is meaningless to the dispatcher engine. Normally used to convey CAN frame content bytes in case of a reception event, but can be anything else. May be NULL if <em>sizeOfData</em> is zero, too. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes. The elements of the dispatcher queue have a fixed limit for the conveyed data. This limit must not be exceeded; this is checked by assertion and the function will return false and further ignore the event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Posting an event to a particular dispatcher queue is not reentrant. If event sources running in different CPU contexts are posting to one and the same dispatcher then the integration code needs to implement mutual exclusion. All of these event sources need to be serialized with respect to event posting.<br />
 Note, "event posting" does not only relate to this method but includes the other method <em>cde_postFrameEvent</em> if the posted frame event is configured to be processed by the same dispatcher.<br />
 Please see <a class="el" href="cde__can_dispatcher_engine_8c.html#a9a50fb3a31b152444c3447ce0f131442">cde_postFrameEvent()</a> for more details. </dd></dl>

</div>
</div>
<a class="anchor" id="a9a50fb3a31b152444c3447ce0f131442"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean_t cde_postFrameEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxBus</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a>&#160;</td>
          <td class="paramname"><em>osHandleFrame</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kind</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A CAN frame related event is posted. It is put into the associated dispatcher's queue.<br />
 This function is invoked by the integration code. The call is typically used from within a CAN interrupt handler. The posted event normally is a frame reception event or a frame send acknowledge event, but it's also imaginable that a platform has error or status events, which are related to frames. The kind of postable events depends on the platform and the integration. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. The dispatcher's queue has a maximum length and the function will return false if it is full. In this case, the event is entirely ignored (besides the reporting of the queue-full event). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxBus</td><td>The index of the bus the frame is transmitted on. Please refer to the description of parameter <em>osHandleFrame</em>, too. </td></tr>
    <tr><td class="paramname">osHandleFrame</td><td>The frame's handle as used (and issued) by the operating system. The pair of bus index and frame handle is translated into the internally used frame index by means of the mapping table, which has been built up during frame registration and which is implemented as external integration code.<br />
 If no specific mapping has been built up then the default mapping "osHandleFrame
is engine frame index" is applied. </td></tr>
    <tr><td class="paramname">kind</td><td>The kind of event is passed to the client code, which reads the posted events from the other end of the queue. It is an enumeration, which is meaningless to the dispatcher engine or queue. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which evaluates the queued elements.<br />
 As a recommendation, the values of the enumeration <a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a> can be used as far as applicable. If other values are used then they should have no overlap with the values of <a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a>. Please refer to <a class="el" href="cde__can_dispatcher_engine_8h.html#ac0b1bbdeb32d64c909174ee84e669232">CDE_EV_FIRST_CUSTOM_EVENT</a>, too. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data, which is meaningless to the dispatcher engine. Normally used to convey CAN frame content bytes in case of a reception event, but can be anything else. May be NULL if <em>sizeOfData</em> is zero, too. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes. The elements of the dispatcher queue have a fixed limit for the conveyed data. This limit must not be exceeded; this is checked by assertion and the function will return false and further ignore the event. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Posting an event to a particular dispatcher queue is not reentrant. If event sources running in different CPU contexts are posting to one and the same dispatcher then the integration code needs to implement mutual exclusion. All of these event sources need to be serialized with respect to event posting.<br />
 Note, "event posting" does not only relate to this method but includes the other method <a class="el" href="cde__can_dispatcher_engine_8c.html#ae7df616ae04f1b58bb85ac13fc3378e1">cde_postBusEvent()</a> if the posted bus event is configured to be processed by the same dispatcher.<br />
 In practice, concurrent event sources that require mutual exclusion will likely occur if the events are reported by different interrupts; different interrupts have different priorities on most existing systems and interrupts of higher priority are normally allowed to preempt those of lower priority. In this situation, a reasonable alternative to explicit mutual exclusion code is an architecture using another dispatcher for each interrupt and running all the dispatcher's main functions one after another in the event receiving APSW task. </dd></dl>

</div>
</div>
<a class="anchor" id="ad3fcd8b689b65ae1333467c4ce2c4a37"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a44a7063040bcdd2c681b211bfe747dbd">cde_atomicUnsignedInt_t</a> cde_getNoDispatcherQueueFullEvents </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of recorded queue full events, i.e. the number of lost events due to an overfull queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the number, which should normally be zero in case of a well designed queue size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxDispatcher</td><td>The index of the dispatcher, whose queue is meant. </td></tr>
    <tr><td class="paramname">reset</td><td>If <em>true</em> then the event counter is reset to zero at the next occasion. Due to the fact that the reset command is handled by the event producing task or interrupt no statement can be made when the reset will actually appear. Due to race conditions it may even slightly increment until the reset command is executed. In particular, the client code must not assume that it can accurately compute the total number of queue full events by regularly calling this method with parameter <em>reset</em> set to <em>true</em> and summing up the function result values.<br />
 If <em>reset</em> is not used and if the event counter reaches its limit then it'll be held at this limit.<br />
 In C11 compilation all delays and race conditions disappear and the function return value is the real, accumulatable number of events since the previous call of this method or <a class="el" href="cde__can_dispatcher_engine_8c.html#ac6d4bf4ab065666f550650b8d6da80df">cde_getNoQueueFullEvents()</a> with <em>reset</em> == <em>true</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is designed for call from any application context. It might be the task, which clocks the referenced dispatcher or another task. The function may be called from a callback in the dispatcher's context, too, but a dedicated function with same functionality is provided for this particular purpose, please refer to <em>cde_getNoQueueFullEvents</em>. </dd>
<dd>
The intended use case of this method is to have a diagnostic API, which gives some feedback about the appropriateness of the chosen queue length. Unless the code is compiled in C11 mode and due to race conditions between event source and APSW is the result not fully consistent (see above) and must not be used for essential program flow decisions. </dd></dl>

</div>
</div>
<a class="anchor" id="ae9b8352ac0a7fee2ff2f56fdc7c93ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_dispatcherMain </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The regular tick function of a dispatcher. This function is invoked from the (periodic) APSW task, which processes the dispatched events. Normally the task, which receives and sends the CAN frames, which are associated with the given dispatcher.<br />
 All notifications and timer operations and thus all can frame related actions are done in the context of this function call (actually as sub-routines of this invokation) and they are therefore completely race conidtion free with the rest of the same APSW task code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxDispatcher</td><td>The index of the dispatcher, which is clocked. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac6d4bf4ab065666f550650b8d6da80df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a44a7063040bcdd2c681b211bfe747dbd">cde_atomicUnsignedInt_t</a> cde_getNoQueueFullEvents </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t&#160;</td>
          <td class="paramname"><em>reset</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the number of recorded queue full events, i.e. the number of lost events due to an overfull queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the number, which should normally be zero in case of a well designed queue size. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">reset</td><td>If <em>true</em> then the event counter is reset to zero at the next occasion. Due to the fact that the reset command is handled by the event producing task or interrupt no statement can be made when the reset will actually appear. Due to race conditions it may even slightly increment until the reset command is executed. In particular, the client code must not assume that it can accurately compute the total number of queue full events by regularly calling this method with parameter <em>reset</em> set to <em>true</em> and summing up the function result values.<br />
 If <em>reset</em> is not used and if the event counter reaches its limit then it'll be held at this limit.<br />
 In C11 compilation all delays and race conditions disappear and the function return value is the real, accumulatable number of events since the previous call of this method or <a class="el" href="cde__can_dispatcher_engine_8c.html#ad3fcd8b689b65ae1333467c4ce2c4a37">cde_getNoDispatcherQueueFullEvents()</a> with <em>reset</em> == <em>true</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is designed for call from a callback. The addressed dispatcher is retrieved from the callback's context. There's the other function <em>cde_getNoDispatcherQueueFullEvents</em>, which provides the same functionality for the normal application context. </dd>
<dd>
The intended use case of this method is to have a diagnostic API, which gives some feedback about the appropriateness of the chosen queue length. Unless the code is compiled in C11 mode and due to race conditions between event source and APSW is the result not fully consistent (see above) and must not be used for essential program flow decisions. </dd></dl>

</div>
</div>
<a class="anchor" id="a4a38186542aa435f82407b1ba4e482b3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> cde_createPeriodicTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserContextData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a periodic timer event from a callback.<br />
 Typical use case is a timer, which triggers sending of regular frames. </p><dl class="section return"><dt>Returns</dt><dd>The timer handle is returned; this handle is used to identify a timer (if several timers should share the same callback function) or to perform other operations on this timer.<br />
 If no timer can be created due to a lack of memory then <a class="el" href="cde__can_dispatcher_engine_8h.html#ae0d3e4c2dd73b8a8d886b1e9e5fd4315">CDE_INVALID_TIMER_HANDLE</a> is returned instead. Due to the static, deterministic error allocation concept this error should preferrably be handled by a simple assertion only; if this assertion doesn't fire in the DEBUG compilation then there won't be an error in the production code neither. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">tiPeriod</td><td>The timer will invoke the specified callback <em>callback</em> every <em>tiPeriod</em> time units. The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time; the timer will fire in every tick of the dispatcher.<br />
 The cycle time is not rounded to a multiple of the dispatcher's clock tick. If <em>tiPeriod</em> is not a multiple of the clock tick then the timer will always fire at the first tick at or after the next nominal due time. The timer events are no longer equidistant but the nominal cycle time is kept in average. </td></tr>
    <tr><td class="paramname">callback</td><td>Please refer to <em>tiPeriod</em>. </td></tr>
    <tr><td class="paramname">pUserContextData</td><td>The user specified context information, which is stored with the timer and which will be brought back into its callback at due time. In the timer's callback, use <em>cde_getEventData</em> to retrieve the value passed in here. The data type of the user context data is hidden behind <em>void*</em>; if you really pass in a pointer to some data then <a class="el" href="cde__can_dispatcher_engine_8c.html#aa395ff7d9b660e5b358177808a35e4d9">cde_getEventData()</a> will return the pointer - not the data it points to.<br />
 This argument is available only if <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a6f045f94b51a771db09e791e2e55f11c">CDE_ENABLE_TIMER_CONTEXT_DATA</a> is set to 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method and <a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer()</a> are the only pieces of code in the CAN interface implementation, which suffer from race conditions with other threads that call <a class="el" href="cde__can_dispatcher_engine_8c.html#ae9b8352ac0a7fee2ff2f56fdc7c93ec5">cde_dispatcherMain()</a>, too, and that could coincidently create a timer. The macros <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#abd9a70d559522dfac1af90b99d1fdb1e">cde_enterCriticalSection</a> and <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a2896ec09d34c4c244f9289952802c58c">cde_leaveCriticalSection</a> need to be defined in this case.<br />
 It's a strong recommendation to not use the timer creation API at run-time and to not set the critical section defines. Create your timers preferably at system initialization time. If periodic timers with varying cycle times are needed, this will likely require using single shot timers as a substitute; these can be re-triggered and re-used while period timers can only be killed and re-created. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a24766b834705025156306c89189c0950"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> cde_createSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiFromNow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pUserContextData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">boolean_t&#160;</td>
          <td class="paramname"><em>killAtDueTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a single shot timer event from a callback.<br />
 Typical use case is a timer, which triggers once after a while to notify a timeout. This timer can be re-triggered before it elapses and it can be reused after having elapsed. </p><dl class="section return"><dt>Returns</dt><dd>The timer handle is returned; this handle is used to identify a timer (if several timers should share the same callback function) or to perform other operations on this timer.<br />
 If no timer can be created due to a lack of memory then <a class="el" href="cde__can_dispatcher_engine_8h.html#ae0d3e4c2dd73b8a8d886b1e9e5fd4315">CDE_INVALID_TIMER_HANDLE</a> is returned instead. Due to the static, deterministic error allocation concept this error should preferrably be handled by a simple assertion only; if this assertion doesn't fire in the DEBUG compilation then there won't be an error in the production code neither. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">tiFromNow</td><td>The timer will invoke the specified callback <em>tiFromNow</em> time units later.<br />
 The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time and the timer fires in the next tick of the dispatcher.<br />
 For single-shot timers with <em>killAtDueTime</em> == <em>false</em> the value 0 is permitted, too; is means to create the timer in suspended state. Doing so can give better control of memory allocation; all ever required timers can be created in the initialization callback for later use at runtime and dynamic object creation at runtime is entirely avoided. </td></tr>
    <tr><td class="paramname">callback</td><td>Please refer to <em>tiFromNow</em>. </td></tr>
    <tr><td class="paramname">pUserContextData</td><td>The user specified context information, which is stored with the timer and which will be brought back into its callback at due time. In the timer's callback, use <em>cde_getEventData</em> to retrieve the value passed in here. The data type of the user context data is hidden behind <em>void*</em>; if you really pass in a pointer to some data then <a class="el" href="cde__can_dispatcher_engine_8c.html#aa395ff7d9b660e5b358177808a35e4d9">cde_getEventData()</a> will return the pointer - not the data it points to. This argument is available only if <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a6f045f94b51a771db09e791e2e55f11c">CDE_ENABLE_TIMER_CONTEXT_DATA</a> is set to 1. </td></tr>
    <tr><td class="paramname">killAtDueTime</td><td>Single shot timers can be killed at due time (and after callback processing) or they can stay alive for later reprogramming of a new single-shot time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method and <a class="el" href="cde__can_dispatcher_engine_8c.html#a4a38186542aa435f82407b1ba4e482b3">cde_createPeriodicTimer()</a> are the only pieces of code in the CAN interface implementation, which suffer from race conditions with other threads that call <a class="el" href="cde__can_dispatcher_engine_8c.html#ae9b8352ac0a7fee2ff2f56fdc7c93ec5">cde_dispatcherMain()</a>, too, and that could coincidently create a timer. The macros <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#abd9a70d559522dfac1af90b99d1fdb1e">cde_enterCriticalSection</a> and <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a2896ec09d34c4c244f9289952802c58c">cde_leaveCriticalSection</a> need to be defined in this case.<br />
 It's a strong recommendation to not use the timer creation API at run-time and to not set the critical section defines. Create your timers preferably at system initialization time but at runtime just re-trigger the always same instead of killing them and creating new ones. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher</a> </dd>
<dd>
<a class="el" href="cde__can_dispatcher_engine_8c.html#a10490cf6b83da1ef9d40c5fb8404b62f">cde_retriggerSingleShotTimer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ab9a069de593fb4d098988218e8e979bd"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_killTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A timer is killed. No later callbacks will appear for periodic and single shot timers and nor will it be possible to reset the due time of a killed timer. Killing of a timer can be done at any reasonable time. Exceptions are: The operation must neither be applied twice or more often to the same timer and nor after leaving the callback of a single-shot timer with auto kill property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the killed timer as got from the create function. The handle becomes invalid with return from this function!<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a timer. In which case the operation affects this timer. This operation is permitted but useless for a single-shot timer with auto-kill property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer</a> </dd>
<dd>
<a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher</a> </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame, bus and timer callbacks. It relates to the explicitly mentioned timer object. (For <em>hTimer</em> == <em>NULL</em> see above) </dd></dl>

</div>
</div>
<a class="anchor" id="ad011ccfe36717430b2fd24c65e70cc35"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_suspendSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a running timer. The difference to kill is that the timer object is not marked for reuse (which is the substitute for object destroying in our static, deterministic memory allocation concept). The handle stays valid and the timer can later be reused by reprogramming its due time with <a class="el" href="cde__can_dispatcher_engine_8c.html#a10490cf6b83da1ef9d40c5fb8404b62f">cde_retriggerSingleShotTimer()</a>.<br />
 The concept of suspending and later reusing timers only holds for single shot timers without the auto-kill property set. Calling this function for an auto-kill single shot timer is still permitted but the operation is effectively a kill. These timers can't be reprogrammed after suspend. Calling this function for a periodic timer is forbidden; this is caught by assertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the suspended timer as got from the create function. It needs to be a single-shot timer. Otherwise an assertion fires.<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a single-shot timer. In which case the operation affects this timer.<br />
 If the function is called from the on-elapse callback of a single-shot timer with auto-kill property set then the operation is without effect since the timer would be killed anyway. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a10490cf6b83da1ef9d40c5fb8404b62f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_retriggerSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiNewFromNow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A single shot timer can be reprogrammed during elapsing or - but only if it doesn't have the auto-kill property set - even after firing or explicit suspend command. Use this function to redefine the due time.<br />
 For running single shot timers with or without auto-kill property this operation means to postpone the timer event by a new time span counting from now.<br />
 For suspended timers it means the reactivation of an inactive timer object. Reactivation after suspend it functionally identical to killing a timer (explicit or by auto-kill) and creating a new one. The only difference is the different memory management impact, kill and create can mean to allocate a new object on the heap, whereas suspend/resume guarantees not to do any heap operation.<br />
 Please note: Single shot timers with auto-kill can't have a suspended state. They are either running or killed, i.e. no longer existant and not accessible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the reprogrammed timer as got from the create function. It needs to be a single-shot timer. Otherwise an assertion fires.<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a single-shot timer. In which case the operation affects this timer.<br />
 If the function is called from the on-elapse callback of a single-shot timer with auto-kill property set then the operation is without effect: These timers won't fire again but are definitly killed after firing their event. </td></tr>
    <tr><td class="paramname">tiNewFromNow</td><td>The new due time is defined to be <em>tiNewFromNow</em> time units in the future. The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time and the timer fires in the next tick of the dispatcher. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame, bus and timer callbacks. It relates to the explicitly mentioned timer object. (For <em>hTimer</em> == <em>NULL</em> see above.) </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer</a> </dd>
<dd>
<a class="el" href="cde__can_dispatcher_engine_8c.html#aa99cde64bdcea6cf539f8b9538ede14b">cde_createDispatcher</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0ed0e33149a08c944f5b96cfbf7d160f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a> cde_installCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="cde__can_dispatcher_engine_8h.html#a7c559c21351f133723e8b6a5b079fa7c">cde_callback_t</a>&#160;</td>
          <td class="paramname"><em>newCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All events related to a bus, frame or timer are reported through the registered callback. In general this callback can have a switch/case to handle different kinds of events. Sometime it might be better to (temporarily) redefine the callback function to handle anticipated, specific events. From within a callback the client code may use this function to re-register the callback function for all future events. </p><dl class="section return"><dt>Returns</dt><dd>The callback function registered so far is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">newCallback</td><td>The new callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame, bus and timer callbacks. It relates to the callback of the the event causing bus, frame or timer object. </dd></dl>

</div>
</div>
<a class="anchor" id="a8d2897423886fa64a631de16e2fe5813"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned long cde_getCanId </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the CAN ID of a frame from a callback invoked by frame or timer event. If it is a timer event then the operation relates to the parent frame of the timer. </p><dl class="section return"><dt>Returns</dt><dd>The CAN ID. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame or timer callback. An assertion fires if this function is invoked from a bus event's callback or from a timer's callback and the timer's parent is a bus. </dd></dl>

</div>
</div>
<a class="anchor" id="a0f36f93324ea09fb8284913e963d57d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cde_getIdxFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index of the frame. The index is the same, which had been returned by the registration of this frame (see <a class="el" href="cde__can_dispatcher_engine_8c.html#ae899a59eb3b3d1850e97185b9c8510a7">cde_registerFrame()</a>). The affected frame is the one, which caused the invocation of the callback. If it is a timer callback then the operation relates to the parent frame of the timer. </p><dl class="section return"><dt>Returns</dt><dd>Get the zero based, linear frame index.<br />
 No frame index can be determined if the callback, which uses this method is not frame related. This situation is caught by assertion and the production compilation will return <a class="el" href="cde__can_dispatcher_engine_8h.html#a0a1371615cb8b495fd3e3a822fe09c1b">CDE_INVALID_FRAME_INDEX</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a930b265bccf412974afeb8fef955a5f0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int cde_getIdxBus </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A callback may invoke this method to get the operating system handle of the related bus. For bus related events, this is the causing bus. For timer callbacks, this is either its parent bus or the bus its parent frame is transmitted on. For frame related callbacks this is the bus the frame is transmitted on. </p><dl class="section return"><dt>Returns</dt><dd>The OS handle of the CAN bus. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from all callbacks. </dd>
<dd>
This API function is available only if <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#adb0f6bcc1f14bd1e8591a25e2fd98de0">CDE_ENABLE_API_GET_INDEX_BUS</a> is set to 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a977d3cf3bbcc5558786732b15aec9a71"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aa315212b79df638706d6b0160bfae343">cde_osHandleFrame_t</a> cde_getOsHandleFrame </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the operating system handle of the frame related to the callback, which calls this method. The affected frame is the one, which caused the invocation of the callback. If it is a timer callback then the operation relates to the parent frame of the timer. </p><dl class="section return"><dt>Returns</dt><dd>The OS handle of the CAN frame. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame or timer callback. An assertion fires if this function is invoked from a bus event's callback or from a timer's callback and the timer's parent is not a frame. </dd>
<dd>
This API function is available only if <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#aedf5b13fd123f6992349ee7f21e732a8">CDE_ENABLE_API_GET_OS_HANDLE_FRAME</a> is set to 1. </dd></dl>

</div>
</div>
<a class="anchor" id="aac2292cf5c806c325a65062cf6f344f4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8h.html#a65f79e51e206a7228788d8575aa5116a">cde_handleTimer_t</a> cde_getHandleTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handle of the timer causing the callback of a <a class="el" href="cde__can_dispatcher_engine_8h.html#a8a41803df95d5cccffab4e8e879e80ed">CDE_TIMER_ELAPSED</a> event, which calls this method. The method can be useful to identify the due timer if several timer objects share the same callback. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the timer object as initially got from either <a class="el" href="cde__can_dispatcher_engine_8c.html#a4a38186542aa435f82407b1ba4e482b3">cde_createPeriodicTimer()</a> or <a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from a timer callback only. An assertion fires if this function is invoked from a bus or frame event's callback. </dd></dl>

</div>
</div>
<a class="anchor" id="ad0f6d44f6c3395161206ea4c3ffbe4ac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">boolean_t cde_isInboundTransmission </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the transmission direction of the frame related to the callback, which calls this method. The affected frame is the one, which caused the invocation of the callback. If it is a timer callback then the operation relates to the parent frame of the timer. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em> for a received frame, <b>false</b> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from frame or timer callback. An assertion fires if this function is invoked from a bus event's callback or from a timer's callback and the timer's parent is not a frame. </dd>
<dd>
This API function is available only if <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a86269295eb995fa5f749a79ff708ae2d">CDE_ENABLE_API_IS_INBOUND_TRANSMISSION</a> is set to 1. </dd></dl>

</div>
</div>
<a class="anchor" id="a47e7083e2226c3f7da761ae85f82289d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="cde__can_dispatcher_engine_8h.html#af4007e26eb30f402c12d06e128cf9d7d">cde_kindOfEvent_t</a> cde_getKindOfEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the reason for invokation of a callback. </p><dl class="section return"><dt>Returns</dt><dd>The reason for invokation or the causing event. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aa395ff7d9b660e5b358177808a35e4d9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void cde_getEventData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="cde__can_dispatcher_engine_8h.html#ac94edf4f0b3a7aa9f2a7ae32766a3f60">cde_callbackContext_t</a> *&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pSizeOfEvContentByteAry</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void **&#160;</td>
          <td class="paramname"><em>pEvContentByteAry</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the data contents of an event from within a callback.<br />
 Normally, this relates to the content bytes of a received frame but for external events other than <a class="el" href="cde__can_dispatcher_engine_8h.html#ac2ee83bf2ffcea1d7000efbbe3880e95">CDE_EV_FRAME_RECEPTION</a> it may have any other meaning, which is aggreed on between data producer and consumer, which are both defined in the integration code.<br />
 For timer events and if user specified timer context data is supported (see <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a6f045f94b51a771db09e791e2e55f11c">CDE_ENABLE_TIMER_CONTEXT_DATA</a>) then the data contents of the event is the user specified context data. This method will return the pointer value, which had been specified as parameter <em>pUserContextData</em> in the timer creation methods, either <a class="el" href="cde__can_dispatcher_engine_8c.html#a4a38186542aa435f82407b1ba4e482b3">cde_createPeriodicTimer()</a> or <a class="el" href="cde__can_dispatcher_engine_8c.html#a24766b834705025156306c89189c0950">cde_createSingleShotTimer()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">pSizeOfEvContentByteAry</td><td>The number of bytes returned by reference through <em>pEvContentByteAry</em>. </td></tr>
    <tr><td class="paramname">pEvContentByteAry</td><td>A pointer to a pointer variable in the client code, which is set such that it points to the content data of the event. The pointer in the client code has read-only access to the data and the data it points to is valid only during the execution of the callback, which this method is called from. The data needs to be copied by the callback code if this doesn't suffice.<br />
 The data has the alignment of a pointer to <em>void</em>. If you e.g. know that it actually is an <em>int</em> then you may on most platforms cast the got <em>void</em> pointer to an <em>int</em> pointer and read the integer as a whole. (As opposed to reading all the integer's bytes as unsigned char and composing the number from these.)<br />
 "On most platforms" refers to the fact that pointers normally have the same or a stricter alignment constraint than type <em>int</em>. However, this is not guaranteed and no general statement can be made if the data is of type <em>long</em>, <em>long</em> <em>long</em>, <em>float</em> or <em>double</em>. Platform specific defines and assertions should make the client code safe and portable if such data is in use. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Event data is not defined for timer events if the code is not compiled with support of user specified timer context data. It must not be used in this case, an assertion would fire and the return value is undefined. See <a class="el" href="cde__can_dispatcher_engine_8config_8h.html#a6f045f94b51a771db09e791e2e55f11c">CDE_ENABLE_TIMER_CONTEXT_DATA</a> for more. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="cde__can_dispatcher_engine_8c.html">cde_canDispatcherEngine.c</a></li>
    <li class="footer">Generated on Wed Sep 12 2018 23:00:09 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
