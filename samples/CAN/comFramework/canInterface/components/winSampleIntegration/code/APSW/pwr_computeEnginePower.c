/**
 * @file pwr_computeEnginePower.c
 * This is a (trivial) example of the functional application software (APSW), which would
 * have to be integrated with the operating system and the CAN interface engine to a
 * complete operational software.\n
 *   The main characteristics of the APSW is that it is widely independent from the
 * platform and its I/O mechanisms. Maybe it uses some generic macros to access the
 * platform layer I/O (and the macro definiton becomes a substantial part of the code
 * integration) or a function or data absed API is defined.\n
 *   In this sample integration we assume a data based API, providing access to all in- and
 * output signals. We directly use the data structure as generated by the code generator as
 * such data based API.
 *
 * Copyright (C) 2015 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
 *
 * This program is free software: you can redistribute it and/or modify it
 * under the terms of the GNU Lesser General Public License as published by the
 * Free Software Foundation, either version 3 of the License, or any later
 * version.
 *
 * This program is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
 * for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program. If not, see <http://www.gnu.org/licenses/>.
 */
/* Module interface
 *   pwr_computeEnginePwr
 *   pwr_checkUserLimits
 * Local functions
 */

/*
 * Include files
 */

#include <stdlib.h>
#include <stdio.h>
#include <math.h>
#include <assert.h>

#include "main.h"
#include "oss_operatingSystemSimulation.h"
#include "log_logger.h"
#include "pck_packCanFrame.h"
#include "pwr_computeEnginePower.h"


/*
 * Defines
 */
 
#ifndef M_PI
# define M_PI   3.14159265358979323846
#endif 


/*
 * Local type definitions
 */
 
 
/*
 * Local prototypes
 */
 
 
/*
 * Data definitions
 */
 
 
/*
 * Function implementation
 */


/**
 * Increment the global error counters, which are broadcasted via CAN.
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 *   @param errDlc
 * Do we have a DLC error in this clock tic?
 */ 
static void updateGlobalErrCounters(boolean_t errDlc, boolean_t errChksum, boolean_t errSqc)
{
    /* Consider possible overrun and limit the counters. */
    if(errDlc)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noDlcErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noDlcErrors;
    }
    if(errChksum)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noCheckSumErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noCheckSumErrors;
    }
    if(errSqc)
    {
        if(++pck_API_PT_StatusPowerDisplay_1537.signals.noSqcErrors == 0)
            -- pck_API_PT_StatusPowerDisplay_1537.signals.noSqcErrors;
    }
} /* End of updateGlobalErrCounters */




/**
 * Simulation of the APSW: The step function to be regularly called. It computes the
 * current engine power from the CAN input, displays it and broadcasts it on the CAN bus.
 */

void pwr_computeEnginePwr()
{
    /* Only compute a new value if the status of all required CAN input frames is alright. */
    boolean_t bSuccess = true;
    if(pck_API_PT_StateEcu01_1024.stsTransmission != cbk_stsTransm_okay)
    {
        bSuccess = false;
        
        /* Display the problem as part of this simulation. */
        static cbk_stsTransmission_t stsTransmission_last_ = cbk_stsTransm_okay;
        if(pck_API_PT_StateEcu01_1024.stsTransmission != stsTransmission_last_)
        {
            boolean_t errDlc = (pck_API_PT_StateEcu01_1024.stsTransmission
                                & cbk_stsTransm_errDLC
                               ) != 0
                    , errChksum = (pck_API_PT_StateEcu01_1024.stsTransmission
                                   & cbk_stsTransm_errChecksum
                                  ) != 0
                    , errSqc = (pck_API_PT_StateEcu01_1024.stsTransmission
                                & cbk_stsTransm_errSequence
                               ) != 0;
            updateGlobalErrCounters(errDlc, errChksum, errSqc);
            
            LOG_WARN( main_hGlobalLogger
                    , "%.1f ms: "
                      "pwr_computeEnginePwr: "
                      "Error CAN frame speed (1024)%s%s%s%s%s"
                    , oss_tiSim / 1000.0
                    , (pck_API_PT_StateEcu01_1024.stsTransmission & cbk_stsTransm_neverReceived) != 0
                      ? ", never received": ""
                    , (pck_API_PT_StateEcu01_1024.stsTransmission & cbk_stsTransm_errTimeout) != 0
                      ? ", timeout": ""
                    , errChksum? ", checksum error": ""
                    , errSqc? ", sequence error": ""
                    , errDlc? ", DLC error": ""
                    );
            stsTransmission_last_ = pck_API_PT_StateEcu01_1024.stsTransmission;
        }
    }
    if(pck_API_PT_StateEcu02_1040.stsTransmission != cbk_stsTransm_okay)
    {
        bSuccess = false;
        
        /* Display the problem as part of this simulation. */
        static cbk_stsTransmission_t stsTransmission_last_ = cbk_stsTransm_okay;
        if(pck_API_PT_StateEcu02_1040.stsTransmission != stsTransmission_last_)
        {
            boolean_t errDlc = (pck_API_PT_StateEcu02_1040.stsTransmission
                                & cbk_stsTransm_errDLC
                               ) != 0
                    , errChksum = (pck_API_PT_StateEcu02_1040.stsTransmission
                                   & cbk_stsTransm_errChecksum
                                  ) != 0
                    , errSqc = (pck_API_PT_StateEcu02_1040.stsTransmission
                                & cbk_stsTransm_errSequence
                               ) != 0;
            updateGlobalErrCounters(errDlc, errChksum, errSqc);

            LOG_WARN( main_hGlobalLogger
                    , "%.1f ms: "
                      "pwr_computeEnginePwr: "
                      "Error CAN frame torque (1040)%s%s%s%s%s"
                    , oss_tiSim / 1000.0
                    , (pck_API_PT_StateEcu02_1040.stsTransmission & cbk_stsTransm_neverReceived) != 0
                      ? ", never received": ""
                    , (pck_API_PT_StateEcu02_1040.stsTransmission & cbk_stsTransm_errTimeout) != 0
                      ? ", timeout": ""
                    , errChksum? ", checksum error": ""
                    , errSqc? ", sequence error": ""
                    , errDlc? ", DLC error": ""
                    );
            stsTransmission_last_ = pck_API_PT_StateEcu02_1040.stsTransmission;
        }
    }
    
    if(bSuccess)
    {
        double torque =  PCK_PT_1040_TORQUE_BIN_TO_DBL
                                    (pck_API_PT_StateEcu02_1040.signals.torque)
             , speedOfRotation = PCK_PT_1024_SPEEDOFROTATION_BIN_TO_DBL
                                    (pck_API_PT_StateEcu01_1024.signals.speedOfRotation)
             , power = 2.0 * M_PI / 60.0 * torque * speedOfRotation;
             
        /* Broadcast the results on the CAN bus: Put the computed power result into the API
           of the sent frame. A range check is done to ensure safe encoding. If the double
           wouldn't fit then the state is set to overflow. */
        double powerSaturated;
        if(power > PCK_PT_1536_POWER_MAX)
        {
            powerSaturated = PCK_PT_1536_POWER_MAX;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 2 /* overflow */;
        }  
        else if(power < PCK_PT_1536_POWER_MIN)
        {
            powerSaturated = PCK_PT_1536_POWER_MIN;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 2 /* overflow */;
        }
        else
        {
            /* Normal operation. */
            powerSaturated = power;
            pck_API_PT_InfoPowerDisplay_1536.signals.state = 0 /* valid */;
        }
        pck_API_PT_InfoPowerDisplay_1536.signals.power =
                                                PCK_PT_1536_POWER_DBL_TO_BIN(powerSaturated);
        
        LOG_RESULT( main_hGlobalLogger
                  , "%.1f ms: "
                    "pwr_computeEnginePwr: "
                    "Current power: %.f kW (%.0f PS), %.0f Nm at %.0f rpm"
                  , oss_tiSim / 1000.0
                  , power / 1000.0
                  , power / 735.49875
                  , torque
                  , speedOfRotation
                  );
    }
    else
    {
        /* Preconditions not met, no result available. Broadcast this information. */
        pck_API_PT_InfoPowerDisplay_1536.signals.power = PCK_PT_1536_POWER_DBL_TO_BIN(0.0);
        pck_API_PT_InfoPowerDisplay_1536.signals.state = 1 /* invalid input */;
    }
} /* End of pwr_computeEnginePwr */




/**
 * Check the current speed of rotation and engine power against the user set limits.\n
 *   This operation is barely useful but has been specified just as an application of
 * purely data change triggered CAN frames: An inbound frame is received in the instance
 * the user has redefined the limits (via whatever human machine interface) but never else
 * and the check result is sent out only if it changes. The check is done regularly from
 * the 100 ms task.
 */

void pwr_checkUserLimits()
{
    /* This function simply looks into the affected CAN messages (using the global message
       API) and conduct its checks. The new check results are unconditionally written into
       the related outbound message. Whether it is sent or not is entirely decided by the
       underlying CAN interface engine, which looks for data changes as trigger.
         The Windows integration is a single threaded application. Threads are serialized
       and no race conditions occur. A migration of this code to a real RTOS would have to
       consider some mutual exclusion or double buffering code when accessing the message
       API: The interface engine, which updates the API is run in the 10ms task but this
       function is indented for the slower 100ms task. */
     
    if(pck_API_PT_InfoPowerDisplay_1536.signals.state == 0 /* valid */)
    {
        /* Power could be updated recently, which means that all input had been validated.
           We can perform the checks. */
        double value = PCK_PT_1024_SPEEDOFROTATION_BIN_TO_DBL
                            (pck_API_PT_StateEcu01_1024.signals.speedOfRotation)
             , limit = PCK_PT_2032_MINSPEEDOFROTATION_BIN_TO_DBL
                            (pck_API_PT_UserLimits_2032.signals.minSpeedOfRotation);
        pck_API_PT_LimitsPowerDisplay_1538.signals.belowMinSpeedOfRotation = value < limit;
        
        limit = PCK_PT_2032_MAXSPEEDOFROTATION_BIN_TO_DBL
                                    (pck_API_PT_UserLimits_2032.signals.maxSpeedOfRotation);
        pck_API_PT_LimitsPowerDisplay_1538.signals.aboveMaxSpeedOfRotation = value > limit;

        /* Power: Limit is in kW, value in W. */
        value = 0.001
                * PCK_PT_1536_POWER_BIN_TO_DBL(pck_API_PT_InfoPowerDisplay_1536.signals.power);
        limit = PCK_PT_2032_MINPOWER_BIN_TO_DBL(pck_API_PT_UserLimits_2032.signals.minPower);
        pck_API_PT_LimitsPowerDisplay_1538.signals.belowMinPower = value < limit;
        
        limit = PCK_PT_2032_MAXPOWER_BIN_TO_DBL(pck_API_PT_UserLimits_2032.signals.maxPower);
        pck_API_PT_LimitsPowerDisplay_1538.signals.aboveMaxPower = value > limit;
    }
    else
    {
        /* No safe, validated input information is currently available, we don't do
           anything in this tick. */
    }
} /* End of pwr_checkUserLimits */