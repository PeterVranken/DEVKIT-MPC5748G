<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: mpo_mapOffsetOnly.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('mpo__map_offset_only_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">mpo_mapOffsetOnly.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="mpo__map_offset_only_8h_source.html">mpo_mapOffsetOnly.h</a>&quot;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ede__basic_definitions_8h_source.html">ede_basicDefinitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="mem__malloc_8h_source.html">mem_malloc.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae4fc7b2b4ad7c9d34ae8b409408e066f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#ae4fc7b2b4ad7c9d34ae8b409408e066f">INVALID_OFFSET_VALUE</a></td></tr>
<tr class="separator:ae4fc7b2b4ad7c9d34ae8b409408e066f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adbf275a6ab4454ca5c2ab4ebf90d86c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#adbf275a6ab4454ca5c2ab4ebf90d86c4">INVALID_MAP_VALUE</a></td></tr>
<tr class="separator:adbf275a6ab4454ca5c2ab4ebf90d86c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e5674560209aeb4148a84fd6c038817"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#a3e5674560209aeb4148a84fd6c038817">BIT_MASK_MAP_CONSTANT_IS_SIMPLE_MAPPING</a>&#160;&#160;&#160;1u</td></tr>
<tr class="separator:a3e5674560209aeb4148a84fd6c038817"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a5a6e33b65e002cf6186587f17c3a8184"><td class="memItemLeft" align="right" valign="top">typedef unsigned short&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a></td></tr>
<tr class="separator:a5a6e33b65e002cf6186587f17c3a8184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adaca599d2c287b0188058b508fb6612a"><td class="memItemLeft" align="right" valign="top">typedef struct map_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#adaca599d2c287b0188058b508fb6612a">map_t</a></td></tr>
<tr class="separator:adaca599d2c287b0188058b508fb6612a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:afa37cc513d1a21f75990b81a9681d2c5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#afa37cc513d1a21f75990b81a9681d2c5">_Static_assert</a> (sizeof(<a class="el" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a>)&lt;=sizeof(unsigned int),&quot;The type of the map constant needs to fit into type (un)signed int&quot;)</td></tr>
<tr class="separator:afa37cc513d1a21f75990b81a9681d2c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1955146017cd28b75948f40ad4a3df4c"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mpo__map_offset_only_8c.html#a1955146017cd28b75948f40ad4a3df4c">mpo_createMapOffsetOnly</a> (<a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *const pNewMap, unsigned int noKindsOfEv, const bool isSenderHandleInUseAry[], <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPool)</td></tr>
<tr class="separator:a1955146017cd28b75948f40ad4a3df4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module provides a simple handle map, suitable for many applications of the event dispatcher mechnism. It can be used as mapping from some OS event handles (e.g. Rx CAN frame handles) to the zero based index space of a dispatcher object.<br />
 The implementation supports the interfaces defined by the event sender and dispatcher engine and the map is therefore most easy to use in this context. Just create a map object and pass it to the constructor of sender or dispatcher object.<br />
 The implementation of this map uses a direct lookup table, i.e. the map is highly execution time efficient, O(1), and can be applied for arbitrary mappings as long as the convered OS handle and index spaces suffice. These spaces are kept little, they spawn an 8 Bit range only, in order to not waste much expensive RAM.<br />
 Most use cases will have a few kinds of events, which know an event handle for further distinction of events of the kind. (CAN: Message Rx and Tx events.) Many other events won't use a handle but stand for themselves. (CAN: Bus-off, bus on) To support these without wasting useless lookup RAM, the implementation offers an alternative, "simple" mapping: A single map value is stored for each of these kinds of events.</p>
<p>Copyright (C) 2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae4fc7b2b4ad7c9d34ae8b409408e066f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_OFFSET_VALUE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(_Generic( (<a class="code" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a>)0                         \</div>
<div class="line">                                         , uint8_t:  0x80                               \</div>
<div class="line">                                         , uint16_t: 0x8000                             \</div>
<div class="line">                                         , uint32_t: 0x80000000                         \</div>
<div class="line">                                         )                                              \</div>
<div class="line">                                )</div>
<div class="ttc" id="mpo__map_offset_only_8c_html_a5a6e33b65e002cf6186587f17c3a8184"><div class="ttname"><a href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a></div><div class="ttdeci">unsigned short uintMapConstant_t</div><div class="ttdef"><b>Definition:</b> mpo_mapOffsetOnly.c:70</div></div>
</div><!-- fragment --><p>Empty map entry. Used for recognition of ambiguous mapping definitions. </p>

</div>
</div>
<a class="anchor" id="adbf275a6ab4454ca5c2ab4ebf90d86c4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_MAP_VALUE</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">(_Generic( (<a class="code" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a>)0                         \</div>
<div class="line">                                         , uint8_t:  0xFF                               \</div>
<div class="line">                                         , uint16_t: 0xFFFF                             \</div>
<div class="line">                                         , uint32_t: 0xFFFFFFFF                         \</div>
<div class="line">                                         )                                              \</div>
<div class="line">                                )</div>
<div class="ttc" id="mpo__map_offset_only_8c_html_a5a6e33b65e002cf6186587f17c3a8184"><div class="ttname"><a href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a></div><div class="ttdeci">unsigned short uintMapConstant_t</div><div class="ttdef"><b>Definition:</b> mpo_mapOffsetOnly.c:70</div></div>
</div><!-- fragment --><p>The reserved value "uninitialized" for those kinds of events, which don't make use of of a sender handle. </p>

</div>
</div>
<a class="anchor" id="a3e5674560209aeb4148a84fd6c038817"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define BIT_MASK_MAP_CONSTANT_IS_SIMPLE_MAPPING&#160;&#160;&#160;1u</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Mask for bit "is simple mapping". </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a5a6e33b65e002cf6186587f17c3a8184"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short <a class="el" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The map value type. One bit is required to distinguish handle offset mapping from simple mapping. The representable range of map values is accordingly smaller. </p>

</div>
</div>
<a class="anchor" id="adaca599d2c287b0188058b508fb6612a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct map_t  map_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The map object. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="afa37cc513d1a21f75990b81a9681d2c5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Static_assert </td>
          <td>(</td>
          <td class="paramtype">sizeof(<a class="el" href="mpo__map_offset_only_8c.html#a5a6e33b65e002cf6186587f17c3a8184">uintMapConstant_t</a>)&lt;=sizeof(unsigned int)&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;The type of the map constant needs to fit into type (un)signed int&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A range calculations are done in the native integer size of the platform. This limits the configurable types for the map constant. </p>

</div>
</div>
<a class="anchor" id="a1955146017cd28b75948f40ad4a3df4c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mpo_createMapOffsetOnly </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *const&#160;</td>
          <td class="paramname"><em>pNewMap</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noKindsOfEv</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isSenderHandleInUseAry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPool</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create new map object. It has <em>noKindsOfEv</em> independently operating instances, which relate to the same number of supported kinds of events. The map is capabale of key-value pairs, which all have the simple relation value = key + const, where "const" is a fixed, known offset value, which may be individual per map instance.<br />
 Despite of its simplicity, this map is most useful. It can be applied in a majority of typical CAN interface use cases. It's always applicable if the mapped sender (or OS) handles are dealt out incrementally and if they are registered in this order at one and the same dispatcher system. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. The map is not usable in the latter case. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNewMap</td><td>If the function returns <em>true</em>, then the new map object is returned by reference as * <em>pNewMap</em>. </td></tr>
    <tr><td class="paramname">noKindsOfEv</td><td>The map will have this number of independent instances.<br />
 Caution, later at runtime, the argument kindOfEvent will be used as zero based index into the array of instances. Consequently, this map implementation must not be used, if the applied enumeration of event kinds is not zero based! </td></tr>
    <tr><td class="paramname">isSenderHandleInUseAry</td><td>A Boolean property of the map instance, which states, whether a given kind of event makes use of the sender handle. (Many events stands for themselves and don't require an additional handle for further differentiation.) Each entry in the array relates to one kind of event, so the array size is <em>noKindsOfEv</em> entries.<br />
 If <em>isSenderHandleInUseAry</em>[<em>i</em>] is <em>true</em>, then normal offset mapping is performed and the map lookup result is the sender handle value plus the fixed offset value, which has been stored for the <em>kindOfEvent</em> <em>i</em>.<br />
 If <em>isSenderHandleInUseAry</em>[<em>i</em>] is <em>false</em>, then no offset mapping is performed and the map lookup result is the fixed value, which has been stored for the <em>kindOfEvent</em> <em>i</em>. </td></tr>
    <tr><td class="paramname">pMemPool</td><td>This memory pool (by reference) provides the memory for the new object. The map is used from the dispatcher engine, so this memory pool should have the same access rights or restrictions as the one applied for creation of the related dispatcher object. Usually, it'll even be the same one. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_b30582f9ff20b54dfb5d39c40ac29991.html">handleMaps</a></li><li class="navelem"><a class="el" href="mpo__map_offset_only_8c.html">mpo_mapOffsetOnly.c</a></li>
    <li class="footer">Generated on Fri Feb 18 2022 19:44:45 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
