<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>comFramework - CAN Interface: vsq_threadSafeQueueVariableSize.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">comFramework - CAN Interface<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('vsq__thread_safe_queue_variable_size_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vsq_threadSafeQueueVariableSize.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__basic_definitions_8h_source.html">ede_basicDefinitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__event_dispatcher_engine_8config_8h_source.html">ede_eventDispatcherEngine.config.h</a>&quot;</code><br />
</div>
<p><a href="vsq__thread_safe_queue_variable_size_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a585323d744ee693146dd7b674213fc60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a585323d744ee693146dd7b674213fc60">VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a585323d744ee693146dd7b674213fc60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2fd4119306322ca91db7aef6c11b0e13"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a2fd4119306322ca91db7aef6c11b0e13">VSQ_SUPPORT_MEMORY_PROTECTION</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a2fd4119306322ca91db7aef6c11b0e13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aec1f518dfbb05393974f012bc678778a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#aec1f518dfbb05393974f012bc678778a">VSQ_ASSERT</a>(booleanInvariant)&#160;&#160;&#160;<a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a114a3328c11b3959d51b481a6a162905">EDE_ASSERT</a>(booleanInvariant)</td></tr>
<tr class="separator:aec1f518dfbb05393974f012bc678778a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a70b9f89da1ce38f2707de95e5be9a434"><td class="memItemLeft" align="right" valign="top">typedef struct vsq_queueHead_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a></td></tr>
<tr class="separator:a70b9f89da1ce38f2707de95e5be9a434"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28ef93f75fff4c3b380a1729a45aa9c8"><td class="memItemLeft" align="right" valign="top">typedef struct vsq_queueTail_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a></td></tr>
<tr class="separator:a28ef93f75fff4c3b380a1729a45aa9c8"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a73b648a69f1909e1ae0632320ca86570"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead</a> (void)</td></tr>
<tr class="separator:a73b648a69f1909e1ae0632320ca86570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6d0b8a2f12e0afa345169d33b15cfc9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#ad6d0b8a2f12e0afa345169d33b15cfc9">vsq_getSizeOfQueueTail</a> (unsigned int maxQueueLength, unsigned int maxElementSize)</td></tr>
<tr class="separator:ad6d0b8a2f12e0afa345169d33b15cfc9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac1f182fce15fc0e392e41243e0d0865a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#ac1f182fce15fc0e392e41243e0d0865a">vsq_createQueueHead</a> (void *pMemoryChunk)</td></tr>
<tr class="separator:ac1f182fce15fc0e392e41243e0d0865a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab6b4876c70469d0746203fdd3be5f3cd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#ab6b4876c70469d0746203fdd3be5f3cd">vsq_createQueueTail</a> (void *pMemoryChunk, unsigned int maxQueueLength, unsigned int maxElementSize)</td></tr>
<tr class="separator:ab6b4876c70469d0746203fdd3be5f3cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfb328fb5c2c9040e1400e8a4a3fa90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#adfb328fb5c2c9040e1400e8a4a3fa90c">vsq_linkQueueHeadWithTail</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *pTheQueuesHead, const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pTheQueuesTail)</td></tr>
<tr class="separator:adfb328fb5c2c9040e1400e8a4a3fa90c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a16f8a5cfe0652ed4b33363a7714d4c75"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a16f8a5cfe0652ed4b33363a7714d4c75">vsq_linkQueueTailWithHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pTheQueuesTail, const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *pTheQueuesHead)</td></tr>
<tr class="separator:a16f8a5cfe0652ed4b33363a7714d4c75"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa640bb119daf72bf9d1ccadcf88245c9"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#aa640bb119daf72bf9d1ccadcf88245c9">vsq_writeToTail</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail, const void *pData, unsigned int noBytes)</td></tr>
<tr class="separator:aa640bb119daf72bf9d1ccadcf88245c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1dd4a81bc1ebb6696a46b69f93fc98cc"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a1dd4a81bc1ebb6696a46b69f93fc98cc">vsq_allocTailElement</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail, unsigned int sizeOfPayload)</td></tr>
<tr class="separator:a1dd4a81bc1ebb6696a46b69f93fc98cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb2546ff04749f7dd640068fd382ffec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#afb2546ff04749f7dd640068fd382ffec">vsq_postTailElement</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail)</td></tr>
<tr class="separator:afb2546ff04749f7dd640068fd382ffec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33edd7c99a0f58851c8c39cfc78ff067"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a33edd7c99a0f58851c8c39cfc78ff067">vsq_readFromHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *pQueueHead, unsigned int *pSizeOfPayload)</td></tr>
<tr class="separator:a33edd7c99a0f58851c8c39cfc78ff067"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6dbe47e4b1c7a9cb8b7853b277c321"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#abe6dbe47e4b1c7a9cb8b7853b277c321">vsq_getIsCommunicationBroken</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:abe6dbe47e4b1c7a9cb8b7853b277c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aade47b415eaa9372e0c25f77df1412"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a0aade47b415eaa9372e0c25f77df1412">vsq_acknReSyncHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail)</td></tr>
<tr class="separator:a0aade47b415eaa9372e0c25f77df1412"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b17b3d142f7a6c114351293eb706766"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a7b17b3d142f7a6c114351293eb706766">vsq_getMaximumQueueUsage</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail)</td></tr>
<tr class="separator:a7b17b3d142f7a6c114351293eb706766"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ecdce9de28d07afde1204ebe1fc7edc"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a2ecdce9de28d07afde1204ebe1fc7edc">vsq_getMaximumQueueUsageInByte</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pQueueTail)</td></tr>
<tr class="separator:a2ecdce9de28d07afde1204ebe1fc7edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Definition of global interface of module <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html">vsq_threadSafeQueueVariableSize.c</a></p>
<p >Copyright (C) 2016-2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a585323d744ee693146dd7b674213fc60" name="a585323d744ee693146dd7b674213fc60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a585323d744ee693146dd7b674213fc60">&#9670;&nbsp;</a></span>VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VSQ_ENABLE_API_QUEUE_DIAGNOSTICS&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A diagnostic API reporting the usage of the queue can be useful for supporting the development of an application (dimensioning the queue sizes) but won't normally be required by the ready application. Therefore the compilation of this API can be configured using this switch. </p>

</div>
</div>
<a id="a2fd4119306322ca91db7aef6c11b0e13" name="a2fd4119306322ca91db7aef6c11b0e13"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2fd4119306322ca91db7aef6c11b0e13">&#9670;&nbsp;</a></span>VSQ_SUPPORT_MEMORY_PROTECTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VSQ_SUPPORT_MEMORY_PROTECTION&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >In a memory protected system, i.e., a system with different processes, where a process A can't violate the memory contents owned by another process B, the queue can be used to safely cross the process boundaries. The data sender, normally residing in the operating system process, can send data to some other client process of lower confidence level. In such an environment, the following switch should normally be enabled:<br  />
 If set to 1 then the sender will always double-check the feedback from the receiver process such that it will never be blocked or harmed by whatever fault at the receiver side. Instead, it'll with very high likelihood recognize a corruption of the receiver's side of the queue and offer a mechanism to re-enable/re-synchronize the receiver. Even in the very rare case if data corruption at the receiver side is not recognized, the sender's operation will stay stable and consistent - only the awareness about data loss at the receiver side would be lacking in this situation.<br  />
 The mechanims is not very expensive but still produces some overhead. At the same time is it entirely useless if no memory protection is configured between sender and receiver - which will be the case in the majority of integration scenarios. Set the switch to 0 in unprotected systems. </p>

</div>
</div>
<a id="aec1f518dfbb05393974f012bc678778a" name="aec1f518dfbb05393974f012bc678778a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aec1f518dfbb05393974f012bc678778a">&#9670;&nbsp;</a></span>VSQ_ASSERT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define VSQ_ASSERT</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">booleanInvariant</td><td>)</td>
          <td>&#160;&#160;&#160;<a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a114a3328c11b3959d51b481a6a162905">EDE_ASSERT</a>(booleanInvariant)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Many error conditions, which are static in the sense that they can only appear due to errors in the implementation code are checked by assertions. This relates to the implementation of the queue itself, but to the implementation of the client code, too. The most typical errors will be caught the first time the code is executed. This concept of static error checks makes it inevitable to have an assertion mechanism. Most platforms will offer an assertion. <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#aec1f518dfbb05393974f012bc678778a">VSQ_ASSERT(bool)</a> needs to expand to the assertion on your platform. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a70b9f89da1ce38f2707de95e5be9a434" name="a70b9f89da1ce38f2707de95e5be9a434"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a70b9f89da1ce38f2707de95e5be9a434">&#9670;&nbsp;</a></span>vsq_queueHead_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct vsq_queueHead_t vsq_queueHead_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The head of the queue as an object of unknown type. The API operates with pointers to such objects. </p>

</div>
</div>
<a id="a28ef93f75fff4c3b380a1729a45aa9c8" name="a28ef93f75fff4c3b380a1729a45aa9c8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a28ef93f75fff4c3b380a1729a45aa9c8">&#9670;&nbsp;</a></span>vsq_queueTail_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct vsq_queueTail_t vsq_queueTail_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The tail of the queue as an object of unknown type. The API operates with pointers to such objects. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a73b648a69f1909e1ae0632320ca86570" name="a73b648a69f1909e1ae0632320ca86570"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a73b648a69f1909e1ae0632320ca86570">&#9670;&nbsp;</a></span>vsq_getSizeOfQueueHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getSizeOfQueueHead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prior to queue creation: Query the size of a queue head object.</p>
<p >Calculate the size of a queue head object.<br  />
 This function is meant to be called prior to creation of a queue head object. The caller of the constructor is in charge of allocating the memory for the object - the intended use case of the queue implementation is the embedded environment, which doesn't permit to allocate memory dynamically using <em>malloc</em>. The typical use case avoids the use of <em>malloc:</em> </p><div class="fragment"><div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeOfQHead = <a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead</a>();</div>
<div class="line">_Alignas(<a class="code hl_typedef" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a>) <span class="keywordtype">char</span> memoryChunk[sizeOfQHead];</div>
<div class="line"><a class="code hl_typedef" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *pMyNewQueuesHead = <a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#a7c0915902940efb17baf5d6f538e4811">vsq_createQueueHead</a>(memoryChunk);</div>
<div class="line"><a class="code hl_typedef" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *pMyNewQueuesTail = ...</div>
<div class="line">vsq_linkQueueHeadWithTail(pMyNewQueuesHead, pMyNewQueuesTail);</div>
<div class="line"><a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead</a>(pMyNewQueuesTail, pMyNewQueuesHead);</div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_a3c25adfaa1191482b13867dd12cc0479"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead</a></div><div class="ttdeci">void vsq_linkQueueTailWithHead(vsq_queueTail_t *const pTheQueuesTail, const vsq_queueHead_t *const pTheQueuesHead)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:1261</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_a73b648a69f1909e1ae0632320ca86570"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead</a></div><div class="ttdeci">unsigned int vsq_getSizeOfQueueHead(void)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:868</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_a7c0915902940efb17baf5d6f538e4811"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a7c0915902940efb17baf5d6f538e4811">vsq_createQueueHead</a></div><div class="ttdeci">vsq_queueHead_t * vsq_createQueueHead(void *const pMemoryChunk)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:1018</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8h_html_a28ef93f75fff4c3b380a1729a45aa9c8"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a></div><div class="ttdeci">struct vsq_queueTail_t vsq_queueTail_t</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.h:93</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8h_html_a70b9f89da1ce38f2707de95e5be9a434"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a></div><div class="ttdeci">struct vsq_queueHead_t vsq_queueHead_t</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.h:86</div></div>
</div><!-- fragment --><p> Alternatively, the embedded environment may offer a simple, uncritical memory allocation or partitioning API, most likely without a free function to avoid fragmentation and indeterministic timing behavior. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes required to construct a queue object with the passed parameters. Only this number is computed, nothing else happens, in particular no queue head object is constructed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The memory chunk required by the constructor does not only need to have the right minimum size but, secondary, it needs to have the right alignment, which is specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a7c0915902940efb17baf5d6f538e4811">vsq_createQueueHead()</a> </dd></dl>

</div>
</div>
<a id="ad6d0b8a2f12e0afa345169d33b15cfc9" name="ad6d0b8a2f12e0afa345169d33b15cfc9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad6d0b8a2f12e0afa345169d33b15cfc9">&#9670;&nbsp;</a></span>vsq_getSizeOfQueueTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getSizeOfQueueTail </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoStdElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfStdElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Prior to queue creation: Query the size of a queue tail object.</p>
<p >Calculate the size of a queue tail object.<br  />
 This function is meant to be called prior to creation of a queue tail object. The caller of the constructor is in charge of allocating the memory for the object - the intended use case of the queue implementation is the embedded environment, which doesn't permit to allocate memory dynamically using <em>malloc</em>.<br  />
 This function needs to be called with the same parameters as later the constructor. The constructor will silently assume that the memory chunk it receives from the caller will have the size computed by this method. The typical use case avoids the use of <em>malloc:</em> </p><div class="fragment"><div class="line"><span class="keyword">struct </span>qElement_t;</div>
<div class="line"><span class="preprocessor">#define MAX_Q_LEN 10</span></div>
<div class="line"><span class="keyword">const</span> <span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> sizeOfQTail = <a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail</a>( MAX_Q_LEN</div>
<div class="line">                                                       , <span class="keyword">sizeof</span>(<span class="keyword">struct</span> qElement_t)</div>
<div class="line">                                                       );</div>
<div class="line"><a class="code hl_define" href="vsq__thread_safe_queue_variable_size_8h.html#aec1f518dfbb05393974f012bc678778a">VSQ_ASSERT</a>(_Alignof(<span class="keyword">struct</span> qElement_t) &lt;= _Alignof(uintptr_t));</div>
<div class="line">_Alignas(<a class="code hl_typedef" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a>) <span class="keywordtype">char</span> memoryChunk[sizeOfQTail];</div>
<div class="line"><a class="code hl_typedef" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *pMyNewQueuesHead = ...</div>
<div class="line">vsq_queueTail_t *pMyNewQueuesTail = <a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#abea9e83f5e323dd6ac71fc85433253b6">vsq_createQueueTail</a>( memoryChunk</div>
<div class="line">                                                       , MAX_Q_LEN</div>
<div class="line">                                                       , <span class="keyword">sizeof</span>(<span class="keyword">struct</span> qElement_t)</div>
<div class="line">                                                       );</div>
<div class="line"><a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail</a>(pMyNewQueuesHead, pMyNewQueuesTail);</div>
<div class="line"><a class="code hl_function" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead</a>(pMyNewQueuesTail, pMyNewQueuesHead);</div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_a8cb622a1c7423e6b7f7cbe657670c299"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail</a></div><div class="ttdeci">void vsq_linkQueueHeadWithTail(vsq_queueHead_t *const pTheQueuesHead, const vsq_queueTail_t *const pTheQueuesTail)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:1227</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_abea9e83f5e323dd6ac71fc85433253b6"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#abea9e83f5e323dd6ac71fc85433253b6">vsq_createQueueTail</a></div><div class="ttdeci">vsq_queueTail_t * vsq_createQueueTail(void *pMemoryChunk, unsigned int maxNoStdElements, unsigned int sizeOfStdElement)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:1111</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8c_html_ae5e06b4cc00f61cfdc599c195691c816"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail</a></div><div class="ttdeci">unsigned int vsq_getSizeOfQueueTail(unsigned int maxNoStdElements, unsigned int sizeOfStdElement)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:950</div></div>
<div class="ttc" id="avsq__thread_safe_queue_variable_size_8h_html_aec1f518dfbb05393974f012bc678778a"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8h.html#aec1f518dfbb05393974f012bc678778a">VSQ_ASSERT</a></div><div class="ttdeci">#define VSQ_ASSERT(booleanInvariant)</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.h:74</div></div>
</div><!-- fragment --><p> Alternatively, the embedded environment may offer a simple, uncritical memory allocation or partitioning API, most likely without a free function to avoid fragmentation and indeterministic timing behavior. </p><dl class="section return"><dt>Returns</dt><dd>The number of Byte required to construct a queue tail object with the passed parameters. Only this number is computed, nothing else happens, in particular no queue tail object is constructed.<br  />
 If a 16 Bit integer type is used to implement the link indexes for the queue elements, it can happen that the specified capacity of the queue is not realizable. The function returns zero in this case. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNoStdElements</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many elements of given <em>size</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the storable number.<br  />
 Rationale: Using a typical standard element size plus a number of those elements as size specification supports the still most relevant use cases with elements of identical size.<br  />
 A queue size of zero is considered an error in the client code. This is caught by assertion and zero is returned. <em>maxNoStdElements</em> * <em>sizeOfStdElement</em> needs to be greater than zero. </td></tr>
    <tr><td class="paramname">sizeOfStdElement</td><td>The size of a standard element, which should be storable <em>maxNoStdElements</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caution, the implementation is not made safe against overflows on systems, where type unsigned int is less than 32 Bit. On such systems, you must not rely on the function return value but carefully double-check that the size of the ring buffer doesn't exceed the 64 kByte limit. Actually, this is a bit theoretic as such systems won't ever have so much RAM that this constraint would be relevant. </dd>
<dd>
The function operates without type information but needs to form a list of elements. To safely do so it needs to anticipate the alignment required for such an element. This alignment will later be applied to all contained elements, regardless of their individual size.<br  />
 Usually this is the alignment of the largest element type if it are primitive types or the alignment of the largest field in any of the elements if it are structs.<br  />
 The required alignment usually is a platform dependent constant and not an application dependent run-time argument. Therefore, it is supplied as macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>, which is part of the compile-time configuration data of this module. You should double-check the setting for your particular platform. </dd>
<dd>
The memory chunk required by the constructor does not only need to have the right minimum size but, secondary, it needs to have the right alignment, which is specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#abea9e83f5e323dd6ac71fc85433253b6">vsq_createQueueTail()</a> </dd></dl>

</div>
</div>
<a id="ac1f182fce15fc0e392e41243e0d0865a" name="ac1f182fce15fc0e392e41243e0d0865a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac1f182fce15fc0e392e41243e0d0865a">&#9670;&nbsp;</a></span>vsq_createQueueHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> * vsq_createQueueHead </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pMemoryChunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new, still unlinked, still unusable queue head object.</p>
<p >Create a new, still unlinked, still unusable, queue head object. Prior to first use, the head needs to be doubly linked with its communication peer, a queue tail object. See <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> and <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the queue head object. Effectively, this is the same pointer as <em>pMemoryChunk</em> but type casted for use as queue head. If the caller uses dynamic memory management then he may free either his memory chunk or the returned pointer after use of the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemoryChunk</td><td>The caller is in charge of allocating memory for the new queue head object. A memory chunk of required size or bigger is passed in by reference. The required size needs to queried with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a> prior to the call of this constructor.<br  />
 Besides the right size, the memory chunk needs to have the right alignment, which is specified at compile-time unsing macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. If you use <em>malloc</em> to allocate the memory chunk than this should normally be granted.<br  />
 The correct alignment is double-checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For alignment considerations and constraints, please refer to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a>. </dd>
<dd>
There's no destructor for a queue head object. The caller is responsible for providing the memory for the object and freeing this memory &ndash; if applicable &ndash; would be the only operation to delete a queue head object after use. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a> </dd></dl>

</div>
</div>
<a id="ab6b4876c70469d0746203fdd3be5f3cd" name="ab6b4876c70469d0746203fdd3be5f3cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab6b4876c70469d0746203fdd3be5f3cd">&#9670;&nbsp;</a></span>vsq_createQueueTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> * vsq_createQueueTail </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemoryChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoStdElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfStdElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new, still unlinked, still unusable queue tail object.</p>
<p >Create a new, still unlinked, still unusable, queue tail object. Prior to first use, the tail needs to be doubly linked with its communication peer, a queue head object. See <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> and <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the queue tail object. Effectively, this is the same pointer as <em>pMemoryChunk</em> but type casted for use as queue. If the caller uses dynamic memory management then he may free either his memory chunk or the returned pointer after use of the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemoryChunk</td><td>The caller is in charge of allocating memory for the new queue object. A memory chunk of required size or bigger is passed in by reference. The required size needs to queried with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a> prior to the call of this constructor.<br  />
 Besides the right size, the memory chunk needs to have the right alignment, which is specified at compile-time unsing macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. If you use <em>malloc</em> to allocate the memory chunk than this should normally be granted.<br  />
 The correct alignment is double-checked by assertion. </td></tr>
    <tr><td class="paramname">maxNoStdElements</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many elements of given size <em>would</em> fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the storable number.<br  />
 Rationale: Using a typical standard element size plus a number of those elements as size specification supports the still most relevant use cases with elements of identical size.<br  />
 A queue size of zero is considered an error in the client code. This is caught by assertion and NULL is returned. <em>maxNoStdElements</em> * <em>sizeOfStdElement</em> needs to be greater than zero. </td></tr>
    <tr><td class="paramname">sizeOfStdElement</td><td>The size of a standard element, which should be storable <em>maxNoStdElements</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For alignment considerations and constraints, please refer to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a>. </dd>
<dd>
There's no destructor for a queue object. The caller is responsible for providing the memory for the object and freeing this memory &ndash; if applicable &ndash; would be the only operation to delete a queue tail object after use. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a> </dd></dl>

</div>
</div>
<a id="adfb328fb5c2c9040e1400e8a4a3fa90c" name="adfb328fb5c2c9040e1400e8a4a3fa90c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfb328fb5c2c9040e1400e8a4a3fa90c">&#9670;&nbsp;</a></span>vsq_linkQueueHeadWithTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkQueueHeadWithTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >After creation of head and tail, connect a queue's tail object to its head object.</p>
<p >The intended queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the head object and can thus be used by the same process that created the head object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> will do the same for the tail object and from another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTheQueuesHead</td><td>The newly created queue head object, which is now linked to its tail. </td></tr>
    <tr><td class="paramname">pTheQueuesTail</td><td>This is the tail object, * <em>pTheQueuesHead</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Do we need a memory barrier somewhere here? And in the counterpart? </dd></dl>

</div>
</div>
<a id="a16f8a5cfe0652ed4b33363a7714d4c75" name="a16f8a5cfe0652ed4b33363a7714d4c75"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a16f8a5cfe0652ed4b33363a7714d4c75">&#9670;&nbsp;</a></span>vsq_linkQueueTailWithHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkQueueTailWithHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >After creation of head and tail, connect a queue's head object to its tail object.</p>
<p >The intended queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the tail object and can thus be used by the same process that created the tail object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> will do the same for the head object and from another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTheQueuesTail</td><td>The newly created queue tail object, which is now linked to its head. </td></tr>
    <tr><td class="paramname">pTheQueuesHead</td><td>This is the head object, * <em>pTheQueuesTail</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa640bb119daf72bf9d1ccadcf88245c9" name="aa640bb119daf72bf9d1ccadcf88245c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa640bb119daf72bf9d1ccadcf88245c9">&#9670;&nbsp;</a></span>vsq_writeToTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_writeToTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Append a new element to the tail of the queue.</p>
<p >Append a new element to the tail of the queue. </p><dl class="section return"><dt>Returns</dt><dd>The operation can fail; the queue is implemented with a pre-determined maximum size and it can be currently full. Get <em>true</em> if the operation succeeds and <em>false</em> in case of a currently full queue.<br  />
 The elements themselves have a flexible size. The function will return <em>false</em> if the caller tries to write more bytes than currently fit into the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object to write to by reference. </td></tr>
    <tr><td class="paramname">pData</td><td>The pointer to the payload data of the appended element. This is an anonymous byte sequence to this method. memcpy is used to copy the data into the queue, which imposes no alignment requirements on the data. </td></tr>
    <tr><td class="paramname">noBytes</td><td>The number of bytes to write.<br  />
 No data will be copied to the queue if the function returns <em>false</em>.<br  />
 Note, it is valid to append an empty element. The related later call of <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ab0db763d8148be9f200bc56023380c71">vsq_readFromHead()</a> will return a non-NULL data pointer in combination with a number of zero bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ade8c2b4a9c8ed4191bb67f22ba793444">vsq_allocTailElement()</a> </dd>
<dd>
<a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ab0db763d8148be9f200bc56023380c71">vsq_readFromHead()</a> </dd></dl>

</div>
</div>
<a id="a1dd4a81bc1ebb6696a46b69f93fc98cc" name="a1dd4a81bc1ebb6696a46b69f93fc98cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1dd4a81bc1ebb6696a46b69f93fc98cc">&#9670;&nbsp;</a></span>vsq_allocTailElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void * vsq_allocTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if the queue has currently room to append another element to the tail and return the available element in case.</p>
<p >Check if the queue has currently room to append another element to the tail and return the available element in case.<br  />
 This method, together with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a51d57a5cd793bce550a438ae539f7e48">vsq_postTailElement()</a>, is an alternative API to write to the end of the queue. If <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ade8c2b4a9c8ed4191bb67f22ba793444">vsq_allocTailElement()</a> returns a non NULL pointer then the caller can take any time to fill the queue element the return value points to without fearing any race conditions. After having the element filled he will use <em>vsq_postTailElement</em> to submit the element. From now on the element will be visible to the consumer at the end of the queue.<br  />
 Using this API in contrast to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> can save a local copy of the produced data in the producers implementation.<br  />
 The producer APIs to access the tail of the queue are not race condition free. A call of <em>vsq_writeToTail</em> must either<br  />
</p><ul>
<li>return before the next call of the same method or<br  />
</li>
<li>return before the invocation of <em>vsq_allocTailElement</em> or<br  />
</li>
<li>be initiated after return from <em>vsq_postTailElement</em>.</li>
</ul>
<p >This means for a single producer context, that it can alternatingly use <em>vsq_writeToTail</em> and the pair of <em>vsq_allocTailElement</em> and <em>vsq_postTailElement</em>. For concurrent producer contexts it imposes the need for the implementation of mutual exclusion code at the caller's side. </p><dl class="section return"><dt>Returns</dt><dd>Get either the next available ring buffer element by reference or NULL if the queue is currently full.<br  />
 The returned pointer is aligned as had been specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer. There is no time limit in keeping the pointer (i.e., until data submission with <em>vsq_postTailElement</em>) and using the pointer can avoid the need for an additional local copy of the data during data production time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object by reference. </td></tr>
    <tr><td class="paramname">sizeOfPayload</td><td>The size of the payload of the appended element in Byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The calls of <em>vsq_allocTailElement</em> and <em>vsq_postTailElement</em> need to be done strictly alternatingly. It is not possible to reserve several elements by multiple calls of the former method and to submit them later by the same number of calls of the latter method. </dd>
<dd>
It is possible to use this method prior to <em>vsq_writeToTail</em> to query if the queue is currently full and to avoid a negative return value of that function. It's however disencouraged to do so. There is a little useless computation overhead in doing so and, more important, the pair of <em>vsq_allocTailElement</em> and <em>vsq_writeToTail</em> is not race condition free; a queue element could become free between the two calls &ndash; the strategy would be too conservative. </dd></dl>

</div>
</div>
<a id="afb2546ff04749f7dd640068fd382ffec" name="afb2546ff04749f7dd640068fd382ffec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afb2546ff04749f7dd640068fd382ffec">&#9670;&nbsp;</a></span>vsq_postTailElement()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_postTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Submit a queue element, which had been allocated with <em>vsq_allocTailElement</em>.</p>
<p >Submit a queue element, which had been allocated with <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ade8c2b4a9c8ed4191bb67f22ba793444">vsq_allocTailElement()</a>.<br  />
 From now on, the element is in the queue and visible to the consumer. The pointer, which had been got from <em>vsq_allocTailElement</em> is invalid and must no longer be used.<br  />
 Please, find more details of using this API in the description of the counterpart method <em>vsq_allocTailElement</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object, where the submitted element had been allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void *vsq_allocTailElement() </dd></dl>

</div>
</div>
<a id="a33edd7c99a0f58851c8c39cfc78ff067" name="a33edd7c99a0f58851c8c39cfc78ff067"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33edd7c99a0f58851c8c39cfc78ff067">&#9670;&nbsp;</a></span>vsq_readFromHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void * vsq_readFromHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pSizeOfPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Read a meanwhile receivced new element from the head of the queue.</p>
<p >Read a meanwhile receivced new element from the head of the queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the newly received element if a new element has arrived. <em>NULL</em> is returned if no new element has been received since the previous invocation of this method.<br  />
 The element, which is returned by reference is from now on owned by the data consumer, i.e., the caller of this method. It may use the pointer to read the data. The ownership only ends by getting another pointer to another element with a future invocation of this method. In particular, it does not end when a future call of this method returns <em>NULL</em>. The access to the owned element is race condition free for the owner of the pointer.<br  />
 The returned pointer is aligned as had been specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer without the need for first copying the data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueHead</td><td>The queue object to be read from by reference. </td></tr>
    <tr><td class="paramname">pSizeOfPayload</td><td>The number of bytes, which are conveyed with the received element, is returned by reference. It is the same value as had been provided to the related call of either <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> or <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ade8c2b4a9c8ed4191bb67f22ba793444">vsq_allocTailElement()</a>.<br  />
 The value is set to zero if the function returns NULL.<br  />
 Note, queued elements of size zero are allowed and possible. In which case, the value is set to zero, too; howeber, now the function won't return NULL.<br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The consumer API is not reentrant. It is not possible to let concurrent consumer contexts read from the head of the queue. This holds even if the consumer code implements synchronization code, which ensures mutual exclusion from this method. This is because the method's effect persists after return from the method; the returned element is reserved to the caller until the next method invocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> </dd></dl>

</div>
</div>
<a id="abe6dbe47e4b1c7a9cb8b7853b277c321" name="abe6dbe47e4b1c7a9cb8b7853b277c321"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abe6dbe47e4b1c7a9cb8b7853b277c321">&#9670;&nbsp;</a></span>vsq_getIsCommunicationBroken()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_getIsCommunicationBroken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Query the communication state in a memory protected environment.</p>
<p >On each queueing of an element, the sender process double-checks if the memories of the receiver process are still valid (as far as the communication via this queue is concerned). It sets a flag in case of not valid. Then the communication is broken until the receiver is re-synchronized (see <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a9e8d41171ada0245a5a64274d4057f5f">vsq_acknReSyncHead()</a>). This method queries the communication state. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> if communication is alright. If <em>true</em> is returned then no more elements can be queued until the receiver has been re-synchronized. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aade47b415eaa9372e0c25f77df1412" name="a0aade47b415eaa9372e0c25f77df1412"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aade47b415eaa9372e0c25f77df1412">&#9670;&nbsp;</a></span>vsq_acknReSyncHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_acknReSyncHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Complete the re-synchronization of a corrupted receiver process.</p>
<p >If the sender had detected and reported a broken communication situation due to corrupted receiver memories then the queue operation is blocked also for the sender until the receiver has been re-synchronized. This is done &ndash; after general recover of the receiver process &ndash; by again calling method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> from the receiver process and acknowledging success to the sender.<br  />
 The complexity of re-synchronization is the asynchronity of sender and receiver and their memory access rights. The entire mechanism is useful only in environments, where the receiver process' memories cannot be written from the sender process. It'll always be a matter of inter-process communication to complete the re-synchronization. This can be implemented only in some platform specific external code:</p><ol type="1">
<li>Receiver process needs to generally recover from its problems</li>
<li>Receiver process needs to invoke method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a>. This requires the address of the tail object - if it is lost due to the data corruption then the sender process will have to provide it again</li>
<li>Receiver process needs to notify completion of invocation of <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> to the sender process. From this point in time on, it may again check its queue head for newly received elements. Initially, there won't be any</li>
<li>The sender process needs to call method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a9e8d41171ada0245a5a64274d4057f5f">vsq_acknReSyncHead()</a> in order to acknowledge the re-synchonization to the queue logic. From now on, the queue operation is re-enabled for the sender. The next call of alloc/post or <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> will succeed again and it'll queue the first element the receiver will get again after re-synchronization. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, which is re-sychronized. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a id="a7b17b3d142f7a6c114351293eb706766" name="a7b17b3d142f7a6c114351293eb706766"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7b17b3d142f7a6c114351293eb706766">&#9670;&nbsp;</a></span>vsq_getMaximumQueueUsage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getMaximumQueueUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the maximum number of queued elements, which has ever been seen.</p>
<p >Get the maximum number of queued elements, which has been seen since creation of the queue object. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of elements. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The compilation of this API can be turned on/off by configuration switch <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a585323d744ee693146dd7b674213fc60">VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd>
<dd>
This method my be called at any time from producer or conumer context. </dd></dl>

</div>
</div>
<a id="a2ecdce9de28d07afde1204ebe1fc7edc" name="a2ecdce9de28d07afde1204ebe1fc7edc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ecdce9de28d07afde1204ebe1fc7edc">&#9670;&nbsp;</a></span>vsq_getMaximumQueueUsageInByte()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getMaximumQueueUsageInByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the maximum number of queued elements, which has ever been seen.</p>
<p >Get the maximum use of buffer memory, which has been seen since creation of the queue object.<br  />
 Note, the variable element size implies, that the queue potentially can't make use of all memory. This is even normal and not an extraordinary situation. Consequently, if the reported memory consumption is less than the configured memory, it doesn't necessarily mean the the queue was never full. </p><dl class="section return"><dt>Returns</dt><dd>Get the number in Byte. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The compilation of this API can be turned on/off by configuration switch <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a585323d744ee693146dd7b674213fc60">VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd>
<dd>
This method my be called at any time from producer or conumer context. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_083cb9b71a0904a1342a47f5208adb1c.html">connectors</a></li><li class="navelem"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html">vsq_threadSafeQueueVariableSize.h</a></li>
    <li class="footer">Generated on Tue Oct 4 2022 15:29:09 for comFramework - CAN Interface by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
