<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>comFramework - CAN Interface: mem_malloc.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">comFramework - CAN Interface<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('mem__malloc_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">mem_malloc.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__basic_definitions_8h_source.html">ede_basicDefinitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__event_dispatcher_engine_8config_8h_source.html">ede_eventDispatcherEngine.config.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
</div>
<p><a href="mem__malloc_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a9af1afd6b2143b1ef14c7c5d4fd36122"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#a9af1afd6b2143b1ef14c7c5d4fd36122">MEM_DIAGNOSTIC_INTERFACE</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a9af1afd6b2143b1ef14c7c5d4fd36122"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac49f2f733b2f360379a501acca61a395"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#ac49f2f733b2f360379a501acca61a395">MEM_MALLOC</a>(memPoolObj,  sizeOfChunk)&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#ac0dfb9afed1e568fc4de0629daa57a2b">EDE_CALL_INTERFACE_VA_ARGS</a>(memPoolObj, malloc, sizeOfChunk)</td></tr>
<tr class="separator:ac49f2f733b2f360379a501acca61a395"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d52238a3a5099c007cbd084ce842184"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#a2d52238a3a5099c007cbd084ce842184">MEM_GET_NBR_OF_AVAILABLE_BYTES</a>(memPoolObj)&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#a53fee197120a647c50813f937b0b1976">EDE_CALL_INTERFACE_NO_ARGS</a>(memPoolObj, getNbrOfAvailableBytes)</td></tr>
<tr class="separator:a2d52238a3a5099c007cbd084ce842184"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a95fb32e62e4b97cd1bb234864d6b677d"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#a95fb32e62e4b97cd1bb234864d6b677d">MEM_GET_NBR_OF_ALLOCATED_BYTES</a>(memPoolObj)&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#a53fee197120a647c50813f937b0b1976">EDE_CALL_INTERFACE_NO_ARGS</a>(memPoolObj, getNbrOfAllocatedBytes)</td></tr>
<tr class="separator:a95fb32e62e4b97cd1bb234864d6b677d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab877da6f01417e138e45db48a393d598"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#ab877da6f01417e138e45db48a393d598">MEM_VOID_CRITICAL_SECTION_OBJECT</a>&#160;&#160;&#160;            (const <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a>){.enter = NULL, .leave = NULL, .hInstance = 0u}</td></tr>
<tr class="separator:ab877da6f01417e138e45db48a393d598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a679cfe25e8260e550289580b3a402921"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#a679cfe25e8260e550289580b3a402921">mem_criticalSection_t</a></td></tr>
<tr class="separator:a679cfe25e8260e550289580b3a402921"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="mem__malloc_8h.html#a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd">mem_createMemoryPool</a> (<a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pNewMemPool, void *pPoolMemory, unsigned int sizeOfPoolMemory, <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a> mutualExclusionGuard)</td></tr>
<tr class="separator:a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Definition of global interface of module <a class="el" href="mem__malloc_8c.html">mem_malloc.c</a></p>
<p >Copyright (C) 2015-2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a9af1afd6b2143b1ef14c7c5d4fd36122" name="a9af1afd6b2143b1ef14c7c5d4fd36122"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9af1afd6b2143b1ef14c7c5d4fd36122">&#9670;&nbsp;</a></span>MEM_DIAGNOSTIC_INTERFACE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_DIAGNOSTIC_INTERFACE&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A tiny API to get some information about memory usage can be conditionally compiled. Use this API during development phase to reduce the heap space to the minimum possible. </p>

</div>
</div>
<a id="ac49f2f733b2f360379a501acca61a395" name="ac49f2f733b2f360379a501acca61a395"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac49f2f733b2f360379a501acca61a395">&#9670;&nbsp;</a></span>MEM_MALLOC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_MALLOC</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memPoolObj, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">sizeOfChunk&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#ac0dfb9afed1e568fc4de0629daa57a2b">EDE_CALL_INTERFACE_VA_ARGS</a>(memPoolObj, malloc, sizeOfChunk)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A wrapper for the call of method malloc from the memory pool interface. Using this wrapper lets the method invocation look much like a normal function call. In particular, the explicit use of the instance handle is hidden. </p><dl class="section return"><dt>Returns</dt><dd>Get the void * to the allocated memory. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memPoolObj</td><td>The memory pool to use. A memory pool interface instance, which has been created and returned by <a class="el" href="mem__malloc_8h.html#a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd">mem_createMemoryPool()</a>. </td></tr>
    <tr><td class="paramname">sizeOfChunk</td><td>The number of bytes to be allocated in the memory pool. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d52238a3a5099c007cbd084ce842184" name="a2d52238a3a5099c007cbd084ce842184"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d52238a3a5099c007cbd084ce842184">&#9670;&nbsp;</a></span>MEM_GET_NBR_OF_AVAILABLE_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_GET_NBR_OF_AVAILABLE_BYTES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memPoolObj</td><td>)</td>
          <td>&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#a53fee197120a647c50813f937b0b1976">EDE_CALL_INTERFACE_NO_ARGS</a>(memPoolObj, getNbrOfAvailableBytes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A wrapper for the call of method getNbrOfAvailableBytes from the memory pool interface. Using this wrapper lets the method invocation look much like a normal function call. In particular, the explicit use of the instance handle is hidden. </p><dl class="section return"><dt>Returns</dt><dd>Get the amount of still unused pool memory in Byte. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memPoolObj</td><td>The memory pool to use. A memory pool interface instance, which has been created and returned by <a class="el" href="mem__malloc_8h.html#a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd">mem_createMemoryPool()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a95fb32e62e4b97cd1bb234864d6b677d" name="a95fb32e62e4b97cd1bb234864d6b677d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a95fb32e62e4b97cd1bb234864d6b677d">&#9670;&nbsp;</a></span>MEM_GET_NBR_OF_ALLOCATED_BYTES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_GET_NBR_OF_ALLOCATED_BYTES</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">memPoolObj</td><td>)</td>
          <td>&#160;&#160;&#160;                                <a class="el" href="ede__external_interfaces_8h.html#a53fee197120a647c50813f937b0b1976">EDE_CALL_INTERFACE_NO_ARGS</a>(memPoolObj, getNbrOfAllocatedBytes)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A wrapper for the call of method getNbrOfAllocatedBytes from the memory pool interface. Using this wrapper lets the method invocation look much like a normal function call. In particular, the explicit use of the instance handle is hidden. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of already allocated bytes. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">memPoolObj</td><td>The memory pool to use. A memory pool interface instance, which has been created and returned by <a class="el" href="mem__malloc_8h.html#a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd">mem_createMemoryPool()</a>. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab877da6f01417e138e45db48a393d598" name="ab877da6f01417e138e45db48a393d598"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab877da6f01417e138e45db48a393d598">&#9670;&nbsp;</a></span>MEM_VOID_CRITICAL_SECTION_OBJECT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MEM_VOID_CRITICAL_SECTION_OBJECT&#160;&#160;&#160;            (const <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a>){.enter = NULL, .leave = NULL, .hInstance = 0u}</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A critical section object without functionality. Does nothing. Can be applied to memory pools, which are not going to be used from competing contexts. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="a679cfe25e8260e550289580b3a402921" name="a679cfe25e8260e550289580b3a402921"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a679cfe25e8260e550289580b3a402921">&#9670;&nbsp;</a></span>mem_criticalSection_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a> <a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The interface of a critical section implementation. The instance of an implementation of such a CS provides mutual exclusion from the portion of code, which is enclosed in two calls of methods enter() and leave(). </p><dl class="section note"><dt>Note</dt><dd>The interface specification leaves it undecided what "mutual exclusion" means, or to whom it relates. Whether all contexts on a single core is meant or only a sub-set or if it relates to contexts on different cores depends on the use case of the CS and will be answered by the given implementation. </dd></dl>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd" name="a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0a1c7b1ed77b3ebc7ffd0cdc0def4ddd">&#9670;&nbsp;</a></span>mem_createMemoryPool()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool mem_createMemoryPool </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pNewMemPool</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pPoolMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfPoolMemory</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structmem__critical_section__t.html">mem_criticalSection_t</a>&#160;</td>
          <td class="paramname"><em>mutualExclusionGuard</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a new memory pool from some given memory.</p>
<p >Create a new memory pool from some given memory. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if operation succeeded. If the function returns <em>false</em> then * <em>pNewMemPool</em> will be unusable.<br  />
 A memory pool requires a minimum number of Bytes to host the administrative data. In pathologic situations, where <em>sizeOfPoolMemory</em> promises only a few Byte, the function may fail.<br  />
 The function will fail only in case of lack of memory or if a bad critical section object <em>mutualExclusionGuard</em> is specified. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pNewMemPool</td><td>The newly created object by reference. The caller has to provide the space for the new object. </td></tr>
    <tr><td class="paramname">pPoolMemory</td><td>The pointer to a chunk of memory, which is statically allocated, available and reserved for the given memory pool during the entire application run-time. This chunk of memory will be partitioned and made available to those data structures of the CAN interface, which are associated with the given pool. The properties of this memory area will become the properties of all the chunks of memory dealt out later by the new pool. </td></tr>
    <tr><td class="paramname">sizeOfPoolMemory</td><td>The number of bytes of <em>pPoolMemory</em>. </td></tr>
    <tr><td class="paramname">mutualExclusionGuard</td><td>If the same memory is partitioned and distributed to clients running in different task (or interrupt) contexts then the entry into method mem_malloc() needs to be serialized.<br  />
 If optional method enter() of <em>mutualExclusionGuard</em> is not <em>NULL</em> then it is invoked before the actual operation of memory allocation to ensure atomicity of the operation.<br  />
 Accordingly, if optional method leave() of <em>mutualExclusionGuard</em> is not <em>NULL</em> then it is invoked after the actual operation of memory allocation. Note, it is not allowed to pass an object, where enter() is <em>NULL</em> but leave() isn't <em>NULL</em> or vice versa.<br  />
 The specified guard object needs to be suitable to mutually exclude all contexts competing for the given memory pool.<br  />
 In a single threaded environment or if the newly created memory pool object won't ever be used in concurrent contexts one should pass an object with methods enter() and leave() both being <em>NULL</em>.<br  />
 Note, the critical section object is copied by value into the newly created memory pool. All of its memory is therefore owned by the owner of the pool. If the methods write to or read from field <em>hInstance</em> then they need to be aware that they access some memory owned by owner of the pool, which normally is the caller of the methods. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function writes (only) to the specified new pool memory. Therefore, it needs to be called from the context, which owns the new pool or from a super-ordinated context, which has write access to the pool-memory, too, e.g. the operating system. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_8ae31aac3bacc0ded92e05f421c5e1c0.html">memoryPool</a></li><li class="navelem"><a class="el" href="mem__malloc_8h.html">mem_malloc.h</a></li>
    <li class="footer">Generated on Tue Oct 4 2022 15:29:09 for comFramework - CAN Interface by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
