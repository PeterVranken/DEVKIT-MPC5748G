<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: ede_mapSenderEvHandleToIdx_t Struct Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li class="current"><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="classes.html"><span>Data&#160;Structure&#160;Index</span></a></li>
      <li><a href="functions.html"><span>Data&#160;Fields</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('structede__map_sender_ev_handle_to_idx__t.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#pub-attribs">Data Fields</a>  </div>
  <div class="headertitle">
<div class="title">ede_mapSenderEvHandleToIdx_t Struct Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-attribs"></a>
Data Fields</h2></td></tr>
<tr class="memitem:aa18a9e6c33d6339b31600c37bbb77c21"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#aa18a9e6c33d6339b31600c37bbb77c21">addKeyValuePair</a> )(uintptr_t <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#a714096fc732ea8f1353bd742a0404598">hInstance</a>, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, unsigned int mapValue)</td></tr>
<tr class="separator:aa18a9e6c33d6339b31600c37bbb77c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9eb69f0f1f39176351617ba96656cec"><td class="memItemLeft" align="right" valign="top">bool(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#ac9eb69f0f1f39176351617ba96656cec">getValue</a> )(uintptr_t <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#a714096fc732ea8f1353bd742a0404598">hInstance</a>, unsigned int *pValue, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent)</td></tr>
<tr class="separator:ac9eb69f0f1f39176351617ba96656cec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a714096fc732ea8f1353bd742a0404598"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#a714096fc732ea8f1353bd742a0404598">hInstance</a></td></tr>
<tr class="separator:a714096fc732ea8f1353bd742a0404598"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The interface of a map, which associates the sender's identification of an event with the internally used zero based index. The implementation of the map is done externally as part of the integration, here we just specify the interface of the required map.<br />
 The map is used for lookup of two kinds of indexes:<br />
</p><ol type="1">
<li>Use case mapping external events to registered event sources:<br />
 The map's function <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#aa18a9e6c33d6339b31600c37bbb77c21">addKeyValuePair()</a> is internally called by the dispatcher engine on each registration of an event source, i.e., ede_registerEventSource(). This way, the map is built up.<br />
 The map's function <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#ac9eb69f0f1f39176351617ba96656cec">getValue()</a> is internally called by the dispatcher engine on reception of an external event in order to associate the received event data with the causing, registered event source.<br />
</li>
<li>Use case mapping external evemts to a sender's port:<br />
The map associates an abstract event handle with a sender's port (addressed by index), which the event is posted to. Using an externally defined map to decide the port to use, allows the external code to control/define the communication structure. (The generic implementation of the event dispatcher does not make any assumption about the communication paths.) In this use case, only the map lookup operation is used, in the operation to post an event, i.e., <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a>. The implementation of sender and dispatcher don't take care of building up the map. </li>
</ol>
</div><h2 class="groupheader">Field Documentation</h2>
<a class="anchor" id="aa18a9e6c33d6339b31600c37bbb77c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* ede_mapSenderEvHandleToIdx_t::addKeyValuePair)(uintptr_t <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#a714096fc732ea8f1353bd742a0404598">hInstance</a>, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, unsigned int mapValue)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This function helps to prepare the map.<br />
</p><ol type="1">
<li>Use case mapping external events to registered event sources:<br />
 A single association as appears in each event registration is added to the map. This function is called once per registered event source as sub-routine of ede_registerEventSource().<br />
 May be NULL. In many environments, the required map is trivial (e.g. the identity) or known (and generated as ROM table) and no code is required to built-up the map.<br />
</li>
<li>Use case mapping external evemts to a sender's port:<br />
 The function is currently not called by the dispatcher engine or sender implementation. The integration code is in charge of providing the map contents and it may or may not make use of this function to buildup the map.<br />
 May be NULL to indicate that operation is not required.<br />
 <dl class="section return"><dt>Returns</dt><dd>The function will return <em>true</em>, if the new key, value pair could be considered. The implementation of the map may be limited by size or otherwise. If the map entry could not be made the external function may return <em>false</em> and, later at run-time, the sender or dispatcher engine will ignore all events, which origin from the related event source. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hInstance</td><td>This is the identification of the map instance to use. The data type uintptr_t is such that the implementation of the map can hide an index into an array of objects or a pointer to an object behind this value. See field <em>hInstance</em>, too.<br />
</td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>
<ol type="1">
<li>Use case mapping external events to registered event sources:<br />
 Each dispatcher has its own index space for event sources and will apply a dedicated map.<br />
</li>
<li>Use case mapping external evemts to a sender's port:<br />
 Each sender has its own index space for its individual ports and it'll use a dedicated, related map instance. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kindOfEvent</td><td>An event is characterized by its kind and by the sender's handle. The meaning of both values is transparent to sender and dispatcher engine. They will be defined by the integrating environment. A common use case would for example be: Kind is "CAN Rx
event" and sender handle is CAN message ID. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>See <em>kindOfEvent</em>. </td></tr>
    <tr><td class="paramname">mapValue</td><td>The value of the pair to add to the map. This value needs to be returned by <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#ac9eb69f0f1f39176351617ba96656cec">getValue()</a> if the same event characterization is provided.<br />
 Use cases: It's either the zero based index of a registered event source or the zero based index of a sender's port. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function is called in the system initialization phase, i.e. in a single threaded, still race condition free context. </dd></dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="ac9eb69f0f1f39176351617ba96656cec"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool(* ede_mapSenderEvHandleToIdx_t::getValue)(uintptr_t <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#a714096fc732ea8f1353bd742a0404598">hInstance</a>, unsigned int *pValue, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The map lookup operation. The index associated with an external event is queried.<br />
</p><ol type="1">
<li>Use case mapping external events to registered event sources:<br />
 The requested index is that of an event source as internally used by the dispatcher engine. The map query function is called as sub-routine of the dispatching operation, <a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain()</a>.<br />
</li>
<li>Use case mapping external events to a sender's port:<br />
 The requested index is that of a port of the querying sender. The map query function is called as sub-routine of sending an event, <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a>.<br />
 Must not be NULL. <dl class="section return"><dt>Returns</dt><dd>Normally, the requested index is returned by reference (see below) and the function result is <em>true</em>. If the function doesn't find a suitable association it will return <em>false</em> and the related event is lost. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hInstance</td><td>This is the identification of the map instance to use. The data type uintptr_t is such that the implementation of the map can hide an index into an array of objects or a pointer to an object behind this value. See field <em>hInstance</em>, too.<br />
</td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>
<ol type="1">
<li>Use case mapping external events to registered event sources:<br />
 Each dispatcher has its own index space for event sources and will apply a dedicated map.<br />
</li>
<li>Use case mapping external evemts to a sender's port:<br />
 Each sender has its own index space for its individual ports and it'll use a dedicated, related map instance. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pValue</td><td>The result of the lookup operation is returned by reference. If the function returns <em>false</em> then it may ignore this parameter. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>First element of characterizing the event source under progress. See argument of same name of <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#aa18a9e6c33d6339b31600c37bbb77c21">addKeyValuePair()</a> for more details. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>Second element of characterizing the event source under progress. See argument of same name of <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html#aa18a9e6c33d6339b31600c37bbb77c21">addKeyValuePair()</a> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The external implementation of the map function needs to be reentrant only with respect to different map instances. There won't be concurrent calls for one and the same instance. </dd></dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="a714096fc732ea8f1353bd742a0404598"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t ede_mapSenderEvHandleToIdx_t::hInstance</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An actual implementation of the map will require some specific data. This field provides access to this data.<br />
 This value is passed as first argument to the functions specified in this interface.<br />
 The meaning of <em>hInstance</em> is transparent to the interface definition but it'll likely by either an index into an array of map instances or a pointer to a map instance. The chosen type allows both and the implementation will do the appropriate type cast. </p>

</div>
</div>
<hr/>The documentation for this struct was generated from the following file:<ul>
<li><a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a></li>
    <li class="footer">Generated on Fri Feb 18 2022 19:44:45 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
