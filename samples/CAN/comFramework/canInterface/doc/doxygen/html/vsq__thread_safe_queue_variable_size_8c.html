<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: vsq_threadSafeQueueVariableSize.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vsq__thread_safe_queue_variable_size_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vsq_threadSafeQueueVariableSize.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="vsq__thread_safe_queue_variable_size_8h_source.html">vsq_threadSafeQueueVariableSize.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:acc7946672fc0b4d7bedb860989cadcdb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>&#160;&#160;&#160;(sizeof(((const <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>*)NULL)-&gt;idxNext))</td></tr>
<tr class="separator:acc7946672fc0b4d7bedb860989cadcdb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a8b308e8fb332945247df48f5f4094f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>&#160;&#160;&#160;(sizeof(uintptr_t))</td></tr>
<tr class="separator:a2a8b308e8fb332945247df48f5f4094f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6329fca57b419ca76d54b1a8290af65f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a>&#160;&#160;&#160;(sizeof(<a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1984590117449c15952558cdfa57f13f">uintatomic_t</a>))</td></tr>
<tr class="separator:a6329fca57b419ca76d54b1a8290af65f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#afa99ec4acc4ecb2dc3c2d05da15d0e3f">MAX</a>(a, b)&#160;&#160;&#160;(((a) &gt; (b)) ? (a) : (b))</td></tr>
<tr class="separator:afa99ec4acc4ecb2dc3c2d05da15d0e3f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3acffbd305ee72dcd4593c0d8af64a4f">MIN</a>(a, b)&#160;&#160;&#160;(((a) &lt; (b)) ? (a) : (b))</td></tr>
<tr class="separator:a3acffbd305ee72dcd4593c0d8af64a4f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5aa623be52f3ca00ca8058b302b548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#afb5aa623be52f3ca00ca8058b302b548">CHECK_THIS</a></td></tr>
<tr class="separator:afb5aa623be52f3ca00ca8058b302b548"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afb5aa623be52f3ca00ca8058b302b548"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#afb5aa623be52f3ca00ca8058b302b548">CHECK_THIS</a></td></tr>
<tr class="separator:afb5aa623be52f3ca00ca8058b302b548"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a1984590117449c15952558cdfa57f13f"><td class="memItemLeft" align="right" valign="top">typedef <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1984590117449c15952558cdfa57f13f">uintatomic_t</a></td></tr>
<tr class="separator:a1984590117449c15952558cdfa57f13f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab9f6c6661870234d09004407a438d5a3"><td class="memItemLeft" align="right" valign="top">typedef unsigned short int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a></td></tr>
<tr class="separator:ab9f6c6661870234d09004407a438d5a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2da01ec229eb5936c0d3b8ea59b09902"><td class="memItemLeft" align="right" valign="top">typedef struct queueElement_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a></td></tr>
<tr class="separator:a2da01ec229eb5936c0d3b8ea59b09902"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1e2aa07874ccb589b36b1c0dcedce4a2"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1e2aa07874ccb589b36b1c0dcedce4a2">_Static_assert</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> &gt;=<a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a550231c7d9af9163faba9a68d9e1df75">EDE_COMMON_MACHINE_ALIGNMENT</a>,&quot;Suspicious specification of machine alignment&quot;)</td></tr>
<tr class="separator:a1e2aa07874ccb589b36b1c0dcedce4a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a73b648a69f1909e1ae0632320ca86570"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead</a> (void)</td></tr>
<tr class="separator:a73b648a69f1909e1ae0632320ca86570"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae5e06b4cc00f61cfdc599c195691c816"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail</a> (unsigned int maxNoStdElements, unsigned int sizeOfStdElement)</td></tr>
<tr class="separator:ae5e06b4cc00f61cfdc599c195691c816"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac13d5725452aceacfd8ac3b25beeef2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#aac13d5725452aceacfd8ac3b25beeef2">vsq_createQueueHead</a> (void *const pMemoryChunk)</td></tr>
<tr class="separator:aac13d5725452aceacfd8ac3b25beeef2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87232b737d5d9e563391184621f3d619"><td class="memItemLeft" align="right" valign="top"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a87232b737d5d9e563391184621f3d619">vsq_createQueueTail</a> (void *pMemoryChunk, unsigned int maxNoStdElements, unsigned int sizeOfStdElement)</td></tr>
<tr class="separator:a87232b737d5d9e563391184621f3d619"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8cb622a1c7423e6b7f7cbe657670c299"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const pTheQueuesHead, const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pTheQueuesTail)</td></tr>
<tr class="separator:a8cb622a1c7423e6b7f7cbe657670c299"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c25adfaa1191482b13867dd12cc0479"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pTheQueuesTail, const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const pTheQueuesHead)</td></tr>
<tr class="separator:a3c25adfaa1191482b13867dd12cc0479"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad36860a03cf15b51113117779b840edc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail, const void *pData, unsigned int noBytes)</td></tr>
<tr class="separator:ad36860a03cf15b51113117779b840edc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac824504a0b8e9ee527210d902586a62b"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ac824504a0b8e9ee527210d902586a62b">vsq_allocTailElement</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail, unsigned int sizeOfPayload)</td></tr>
<tr class="separator:ac824504a0b8e9ee527210d902586a62b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a51d57a5cd793bce550a438ae539f7e48"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a51d57a5cd793bce550a438ae539f7e48">vsq_postTailElement</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:a51d57a5cd793bce550a438ae539f7e48"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c7e5c2548db4df5322c765805186d6b"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1c7e5c2548db4df5322c765805186d6b">vsq_readFromHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const pQueueHead, unsigned int *const pSizeOfPayload)</td></tr>
<tr class="separator:a1c7e5c2548db4df5322c765805186d6b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe6dbe47e4b1c7a9cb8b7853b277c321"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#abe6dbe47e4b1c7a9cb8b7853b277c321">vsq_getIsCommunicationBroken</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:abe6dbe47e4b1c7a9cb8b7853b277c321"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e8d41171ada0245a5a64274d4057f5f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a9e8d41171ada0245a5a64274d4057f5f">vsq_acknReSyncHead</a> (<a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:a9e8d41171ada0245a5a64274d4057f5f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a47cbd5cd96591a5d2fbff5c468203509"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a47cbd5cd96591a5d2fbff5c468203509">vsq_getMaximumQueueUsage</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:a47cbd5cd96591a5d2fbff5c468203509"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0b9117fd3075fcdd83a0937129d870ee"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a0b9117fd3075fcdd83a0937129d870ee">vsq_getMaximumQueueUsageInByte</a> (const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const pQueueTail)</td></tr>
<tr class="separator:a0b9117fd3075fcdd83a0937129d870ee"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Thread-safe implementation of a queue. Filling and reading the queue may be done from different threads. It doesn't matter whether these threads have same or different priorities and whether they are running on the same or on different cores.<br />
 The implementation is lock-free. Mutual exclusion of threads is based on spatial separation rather then on serialization (ordering in time). No two threads will ever read or write to the same address space. The implementation is based on shared memory, which can be read and written by both affected threads. In practice, this will almost always mean some uncached memory area.<br />
 If the queue connects two processes with enabled memory protection, then the sender of data (tail process) needs to belong to the trusted sphere of code in order not to endanger the stability of the receiver process: If the queue data is potentially damaged then the receiver will not only get damaged data but also wrong pointers to data, which may cause potential access violations and resulting exceptions in the receiving process.<br />
 It doesn't matter if the receiver doesn't belong to the sphere of trusted code. If the receiver data is damaged then the stability of the sender is not harmed. It may of course lead to loss of data (data not read from the queue, still unread data overwritten by the sender), but the sender will not operate with damaged data, it'll not run a risk of access violation or exception.<br />
 For the principal use case of a CAN interface, this asymmetry is just fine. The sender will always be the (trusted) OS code, which sends Rx messages or Tx send-acknowledges to the receiver, which may then be some untrusted QM code.</p>
<p>Copyright (C) 2016-2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="acc7946672fc0b4d7bedb860989cadcdb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN_OF_HDR&#160;&#160;&#160;(sizeof(((const <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>*)NULL)-&gt;idxNext))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The thread-safe implementation of the dispatcher queue builds on defined memory ordering; machine operations are expected to happen in the order of C code statements. This is not easy to achieve in C as the language semantics doesn't have awareness of concurrency (before C11). The solution will always be target and compiler dependent. Here, we offer a macro, which is meant to implement a full memory barrier on the target.<br />
 Fortunately, when using GCC there is a platform independent solution. See <a href="http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html">http://gcc.gnu.org/onlinedocs/gcc-4.4.3/gcc/Atomic-Builtins.html</a> for details. The alignment of type queueElement_t. The queue element can make use of a configurable integer size for storage of indexes. We need to know the alignment for this type and compilers not supporting C11 can't figure it out. You need to configure the alignment in accordance with the chosen index type, see uintidx_t.<br />
 TriCore: The alignment of an unsigned int is not identical to its size. The alignment can be reduced to 2 Byte even if unsigned int is configured as index type. </p>

</div>
</div>
<a class="anchor" id="a2a8b308e8fb332945247df48f5f4094f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN_OF_PAYLOAD&#160;&#160;&#160;(sizeof(uintptr_t))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The alignment of the payload of the queued elements in Byte. The payload of an element read from the queue is returned by reference. The got address will have at least this alignment.<br />
 The value will normally be the largest natural alignment for the given architecture, i.e. 4 Byte for 32 Bit systems and 8 Byte on 64 Bit systems. However, special architectures like TriCore can deviate. A 32 Bit TriCore could use 2 Byte if the payload doesn't contain double values.<br />
 The specified value must not be less than <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>. This is checked by assertion. </p>

</div>
</div>
<a class="anchor" id="a6329fca57b419ca76d54b1a8290af65f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define ALIGN_OF_UINTATOMIC&#160;&#160;&#160;(sizeof(<a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1984590117449c15952558cdfa57f13f">uintatomic_t</a>))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The alignment of the chosen atomic integer type. Mostly, it'll be sizeof(uintatomic_t), but because of some specialities on particular platforms, we make this explicit.<br />
 TriCore: The alignment of an unsigned int is not identical to the alignment, we require, which is the alignment that ensures atomic read and write operations. Taking the maximum of alignment and size should be alright in nearly all environments. </p>

</div>
</div>
<a class="anchor" id="afa99ec4acc4ecb2dc3c2d05da15d0e3f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MAX</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((a) &gt; (b)) ? (a) : (b))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The maximum of two numbers as a preprocessor expression. </p>

</div>
</div>
<a class="anchor" id="a3acffbd305ee72dcd4593c0d8af64a4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define MIN</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">a, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">b&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;(((a) &lt; (b)) ? (a) : (b))</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The minimum of two numbers as a preprocessor expression. </p>

</div>
</div>
<a class="anchor" id="afb5aa623be52f3ca00ca8058b302b548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_THIS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a>     \</div>
<div class="line">             &amp;&amp;  (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>                      \</div>
<div class="line">             &amp;&amp;  (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>          \</div>
<div class="line">             &amp;&amp;  <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> &gt;= <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>                                           \</div>
<div class="line">             &amp;&amp;  <span class="keyword">sizeof</span>(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>) % <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> == 0                             \</div>
<div class="line">             &amp;&amp;  offsetof(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>, payload) % <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> == 0                  \</div>
<div class="line">             &amp;&amp;  <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int) &gt;= <span class="keyword">sizeof</span>(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a>)                                  \</div>
<div class="line">            )</div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a6329fca57b419ca76d54b1a8290af65f"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a></div><div class="ttdeci">#define ALIGN_OF_UINTATOMIC</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:172</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a2a8b308e8fb332945247df48f5f4094f"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a></div><div class="ttdeci">#define ALIGN_OF_PAYLOAD</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:156</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_ab9f6c6661870234d09004407a438d5a3"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a></div><div class="ttdeci">unsigned short int uintidx_t</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:215</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_acc7946672fc0b4d7bedb860989cadcdb"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a></div><div class="ttdeci">#define ALIGN_OF_HDR</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:138</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a2da01ec229eb5936c0d3b8ea59b09902"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a></div><div class="ttdeci">struct queueElement_t queueElement_t</div></div>
</div><!-- fragment -->
</div>
</div>
<a class="anchor" id="afb5aa623be52f3ca00ca8058b302b548"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define CHECK_THIS</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">((<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a>     \</div>
<div class="line">             &amp;&amp;  (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>                      \</div>
<div class="line">             &amp;&amp;  (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> | (<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>-1))+1 == 2*<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>          \</div>
<div class="line">             &amp;&amp;  <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> &gt;= <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a>                                           \</div>
<div class="line">             &amp;&amp;  <span class="keyword">sizeof</span>(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>) % <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> == 0                             \</div>
<div class="line">             &amp;&amp;  offsetof(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a>, payload) % <a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> == 0                  \</div>
<div class="line">             &amp;&amp;  <span class="keyword">sizeof</span>(<span class="keywordtype">unsigned</span> int) &gt;= <span class="keyword">sizeof</span>(<a class="code" href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a>)                                  \</div>
<div class="line">            )</div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a6329fca57b419ca76d54b1a8290af65f"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a6329fca57b419ca76d54b1a8290af65f">ALIGN_OF_UINTATOMIC</a></div><div class="ttdeci">#define ALIGN_OF_UINTATOMIC</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:172</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a2a8b308e8fb332945247df48f5f4094f"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a></div><div class="ttdeci">#define ALIGN_OF_PAYLOAD</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:156</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_ab9f6c6661870234d09004407a438d5a3"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a></div><div class="ttdeci">unsigned short int uintidx_t</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:215</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_acc7946672fc0b4d7bedb860989cadcdb"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#acc7946672fc0b4d7bedb860989cadcdb">ALIGN_OF_HDR</a></div><div class="ttdeci">#define ALIGN_OF_HDR</div><div class="ttdef"><b>Definition:</b> vsq_threadSafeQueueVariableSize.c:138</div></div>
<div class="ttc" id="vsq__thread_safe_queue_variable_size_8c_html_a2da01ec229eb5936c0d3b8ea59b09902"><div class="ttname"><a href="vsq__thread_safe_queue_variable_size_8c.html#a2da01ec229eb5936c0d3b8ea59b09902">queueElement_t</a></div><div class="ttdeci">struct queueElement_t queueElement_t</div></div>
</div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="a1984590117449c15952558cdfa57f13f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a> <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1984590117449c15952558cdfa57f13f">uintatomic_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The thread-safe implementation of the queue builds on atomic read and write of a numeric type. Basically any atomic unsigned integer available on the target platform can be typedef'ed here; however, the maximum length of the queue is given by the range of this type - thus don't use a too short integer type if you have the choice. unsigned int will be appropriate on most 32 and 16 Bit platforms and unsigned char on a typical 8 Bit platform.<br />
 Negligible problems arise on platforms like AVR, where the atomic integer type is shorter than unsigned int. Due to the typedef made here, two integer types are mixed in the implementation without making this transparent by explicit type casts. The implicit type casts still ensure code correctness with one documented exception: The optional diagnostic API functions are now restricted to be used solely in the producer context. However, these functions are not essential and will be switched off in most integrations. We decided to not clean this up by using typedef'ed integers throughout the complete implementation &ndash; this would degrade the readability and maintainability of the code and such systems are anyway not the targeted platforms. </p>

</div>
</div>
<a class="anchor" id="ab9f6c6661870234d09004407a438d5a3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned short int <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ab9f6c6661870234d09004407a438d5a3">uintidx_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>This type is used to store index and size information for queue elements. 16, 32 and even 64 Bit types can be specified. (Where 64 Bit should have no practical relevance.) The appropriate choice is not a really a matter of having a 16 or 32 Bit architecture. Even on 32 Bit embedded platforms, the RAM consumption is an important aspect and the choice can save a significant amount of RAM: The size of header information for each queued element is 4 Byte if a 16 Bit type is configured and 8 Byte for a 32 Bit type. If the alignment for the payload is no more than 4 Byte (almost certain for 32 Bit systems) then this means a RAM reduction of 4 Byte per queued element. This can sum up to several hundreds of Byte for a typical embedded application.}<br />
 Caution, the chosen type must not be larger than unsigned int on the given platform. </p>

</div>
</div>
<a class="anchor" id="a2da01ec229eb5936c0d3b8ea59b09902"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct queueElement_t  queueElement_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formally, this is the type of a queued element. We use a flexible array member to model the payload data. Effectively, this is the heaer of the element, since the payload data is not really inside the struct. The combination of both characteristics is advantageous, we can access the payload by the normal dot operator. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a1e2aa07874ccb589b36b1c0dcedce4a2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Static_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a> &gt;=&#160;</td>
          <td class="paramname"><em>EDE_COMMON_MACHINE_ALIGNMENT</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Suspicious specification of machine alignment&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a73b648a69f1909e1ae0632320ca86570"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getSizeOfQueueHead </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the size of a queue head object.<br />
 This function is meant to be called prior to creation of a queue head object. The caller of the constructor is in charge of allocating the memory for the object - the intended use case of the queue implementation is the embedded environment, which doesn't permit to allocate memory dynamically using <em>malloc</em>. The typical use case avoids the use of <em>malloc:</em> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;const unsigned int sizeOfQHead = vsq_getSizeOfQueueHead();</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;_Alignas(vsq_queueHead_t) char memoryChunk[sizeOfQHead];</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;vsq_queueHead_t *pMyNewQueuesHead = vsq_createQueueHead(memoryChunk);</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;vsq_queueTail_t *pMyNewQueuesTail = ...</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;vsq_linkQueueHeadWithTail(pMyNewQueuesHead, pMyNewQueuesTail);</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;vsq_linkQueueTailWithHead(pMyNewQueuesTail, pMyNewQueuesHead);</div>
</div><!-- fragment --><p> Alternatively, the embedded environment may offer a simple, uncritical memory allocation or partitioning API, most likely without a free function to avoid fragmentation and indeterministic timing behavior. </p><dl class="section return"><dt>Returns</dt><dd>The number of bytes required to construct a queue object with the passed parameters. Only this number is computed, nothing else happens, in particular no queue head object is constructed. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The memory chunk required by the constructor does not only need to have the right minimum size but, secondary, it needs to have the right alignment, which is specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#aac13d5725452aceacfd8ac3b25beeef2">vsq_createQueueHead()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae5e06b4cc00f61cfdc599c195691c816"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getSizeOfQueueTail </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoStdElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfStdElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Calculate the size of a queue tail object.<br />
 This function is meant to be called prior to creation of a queue tail object. The caller of the constructor is in charge of allocating the memory for the object - the intended use case of the queue implementation is the embedded environment, which doesn't permit to allocate memory dynamically using <em>malloc</em>.<br />
 This function needs to be called with the same parameters as later the constructor. The constructor will silently assume that the memory chunk it receives from the caller will have the size computed by this method. The typical use case avoids the use of <em>malloc:</em> </p><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;struct qElement_t;</div>
<div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;#define MAX_Q_LEN 10</div>
<div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;const unsigned int sizeOfQTail = vsq_getSizeOfQueueTail( MAX_Q_LEN</div>
<div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;                                                       , sizeof(struct qElement_t)</div>
<div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;                                                       );</div>
<div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;VSQ_ASSERT(_Alignof(struct qElement_t) &lt;= _Alignof(uintptr_t));</div>
<div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;_Alignas(vsq_queueHead_t) char memoryChunk[sizeOfQTail];</div>
<div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;vsq_queueHead_t *pMyNewQueuesHead = ...</div>
<div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;vsq_queueTail_t *pMyNewQueuesTail = vsq_createQueueTail( memoryChunk</div>
<div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;                                                       , MAX_Q_LEN</div>
<div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;                                                       , sizeof(struct qElement_t)</div>
<div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;                                                       );</div>
<div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;vsq_linkQueueHeadWithTail(pMyNewQueuesHead, pMyNewQueuesTail);</div>
<div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;vsq_linkQueueTailWithHead(pMyNewQueuesTail, pMyNewQueuesHead);</div>
</div><!-- fragment --><p> Alternatively, the embedded environment may offer a simple, uncritical memory allocation or partitioning API, most likely without a free function to avoid fragmentation and indeterministic timing behavior. </p><dl class="section return"><dt>Returns</dt><dd>The number of Byte required to construct a queue tail object with the passed parameters. Only this number is computed, nothing else happens, in particular no queue tail object is constructed.<br />
 If a 16 Bit integer type is used to implement the link indexes for the queue elements, it can happen that the specified capacity of the queue is not realizable. The function returns zero in this case. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">maxNoStdElements</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many elements of given <em>size</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the storable number.<br />
 Rationale: Using a typical standard element size plus a number of those elements as size specification supports the still most relevant use cases with elements of identical size.<br />
 A queue size of zero is considered an error in the client code. This is caught by assertion and zero is returned. <em>maxNoStdElements</em> * <em>sizeOfStdElement</em> needs to be greater than zero. </td></tr>
    <tr><td class="paramname">sizeOfStdElement</td><td>The size of a standard element, which should be storable <em>maxNoStdElements</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caution, the implementation is not made safe against overflows on systems, where type unsigned int is less than 32 Bit. On such systems, you must not rely on the function return value but carefully double-check that the size of the ring buffer doesn't exceed the 64 kByte limit. Actually, this is a bit theoretic as such systems won't ever have so much RAM that this constraint would be relevant. </dd>
<dd>
The function operates without type information but needs to form a list of elements. To safely do so it needs to anticipate the alignment required for such an element. This alignment will later be applied to all contained elements, regardless of their individual size.<br />
 Usually this is the alignment of the largest element type if it are primitive types or the alignment of the largest field in any of the elements if it are structs.<br />
 The required alignment usually is a platform dependent constant and not an application dependent run-time argument. Therefore, it is supplied as macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>, which is part of the compile-time configuration data of this module. You should double-check the setting for your particular platform. </dd>
<dd>
The memory chunk required by the constructor does not only need to have the right minimum size but, secondary, it needs to have the right alignment, which is specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a87232b737d5d9e563391184621f3d619">vsq_createQueueTail()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aac13d5725452aceacfd8ac3b25beeef2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a>* vsq_createQueueHead </td>
          <td>(</td>
          <td class="paramtype">void *const&#160;</td>
          <td class="paramname"><em>pMemoryChunk</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new, still unlinked, still unusable, queue head object. Prior to first use, the head needs to be doubly linked with its communication peer, a queue tail object. See <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> and <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the queue head object. Effectively, this is the same pointer as <em>pMemoryChunk</em> but type casted for use as queue head. If the caller uses dynamic memory management then he may free either his memory chunk or the returned pointer after use of the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemoryChunk</td><td>The caller is in charge of allocating memory for the new queue head object. A memory chunk of required size or bigger is passed in by reference. The required size needs to queried with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a> prior to the call of this constructor.<br />
 Besides the right size, the memory chunk needs to have the right alignment, which is specified at compile-time unsing macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. If you use <em>malloc</em> to allocate the memory chunk than this should normally be granted.<br />
 The correct alignment is double-checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For alignment considerations and constraints, please refer to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a>. </dd>
<dd>
There's no destructor for a queue head object. The caller is responsible for providing the memory for the object and freeing this memory &ndash; if applicable &ndash; would be the only operation to delete a queue head object after use. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a73b648a69f1909e1ae0632320ca86570">vsq_getSizeOfQueueHead()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a87232b737d5d9e563391184621f3d619"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a>* vsq_createQueueTail </td>
          <td>(</td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>pMemoryChunk</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoStdElements</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfStdElement</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a new, still unlinked, still unusable, queue tail object. Prior to first use, the tail needs to be doubly linked with its communication peer, a queue head object. See <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> and <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the queue tail object. Effectively, this is the same pointer as <em>pMemoryChunk</em> but type casted for use as queue. If the caller uses dynamic memory management then he may free either his memory chunk or the returned pointer after use of the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pMemoryChunk</td><td>The caller is in charge of allocating memory for the new queue object. A memory chunk of required size or bigger is passed in by reference. The required size needs to queried with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a> prior to the call of this constructor.<br />
 Besides the right size, the memory chunk needs to have the right alignment, which is specified at compile-time unsing macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. If you use <em>malloc</em> to allocate the memory chunk than this should normally be granted.<br />
 The correct alignment is double-checked by assertion. </td></tr>
    <tr><td class="paramname">maxNoStdElements</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many elements of given size <em>would</em> fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the storable number.<br />
 Rationale: Using a typical standard element size plus a number of those elements as size specification supports the still most relevant use cases with elements of identical size.<br />
 A queue size of zero is considered an error in the client code. This is caught by assertion and NULL is returned. <em>maxNoStdElements</em> * <em>sizeOfStdElement</em> needs to be greater than zero. </td></tr>
    <tr><td class="paramname">sizeOfStdElement</td><td>The size of a standard element, which should be storable <em>maxNoStdElements</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>For alignment considerations and constraints, please refer to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a>. </dd>
<dd>
There's no destructor for a queue object. The caller is responsible for providing the memory for the object and freeing this memory &ndash; if applicable &ndash; would be the only operation to delete a queue tail object after use. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ae5e06b4cc00f61cfdc599c195691c816">vsq_getSizeOfQueueTail()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8cb622a1c7423e6b7f7cbe657670c299"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkQueueHeadWithTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The intended queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the head object and can thus be used by the same process that created the head object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> will do the same for the tail object and from another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTheQueuesHead</td><td>The newly created queue head object, which is now linked to its tail. </td></tr>
    <tr><td class="paramname">pTheQueuesTail</td><td>This is the tail object, * <em>pTheQueuesHead</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000003">Todo:</a></b></dt><dd>Do we need a memory barrier somewhere here? And in the counterpart? </dd></dl>

</div>
</div>
<a class="anchor" id="a3c25adfaa1191482b13867dd12cc0479"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkQueueTailWithHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pTheQueuesHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The intended queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the tail object and can thus be used by the same process that created the tail object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> will do the same for the head object and from another process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pTheQueuesTail</td><td>The newly created queue tail object, which is now linked to its head. </td></tr>
    <tr><td class="paramname">pTheQueuesHead</td><td>This is the head object, * <em>pTheQueuesTail</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad36860a03cf15b51113117779b840edc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_writeToTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Append a new element to the tail of the queue. </p><dl class="section return"><dt>Returns</dt><dd>The operation can fail; the queue is implemented with a pre-determined maximum size and it can be currently full. Get <em>true</em> if the operation succeeds and <em>false</em> in case of a currently full queue.<br />
 The elements themselves have a flexible size. The function will return <em>false</em> if the caller tries to write more bytes than currently fit into the queue. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object to write to by reference. </td></tr>
    <tr><td class="paramname">pData</td><td>The pointer to the payload data of the appended element. This is an anonymous byte sequence to this method. memcpy is used to copy the data into the queue, which imposes no alignment requirements on the data. </td></tr>
    <tr><td class="paramname">noBytes</td><td>The number of bytes to write.<br />
 No data will be copied to the queue if the function returns <em>false</em>.<br />
 Note, it is valid to append an empty element. The related later call of <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1c7e5c2548db4df5322c765805186d6b">vsq_readFromHead()</a> will return a non-NULL data pointer in combination with a number of zero bytes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ac824504a0b8e9ee527210d902586a62b">vsq_allocTailElement()</a> </dd>
<dd>
<a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a1c7e5c2548db4df5322c765805186d6b">vsq_readFromHead()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac824504a0b8e9ee527210d902586a62b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* vsq_allocTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Check if the queue has currently room to append another element to the tail and return the available element in case.<br />
 This method, together with the other method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a51d57a5cd793bce550a438ae539f7e48">vsq_postTailElement()</a>, is an alternative API to write to the end of the queue. If <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ac824504a0b8e9ee527210d902586a62b">vsq_allocTailElement()</a> returns a non NULL pointer then the caller can take any time to fill the queue element the return value points to without fearing any race conditions. After having the element filled he will use <em>vsq_postTailElement</em> to submit the element. From now on the element will be visible to the consumer at the end of the queue.<br />
 Using this API in contrast to <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> can save a local copy of the produced data in the producers implementation.<br />
 The producer APIs to access the tail of the queue are not race condition free. A call of <em>vsq_writeToTail</em> must either<br />
</p><ul>
<li>return before the next call of the same method or<br />
</li>
<li>return before the invocation of <em>vsq_allocTailElement</em> or<br />
</li>
<li>be initiated after return from <em>vsq_postTailElement</em>.</li>
</ul>
<p>This means for a single producer context, that it can alternatingly use <em>vsq_writeToTail</em> and the pair of <em>vsq_allocTailElement</em> and <em>vsq_postTailElement</em>. For concurrent producer contexts it imposes the need for the implementation of mutual exclusion code at the caller's side. </p><dl class="section return"><dt>Returns</dt><dd>Get either the next available ring buffer element by reference or NULL if the queue is currently full.<br />
 The returned pointer is aligned as had been specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer. There is no time limit in keeping the pointer (i.e. until data submission with <em>vsq_postTailElement</em>) and using the pointer can avoid the need for an additional local copy of the data during data production time. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object by reference. </td></tr>
    <tr><td class="paramname">sizeOfPayload</td><td>The size of the payload of the appended element in Byte. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The calls of <em>vsq_allocTailElement</em> and <em>vsq_postTailElement</em> need to be done strictly alternatingly. It is not possible to reserve several elements by multiple calls of the former method and to submit them later by the same number of calls of the latter method. </dd>
<dd>
It is possible to use this method prior to <em>vsq_writeToTail</em> to query if the queue is currently full and to avoid a negative return value of that function. It's however disencouraged to do so. There is a little useless computation overhead in doing so and, more important, the pair of <em>vsq_allocTailElement</em> and <em>vsq_writeToTail</em> is not race condition free; a queue element could become free between the two calls &ndash; the strategy would be too conservative. </dd></dl>

</div>
</div>
<a class="anchor" id="a51d57a5cd793bce550a438ae539f7e48"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_postTailElement </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Submit a queue element, which had been allocated with <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ac824504a0b8e9ee527210d902586a62b">vsq_allocTailElement()</a>.<br />
 From now on, the element is in the queue and visible to the consumer. The pointer, which had been got from <em>vsq_allocTailElement</em> is invalid and must no longer be used.<br />
 Please, find more details of using this API in the description of the counterpart method <em>vsq_allocTailElement</em>. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object, where the submitted element had been allocated. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd>void *vsq_allocTailElement() </dd></dl>

</div>
</div>
<a class="anchor" id="a1c7e5c2548db4df5322c765805186d6b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* vsq_readFromHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a70b9f89da1ce38f2707de95e5be9a434">vsq_queueHead_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *const&#160;</td>
          <td class="paramname"><em>pSizeOfPayload</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Read a meanwhile receivced new element from the head of the queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the newly received element if a new element has arrived. <em>NULL</em> is returned if no new element has been received since the previous invocation of this method.<br />
 The element, which is returned by reference is from now on owned by the data consumer, i.e. the caller of this method. It may use the pointer to read the data. The ownership only ends by getting another pointer to another element with a future invocation of this method. In particular, it does not end when a future call of this method returns <em>NULL</em>. The access to the owned element is race condition free for the owner of the pointer.<br />
 The returned pointer is aligned as had been specified at compile-time using macro <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a2a8b308e8fb332945247df48f5f4094f">ALIGN_OF_PAYLOAD</a>. The returned pointer can be safely casted to the element type and access to the element (or its fields in case of a struct) can be done through this pointer without the need for first copying the data. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueHead</td><td>The queue object to be read from by reference. </td></tr>
    <tr><td class="paramname">pSizeOfPayload</td><td>The number of bytes, which are conveyed with the received element, is returned by reference. It is the same value as had been provided to the related call of either <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> or <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ac824504a0b8e9ee527210d902586a62b">vsq_allocTailElement()</a>.<br />
 The value is set to zero if the function returns NULL.<br />
 Note, queued elements of size zero are allowed and possible. In which case, the value is set to zero, too; howeber, now the function won't return NULL.<br />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The consumer API is not reentrant. It is not possible to let concurrent consumer contexts read from the head of the queue. This holds even if the consumer code implements synchronization code, which ensures mutual exclusion from this method. This is because the method's effect persists after return from the method; the returned element is reserved to the caller until the next method invocation. </dd></dl>
<dl class="section see"><dt>See also</dt><dd>bool <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> </dd></dl>

</div>
</div>
<a class="anchor" id="abe6dbe47e4b1c7a9cb8b7853b277c321"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_getIsCommunicationBroken </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>On each queueing of an element, the sender process double-checks if the memories of the receiver process are still valid (as far as the communication via this queue is concerned). It sets a flag in case of not valid. Then the communication is broken until the receiver is re-synchronized (see <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a9e8d41171ada0245a5a64274d4057f5f">vsq_acknReSyncHead()</a>). This method queries the communication state. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> if communication is alright. If <em>true</em> is returned then no more elements can be queued until the receiver has been re-synchronized. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9e8d41171ada0245a5a64274d4057f5f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_acknReSyncHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>If the sender had detected and reported a broken communication situation due to corrupted receiver memories then the queue operation is blocked also for the sender until the receiver has been re-synchronized. This is done &ndash; after general recover of the receiver process &ndash; by again calling method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> from the receiver process and acknowledging success to the sender.<br />
 The complexity of re-synchronization is the asynchronity of sender and receiver and their memory access rights. The entire mechanism is useful only in environments, where the receiver process' memories cannot be written from the sender process. It'll always be a matter of inter-process communication to complete the re-synchronization. This can be implemented only in some platform specific external code:</p><ol type="1">
<li>Receiver process needs to generally recover from its problems</li>
<li>Receiver process needs to invoke method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a>. This requires the address of the tail object - if it is lost due to the data corruption then the sender process will have to provide it again</li>
<li>Receiver process needs to notify completion of invocation of <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> to the sender process. From this point in time on, it may again check its queue head for newly received elements. Initially, there won't be any</li>
<li>The sender process needs to call method <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a9e8d41171ada0245a5a64274d4057f5f">vsq_acknReSyncHead()</a> in order to acknowledge the re-synchonization to the queue logic. From now on, the queue operation is re-enabled for the sender. The next call of alloc/post or <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#ad36860a03cf15b51113117779b840edc">vsq_writeToTail()</a> will succeed again and it'll queue the first element the receiver will get again after re-synchronization. <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, which is re-sychronized. </td></tr>
    <tr><td class="paramname">keyForReSync</td><td>The key for resynchronization, which had been got from a call of <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#abe6dbe47e4b1c7a9cb8b7853b277c321">vsq_getIsCommunicationBroken()</a> in the sender process. </td></tr>
  </table>
  </dd>
</dl>
</li>
</ol>

</div>
</div>
<a class="anchor" id="a47cbd5cd96591a5d2fbff5c468203509"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getMaximumQueueUsage </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum number of queued elements, which has been seen since creation of the queue object. </p><dl class="section return"><dt>Returns</dt><dd>Get the number of elements. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The tail object of the queue by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The compilation of this API can be turned on/off by configuration switch <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a585323d744ee693146dd7b674213fc60">VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd>
<dd>
This method my be called at any time from producer or conumer context. </dd></dl>

</div>
</div>
<a class="anchor" id="a0b9117fd3075fcdd83a0937129d870ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int vsq_getMaximumQueueUsageInByte </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a28ef93f75fff4c3b380a1729a45aa9c8">vsq_queueTail_t</a> *const&#160;</td>
          <td class="paramname"><em>pQueueTail</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the maximum use of buffer memory, which has been seen since creation of the queue object.<br />
 Note, the variable element size implies, that the queue potentially can't make use of all memory. This is even normal and not an extraordinary situation. Consequently, if the reported memory consumption is less than the configured memory, it doesn't necessarily mean the the queue was never full. </p><dl class="section return"><dt>Returns</dt><dd>Get the number in Byte. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pQueueTail</td><td>The queue object by reference, to which the query relates. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The compilation of this API can be turned on/off by configuration switch <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html#a585323d744ee693146dd7b674213fc60">VSQ_ENABLE_API_QUEUE_DIAGNOSTICS</a>. </dd>
<dd>
This method my be called at any time from producer or conumer context. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_083cb9b71a0904a1342a47f5208adb1c.html">connectors</a></li><li class="navelem"><a class="el" href="vsq__thread_safe_queue_variable_size_8c.html">vsq_threadSafeQueueVariableSize.c</a></li>
    <li class="footer">Generated on Fri Feb 18 2022 19:44:45 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
