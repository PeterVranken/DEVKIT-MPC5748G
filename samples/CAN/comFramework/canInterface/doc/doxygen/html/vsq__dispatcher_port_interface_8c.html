<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: vsq_dispatcherPortInterface.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('vsq__dispatcher_port_interface_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">vsq_dispatcherPortInterface.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="vsq__dispatcher_port_interface_8h_source.html">vsq_dispatcherPortInterface.h</a>&quot;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ede__basic_definitions_8h_source.html">ede_basicDefinitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="vsq__thread_safe_queue_variable_size_8h_source.html">vsq_threadSafeQueueVariableSize.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a852ed9626db583faa703c9041132799f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8c.html#a852ed9626db583faa703c9041132799f">vsq_createEventQueueHead</a> (<a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *pPortHead, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolHead)</td></tr>
<tr class="separator:a852ed9626db583faa703c9041132799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf9117372229fabddc581075c95a568"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8c.html#aecf9117372229fabddc581075c95a568">vsq_createEventQueueTail</a> (<a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *pPortTail, unsigned int maxQueueLength, unsigned int maxPayloadSize, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolTail)</td></tr>
<tr class="separator:aecf9117372229fabddc581075c95a568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f009be1515bb07783a256132da7011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8c.html#a20f009be1515bb07783a256132da7011">vsq_linkEventQueueHeadWithTail</a> (const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> portHead, const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portTail)</td></tr>
<tr class="separator:a20f009be1515bb07783a256132da7011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a47e3a7c7fcb69093ceb5198f8627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8c.html#ae95a47e3a7c7fcb69093ceb5198f8627">vsq_linkEventQueueTailWithHead</a> (const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portTail, const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> portHead)</td></tr>
<tr class="separator:ae95a47e3a7c7fcb69093ceb5198f8627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a48c782da13efd442ea5c208afc3b3c85"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue</a> (<a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *pPortHead, <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *pPortTail, unsigned int maxQueueLength, unsigned int maxPayloadSize, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolHead, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolTail)</td></tr>
<tr class="separator:a48c782da13efd442ea5c208afc3b3c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>This module supports the use of the thread-safe queue as connection element between sender and dispatcher in the event dispatcher mechanism. The event dispatcher mechanism specifies the interfaces of the ports of sender and dispatcher and this module provides the queue API in the form of instances of those ports.<br />
 This module does not belong to the generic queue implementation and won't be usable outside the context of the event dispatcher mechanism.</p>
<p>Copyright (C) 2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a852ed9626db583faa703c9041132799f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueueHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create the head object of a thread-safe queue with variable element size for external dispatcher events and return it as a port, which provide access to the head of the queue. The port is compliant with the port interface of the dispatcher from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortHead</td><td>If the function returns <em>true</em>, then a port object, which provides access to the head of the queue for fetching queued elements, has been placed into * <em>pPortHead</em>. </td></tr>
    <tr><td class="paramname">pMemPoolHead</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the head of the queue, i.e., for fetching queued elements.<br />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue tail to queue elements, needs to have at least read access to the memory from this pool, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates the complete quene, including both ports - all in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="aecf9117372229fabddc581075c95a568"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueueTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a thread-safe queue with variable element size for external dispatcher events and return it as a port, which provides access to the tail of the queue. The port is compliant with the port interfaces of the sender from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortTail</td><td>If the function returns <em>true</em>, then a port object, which provides access to the tail of the queue for adding elements, has been placed into * <em>pPortTail</em>. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many events with a payload of <em>sizeOfPayload</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the actually storable number.<br />
 A queue length of zero is considered an error in the client code. This is caught by assertion and <em>false</em> is returned. </td></tr>
    <tr><td class="paramname">sizeOfPayload</td><td>The size of the payload of a queued standard event, which should be storable <em>maxQueueLength</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
    <tr><td class="paramname">pMemPoolTail</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the tail of the queue, i.e., for queueing elements.<br />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue head to fetch queued elements, needs to have at least read access to the memory from this pool, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates the complete quene, including both ports - all in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="a20f009be1515bb07783a256132da7011"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkEventQueueHeadWithTail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a>&#160;</td>
          <td class="paramname"><em>portHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A new event queue's tail and head objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the head object and can thus be used by the same process that created the head object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> will do the same for the tail object and from another process.<br />
 Note, this function is just the same as <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> but for port objects as used in the dispatcher engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portHead</td><td>The newly created queue head port object, which is now linked to its tail. </td></tr>
    <tr><td class="paramname">portTail</td><td>This is the tail port object, * <em>portHead</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates both ports, head and tail, and links them - all in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="ae95a47e3a7c7fcb69093ceb5198f8627"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkEventQueueTailWithHead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a>&#160;</td>
          <td class="paramname"><em>portHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A new event queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the tail object and can thus be used by the same process that created the tail object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> will do the same for the head object and from another process.<br />
 Note, this function is just the same as <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> but for port objects as used in the dispatcher engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portTail</td><td>The newly created queue tail port object, which is now linked to its head. </td></tr>
    <tr><td class="paramname">portHead</td><td>This is the head port object, * <em>portTail</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates both ports, head and tail, and links them - all in one call. </dd></dl>

</div>
</div>
<a class="anchor" id="a48c782da13efd442ea5c208afc3b3c85"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a thread-safe queue with variable element size for external dispatcher events and return it as pair of ports, which provide access to head and tail of the queue. The ports are compliant with the port interfaces of sender and dispatcher from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortHead</td><td>If the function returns <em>true</em>, then a port object, which provides access to the head of the queue for fetching queued elements, has been placed into * <em>pPortHead</em>. </td></tr>
    <tr><td class="paramname">pPortTail</td><td>If the function returns <em>true</em>, then a port object, which provides access to the tail of the queue for adding elements, has been placed into * <em>pPortTail</em>. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many events with a payload of <em>sizeOfPayload</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the actually storable number.<br />
 A queue length of zero is considered an error in the client code. This is caught by assertion and <em>false</em> is returned. </td></tr>
    <tr><td class="paramname">sizeOfPayload</td><td>The size of the payload of a queued standard event, which should be storable <em>maxQueueLength</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
    <tr><td class="paramname">pMemPoolHead</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the head of the queue, i.e., for fetching queued elements.<br />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue tail to queue elements, needs to have at least read access to the memory from this pool. </td></tr>
    <tr><td class="paramname">pMemPoolTail</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the tail of the queue, i.e., for queueing elements.<br />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue head to fetch queued elements, needs to have at least read access to the memory from this pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The creation of a complete, ready-to-use queue object requires initialization of both, head and tail object. Therefore, the caller of this routine needs to have write access to the memory from both memory pools. In memory protected environments, this will normally be only a supervisor context! </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_083cb9b71a0904a1342a47f5208adb1c.html">connectors</a></li><li class="navelem"><a class="el" href="vsq__dispatcher_port_interface_8c.html">vsq_dispatcherPortInterface.c</a></li>
    <li class="footer">Generated on Fri Feb 18 2022 19:44:45 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
