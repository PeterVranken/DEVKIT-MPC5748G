<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>comFramework - CAN Interface: ede_eventSender.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">comFramework - CAN Interface<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('ede__event_sender_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">ede_eventSender.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__event_sender_8h_source.html">ede_eventSender.h</a>&quot;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__event_dispatcher_engine_8h_source.html">ede_eventDispatcherEngine.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a3ced2f8d5ec2344cfaeadc4c4b986a05"><td class="memItemLeft" align="right" valign="top">typedef struct ede_eventSender_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a></td></tr>
<tr class="separator:a3ced2f8d5ec2344cfaeadc4c4b986a05"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a427a4fb0c358294d426691783d816f31"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender</a> (<a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> *const pHandleSender, const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portAry[], unsigned int noPorts, const <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *pMapSenderEvHandleToPortIndex, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolSender)</td></tr>
<tr class="separator:a427a4fb0c358294d426691783d816f31"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab798e6f0c026481f4848e52207136aac"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:ab798e6f0c026481f4848e52207136aac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af784c1f528d120e096159eedfc7a6083"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort</a> (<a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const hSender, unsigned int idxPort, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, const void *pData, unsigned int sizeOfData)</td></tr>
<tr class="separator:af784c1f528d120e096159eedfc7a6083"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0d19cf302860504824ac3749a075d23f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_sender_8c.html#a0d19cf302860504824ac3749a075d23f">ede_getNoSenderPortBlockedEvents</a> (<a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> hSender, unsigned int idxPort)</td></tr>
<tr class="separator:a0d19cf302860504824ac3749a075d23f"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Implementation of the event sender. Any number of senders can be created and they can be flexibly connected to an unrelated set of dispatchers. n:m connectivity is supported.</p>
<p >Copyright (C) 2021-2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a3ced2f8d5ec2344cfaeadc4c4b986a05" name="a3ced2f8d5ec2344cfaeadc4c4b986a05"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3ced2f8d5ec2344cfaeadc4c4b986a05">&#9670;&nbsp;</a></span>ede_eventSender_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ede_eventSender_t ede_eventSender_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000005">Todo:</a></b></dt><dd>The API of a sender port splits sending a data packet into buffer allocation and submission. There are a lot of use cases, where this two-step paradigm saves us payload copying. (Data can instead be directly produced inside the allocated buffer.) This advantage is lost when using the sender object, which offers just the one-step "post". The two-step approach should become an optionally applied additional sender API. </dd></dl>
<p>An event sender object. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a427a4fb0c358294d426691783d816f31" name="a427a4fb0c358294d426691783d816f31"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a427a4fb0c358294d426691783d816f31">&#9670;&nbsp;</a></span>ede_createSender()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_createSender </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandleSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portAry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noPorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> *&#160;</td>
          <td class="paramname"><em>pMapSenderEvHandleToPortIndex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolSender</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a sender.<br  />
 A sender has n output ports and it can be connected to n dispatchers. Main API of a sender is <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a>, which sends an event to the connetced dispatcher input. The exact behavior depends on the element, which is applied to make the connection between the sender's output port and the dispatcher's input port. This will normally be a queue but can be any other connecting operation, which implements the given interface. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the new sender could be created and <em>false</em> otherwise.<br  />
 The function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. If the assertion doesn't fire throughout the development and test phase then it won't in the production code. Anyhow, the sender must never be used if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandleSender</td><td>Get the handle of the newly created sender object by reference. This handle is later needed to use the sender. If the function fails then it'll return the special handle <a class="el" href="ede__event_sender_8h.html#a05ef25fbdb9c94224bb049c897fe4cec">EDE_INVALID_SENDER_HANDLE</a> in * <em>pHandleSender</em>.<br  />
</td></tr>
    <tr><td class="paramname">portAry</td><td>All ports of the sender as an array of objects, which implement the given interface. Each port may use the same or another implementation of the interface. Normally, the implementation of the interface will be the tail of the thread-safe queue, see <a class="el" href="vsq__thread_safe_queue_variable_size_8h.html">vsq_threadSafeQueueVariableSize.h</a>, which belongs to this package.<br  />
 The array elements are copied and portAry needs to be valid only during the run time of the constructor. </td></tr>
    <tr><td class="paramname">noPorts</td><td>The number of supported ports and the number of elements in portAry at the same time. </td></tr>
    <tr><td class="paramname">pMapSenderEvHandleToPortIndex</td><td>The (externally implemented) map by reference, which associates the abstract handle of an external event with the output port to use for th given event(by index).<br  />
 If the sender has just one port then no mapping is required and NULL can be passed. All events will go into the only port. Note, a map still matters for a sender with a single port: A map now becomes a Boolean filter, whether or not an event may or can be posted.<br  />
 If only method <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a> is going to be used to send an event, i.e., method <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> won't be used, then NULL can be passed even for a sender with more than one port. </td></tr>
    <tr><td class="paramname">pMemPoolSender</td><td>A memory pool by reference, which provides the memory needed for construction of the sender object.<br  />
 The memory dealt out by this pool needs to grant write-access to the context that runs the event posting process, i.e., the process, which is going to regularly call ede_sendEvent() for the here created sender object. All other contexts (e.g. dispatchers or other senders) don't need access to the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function has to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platforms will offer an initialization task for this purpose. </dd></dl>

</div>
</div>
<a id="ab798e6f0c026481f4848e52207136aac" name="ab798e6f0c026481f4848e52207136aac"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab798e6f0c026481f4848e52207136aac">&#9670;&nbsp;</a></span>ede_postEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_postEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event is posted. It is sent via the associated sender's port.<br  />
 This function is invoked by the integration code. In the case of CAN communication, the call is typically used from within a CAN interrupt handler. The posted event normally is a frame reception event or a frame send acknowledge event. Generally, the kind of postable events depends on the platform and the integration.<br  />
 The event is posted to the port, which is named by the map that had been agreed on during construction of the sender. This indirect port selection has been defined in order to allow the external intergration code to specify the connectivity still at run time. As an example, and for CAN communication, the external code could decide for each particular CAN message, whether it is processed by the QM code or by the safety code. If this flexibility is not required then the other API <a class="el" href="ede__event_sender_8c.html#af784c1f528d120e096159eedfc7a6083">ede_postEventToPort()</a> can be used.<br  />
 The meaning of an event is widely transparent to sender and dispatcher. The event is identified by two values of basic integral data type. The first value is the "kind of
event" and this will be an enumeration. The only constraint sender and dispatcher put on this value are a few numeric values, which are reserved for internal purpose; see <a class="el" href="ede__event_dispatcher_engine_8h.html#a47c207ede4c03db1627850da02b67e68">EDE_EV_KIND_LAST</a> for details. The second value is a handle or ID of the event. Use and meaning of this value are unconstrained and fully transparant to sender and dispatcher. Having two value to identify an event means that each kind of event has its own handle space; this has been decide to support heterogenous events. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. For most imaginable implementations of the port interface, it'll be possible that the port is currently not able to process a new event, e.g., because of a queue full state. In this case, the event is entirely ignored (besides reporting the port-blocked event). </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is an enumeration, which is meaningless to the sender or dispatcher object. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which eventually evaluates the transmitted events. In the case of CAN communication, this will e.g. be the CAN message reception event. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code. In the case of CAN communication, this will e.g. be the operating system's handle of a registered CAN message. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data, which is meaningless to the sender and dispatcher object. Typically used to convey CAN message content bytes in case of a reception event, but can be anything else. May be NULL if <em>sizeOfData</em> is zero, too. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes, i.e., the number of bytes, <em>pData</em> points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Posting an event to a particular port of the sender is not reentrant. If event sources running in different CPU contexts are posting to one and the same sender port then the integration code needs to implement mutual exclusion. All of these event sources need to be serialized with respect to event posting.<br  />
 In practice, concurrent event sources that require mutual exclusion will likely occur if the events are reported by different interrupts; different interrupts have different priorities on most existing systems and interrupts of higher priority are normally allowed to preempt those of lower priority. In this situation, a reasonable alternative to explicit mutual exclusion code is an architecture using another interconnected pair of sender and and dispatcher port for each interrupt. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000006">Todo:</a></b></dt><dd>Should this be counted like a lost event due to buffer full? </dd></dl>

</div>
</div>
<a id="af784c1f528d120e096159eedfc7a6083" name="af784c1f528d120e096159eedfc7a6083"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af784c1f528d120e096159eedfc7a6083">&#9670;&nbsp;</a></span>ede_postEventToPort()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_postEventToPort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8c.html#a3ced2f8d5ec2344cfaeadc4c4b986a05">ede_eventSender_t</a> *const&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>pData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event is posted. It is sent via the explicitly stated sender's port.<br  />
 See other API <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> for more details. The only difference between both functions is the way, the port to use is selected. </p><dl class="section return"><dt>Returns</dt><dd><em>true</em>, if function succeeded, else <em>false</em>. The event has been sent and will be delivered to the dispatcher only if the function returns <em>true</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object to use. Has been created before by <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a>. </td></tr>
    <tr><td class="paramname">idxPort</td><td>The port to be applied for the event by zero based index. The specified number must not be greater or equal to argument <em>noPorts</em> of the constructor call, which yielded <em>hSender</em>. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is an enumeration, which is meaningless to connector element and dispatcher engine. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code system. In the case of CAN communication, this will e.g. be the operating system's handle of a registered CAN message. </td></tr>
    <tr><td class="paramname">pData</td><td>A pointer to some event data. It is delivered to the dispatcher as part of the event. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The number of data bytes, i.e., the number of bytes, <em>pData</em> points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>All remarks made for <a class="el" href="ede__event_sender_8c.html#ab798e6f0c026481f4848e52207136aac">ede_postEvent()</a> hold for this function, too. </dd></dl>

</div>
</div>
<a id="a0d19cf302860504824ac3749a075d23f" name="a0d19cf302860504824ac3749a075d23f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d19cf302860504824ac3749a075d23f">&#9670;&nbsp;</a></span>ede_getNoSenderPortBlockedEvents()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a124b7daa71a5d329213c459f68203f89">ede_atomicUnsignedInt_t</a> ede_getNoSenderPortBlockedEvents </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_sender_8h.html#aab46fbce36a9ae7c406ff72f2b4ac149">ede_handleSender_t</a>&#160;</td>
          <td class="paramname"><em>hSender</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxPort</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of recorded port-blocked events, i.e. the number of lost events due to an currently unavailable port, e.g. because of an overfull queue. </p><dl class="section return"><dt>Returns</dt><dd>Get the number, which should should rise very slowly or not at all in case of a well designed implementation of the port interface. The counter for port-blocked events wraps at its implementation range. Therefore, the client code can easliy check for an allowed maximum loss rate by regularly evaluating the delta/increment of the returned function value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hSender</td><td>The sender object, which the query is made for. </td></tr>
    <tr><td class="paramname">idxPort</td><td>The port, which the query is made for, by zero based index. The specified number must not be greater or equal to argument <em>noPorts</em> of the constructor call, which yielded <em>hSender</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function can be called at any time from any context, which has read access to the memory, which had been used for construction of the sender object; see argument <em>pMemPoolSender</em> of <a class="el" href="ede__event_sender_8c.html#a427a4fb0c358294d426691783d816f31">ede_createSender()</a> for details. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_081dba3b7b2444bc5b95b682ee9f194a.html">eventDispatcher</a></li><li class="navelem"><a class="el" href="ede__event_sender_8c.html">ede_eventSender.c</a></li>
    <li class="footer">Generated on Tue Oct 4 2022 15:29:09 for comFramework - CAN Interface by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
