<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.8"/>
<title>comFramework-CANInterface: ede_eventDispatcherEngine.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">comFramework-CANInterface
   &#160;<span id="projectnumber">1.5</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.8 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('ede__event_dispatcher_engine_8c.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">ede_eventDispatcherEngine.c File Reference</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__event_dispatcher_engine_8h_source.html">ede_eventDispatcherEngine.h</a>&quot;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;string.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &quot;<a class="el" href="vsq__thread_safe_queue_variable_size_8h_source.html">vsq_threadSafeQueueVariableSize.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:ae08f7606e166bbb77d0d10596eeb94f5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ae08f7606e166bbb77d0d10596eeb94f5">TIMER_STATE_SINGLE_SHOT</a>&#160;&#160;&#160;(0)</td></tr>
<tr class="separator:ae08f7606e166bbb77d0d10596eeb94f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63cb29b921ea84e61ea662a74390d667"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a63cb29b921ea84e61ea662a74390d667">TIMER_STATE_SINGLE_SHOT_AUTO_KILL</a>&#160;&#160;&#160;(-1)</td></tr>
<tr class="separator:a63cb29b921ea84e61ea662a74390d667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a66e094a1460f371bf6407f91afe9919b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a66e094a1460f371bf6407f91afe9919b">TIMER_STATE_SINGLE_SHOT_SUSPENDED</a>&#160;&#160;&#160;(-2)</td></tr>
<tr class="separator:a66e094a1460f371bf6407f91afe9919b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad04c6c784c9e2233898108b0c6ebfd59"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ad04c6c784c9e2233898108b0c6ebfd59">TIMER_STATE_KILLED</a>&#160;&#160;&#160;(-3)</td></tr>
<tr class="separator:ad04c6c784c9e2233898108b0c6ebfd59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20b49b55678bd229a5a4fd324a019c21"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(c, m)&#160;&#160;&#160;sizeof(((const c*)NULL)-&gt;m)</td></tr>
<tr class="separator:a20b49b55678bd229a5a4fd324a019c21"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09d1cb20cec1bbe341cf91ba32d1c964"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a09d1cb20cec1bbe341cf91ba32d1c964">INVALID_DISPATCHER_HANDLE</a>&#160;&#160;&#160;NULL</td></tr>
<tr class="separator:a09d1cb20cec1bbe341cf91ba32d1c964"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aca0c655f3fe403fb6a024efc5cf8fa52"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak" />
ede_dispatcherSystem_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#aca0c655f3fe403fb6a024efc5cf8fa52">ede_dispatcherSystem_t</a></td></tr>
<tr class="separator:aca0c655f3fe403fb6a024efc5cf8fa52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7b8ada5a56ea28293ae25dd4fa43ab90"><td class="memItemLeft" align="right" valign="top">typedef struct <br class="typebreak" />
ede_eventDispatcher_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a7b8ada5a56ea28293ae25dd4fa43ab90">ede_eventDispatcher_t</a></td></tr>
<tr class="separator:a7b8ada5a56ea28293ae25dd4fa43ab90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2940b23e2877f7abcd389c7a7e812896"><td class="memItemLeft" align="right" valign="top">typedef struct eventSrc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a></td></tr>
<tr class="separator:a2940b23e2877f7abcd389c7a7e812896"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60251d57ef6ad3972549eb3bf01345de"><td class="memItemLeft" align="right" valign="top">typedef struct eventSrcExt_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a></td></tr>
<tr class="separator:a60251d57ef6ad3972549eb3bf01345de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abeaaaa3e9114acf72faa9398e06286c7"><td class="memItemLeft" align="right" valign="top">typedef union ptrToEvtSrc_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a></td></tr>
<tr class="separator:abeaaaa3e9114acf72faa9398e06286c7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9f8986a97b4d0b117d772f1c799ca52a"><td class="memItemLeft" align="right" valign="top">typedef struct ede_timer_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a9f8986a97b4d0b117d772f1c799ca52a">timer_t</a></td></tr>
<tr class="separator:a9f8986a97b4d0b117d772f1c799ca52a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0ef7bd37f26407c9b1ddefac14a4aace"><td class="memItemLeft" align="right" valign="top">typedef struct event_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a0ef7bd37f26407c9b1ddefac14a4aace">event_t</a></td></tr>
<tr class="separator:a0ef7bd37f26407c9b1ddefac14a4aace"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ae8e2baa029b22ce38d5d937844f8b189"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ae8e2baa029b22ce38d5d937844f8b189">_Static_assert</a> (offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>, refEventSrcData)==offsetof(struct <a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>, refEventSrcData)&amp;&amp;<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>, refEventSrcData)==<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(struct <a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>, refEventSrcData)&amp;&amp;sizeof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>)==offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>, callback),&quot;Construction of extended class definition is bad&quot;)</td></tr>
<tr class="separator:ae8e2baa029b22ce38d5d937844f8b189"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a61ed1519c7fb4bd6c422e3b2f88d102f"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a61ed1519c7fb4bd6c422e3b2f88d102f">_Static_assert</a> (offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>, ext)==offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>, base)&amp;&amp;<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>, ext)==<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>, base)&amp;&amp;sizeof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>)==sizeof(void *),&quot;Construction of extended class definition is bad&quot;)</td></tr>
<tr class="separator:a61ed1519c7fb4bd6c422e3b2f88d102f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa40169333aa1715af8ff4e68e86a7fb"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#aaa40169333aa1715af8ff4e68e86a7fb">_Static_assert</a> (<a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a550231c7d9af9163faba9a68d9e1df75">EDE_COMMON_MACHINE_ALIGNMENT</a> &gt;=_Alignof(uintptr_t)||<a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a550231c7d9af9163faba9a68d9e1df75">EDE_COMMON_MACHINE_ALIGNMENT</a>==1u||EDE_COMMON_MACHINE_ALIGNMENT==2u||EDE_COMMON_MACHINE_ALIGNMENT==4u||EDE_COMMON_MACHINE_ALIGNMENT==8u||EDE_COMMON_MACHINE_ALIGNMENT==16u,&quot;Bad configuration of alignment&quot;)</td></tr>
<tr class="separator:aaa40169333aa1715af8ff4e68e86a7fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f6cb6a9250a5f4ff0076a4e56b19e40"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a4f6cb6a9250a5f4ff0076a4e56b19e40">ede_createDispatcherSystem</a> (<a class="el" href="ede__event_dispatcher_engine_8h.html#a0cb1fc00f09a5921434b9da748eb44d9">ede_handleDispatcherSystem_t</a> *const pHandleDispSystem, unsigned int noEventDispatcherEngines, unsigned int maxNoEventSourcesExt, unsigned int maxNoEventSourcesInt, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolDispatchingProcess)</td></tr>
<tr class="separator:a4f6cb6a9250a5f4ff0076a4e56b19e40"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5cf8525218dded99c9b1688aa2ac53e5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher</a> (<a class="el" href="ede__event_dispatcher_engine_8c.html#aca0c655f3fe403fb6a024efc5cf8fa52">ede_dispatcherSystem_t</a> *const pSys, unsigned int idxDispatcher, signed int tiTick, <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> portAry[], unsigned int noPorts, <a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a> mapSdrEvHdlToEdeEvSrcIdx)</td></tr>
<tr class="separator:a5cf8525218dded99c9b1688aa2ac53e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a094049b2a8687b18a16778faa8f5fd00"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource</a> (<a class="el" href="ede__event_dispatcher_engine_8h.html#a0cb1fc00f09a5921434b9da748eb44d9">ede_handleDispatcherSystem_t</a> const hDispatcherSystem, unsigned int idxDispatcher, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> kindOfEvent, <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a> senderHandleEvent, <a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> callback, uintptr_t refEventSourceData)</td></tr>
<tr class="separator:a094049b2a8687b18a16778faa8f5fd00"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad58d14d5107064bdfcce3c2be2f600f9"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ad58d14d5107064bdfcce3c2be2f600f9">ede_registerInternalEventSource</a> (<a class="el" href="ede__event_dispatcher_engine_8c.html#aca0c655f3fe403fb6a024efc5cf8fa52">ede_dispatcherSystem_t</a> *const pSystem, unsigned int idxDispatcher, <a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> callback, uintptr_t refEventSourceData)</td></tr>
<tr class="separator:ad58d14d5107064bdfcce3c2be2f600f9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92423b842e575d300f2128781b88fde4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain</a> (<a class="el" href="ede__event_dispatcher_engine_8h.html#aa57c811b7b1b41219c699d9d6652a121">ede_handleConstDispatcherSystem_t</a> const hDispatcherSystem, unsigned int idxDispatcher)</td></tr>
<tr class="separator:a92423b842e575d300f2128781b88fde4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23d83e118d5b270be853ff99c1b3c199"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a23d83e118d5b270be853ff99c1b3c199">ede_createPeriodicTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, signed int tiPeriod, <a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> callback)</td></tr>
<tr class="separator:a23d83e118d5b270be853ff99c1b3c199"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a503c8559e732bf76760492e901c086de"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a503c8559e732bf76760492e901c086de">ede_createSingleShotTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, signed int tiFromNow, <a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> callback, bool killAtDueTime)</td></tr>
<tr class="separator:a503c8559e732bf76760492e901c086de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e5ec6bbc83a0b2e667410d0d650cd44"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a6e5ec6bbc83a0b2e667410d0d650cd44">ede_killTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, <a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> hTimer)</td></tr>
<tr class="separator:a6e5ec6bbc83a0b2e667410d0d650cd44"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac69c32323b63b4bea1f9071d8c1c2d43"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ac69c32323b63b4bea1f9071d8c1c2d43">ede_suspendSingleShotTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, <a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> hTimer)</td></tr>
<tr class="separator:ac69c32323b63b4bea1f9071d8c1c2d43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3a5a552181f095bf9f2b8582201dfabf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a3a5a552181f095bf9f2b8582201dfabf">ede_retriggerSingleShotTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, <a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> hTimer, signed int tiNewFromNow)</td></tr>
<tr class="separator:a3a5a552181f095bf9f2b8582201dfabf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a45d2c1ba696c37c8f106cc15ce3c8ab7"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a45d2c1ba696c37c8f106cc15ce3c8ab7">ede_installCallback</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, <a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> newCallback)</td></tr>
<tr class="separator:a45d2c1ba696c37c8f106cc15ce3c8ab7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a06daa815dbab9f66d90ffb10530556"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a0a06daa815dbab9f66d90ffb10530556">ede_getIdxEventSource</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, bool *const pIsExternalEventSrc)</td></tr>
<tr class="separator:a0a06daa815dbab9f66d90ffb10530556"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af72e0545d32cb2e6e50fea0771122b67"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#af72e0545d32cb2e6e50fea0771122b67">ede_getIdxExternalEventSource</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:af72e0545d32cb2e6e50fea0771122b67"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ed35b6cbccf1eb503828775cd6c7854"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a9ed35b6cbccf1eb503828775cd6c7854">ede_getIdxInternalEventSource</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:a9ed35b6cbccf1eb503828775cd6c7854"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc88cc6f4cf3f139e83e000b55723644"><td class="memItemLeft" align="right" valign="top">uintptr_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#acc88cc6f4cf3f139e83e000b55723644">ede_getEventSourceData</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:acc88cc6f4cf3f139e83e000b55723644"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac0abddb80f7d066a177947b80dc8baf5"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ac0abddb80f7d066a177947b80dc8baf5">ede_getIdxPort</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:ac0abddb80f7d066a177947b80dc8baf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782303d6e966906d0b22007efd4bc90b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#a782303d6e966906d0b22007efd4bc90b">ede_getHandleTimer</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:a782303d6e966906d0b22007efd4bc90b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aea92c4aed177111187726f4113e23a0a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#aea92c4aed177111187726f4113e23a0a">ede_getKindOfEvent</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext)</td></tr>
<tr class="separator:aea92c4aed177111187726f4113e23a0a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac75fb1045ab6453d893e179253225e31"><td class="memItemLeft" align="right" valign="top">const void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="ede__event_dispatcher_engine_8c.html#ac75fb1045ab6453d893e179253225e31">ede_getEventData</a> (const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const pContext, unsigned int *pSizeOfEvData)</td></tr>
<tr class="separator:ac75fb1045ab6453d893e179253225e31"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>The dispatcher engine for events. Events are either external events, which are sent with a connected sender object, or internal timer events.<br />
 Both ends of the communication, sender and dispatcher can execute in different CPU contexts. This is the principal reason for the chosen design: Events, normally generated asynchonously in one or more interrupts can be processed in some application task context on the same or another core and without fearing difficult to handle race conditions.</p>
<p>Copyright (C) 2015-2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span style="display: none;">.nosp@m.</span>_Vra<span style="display: none;">.nosp@m.</span>nken@<span style="display: none;">.nosp@m.</span>Yaho<span style="display: none;">.nosp@m.</span>o.de</a>)</p>
<p>This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p>This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p>You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a class="anchor" id="ae08f7606e166bbb77d0d10596eeb94f5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT&#160;&#160;&#160;(0)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a63cb29b921ea84e61ea662a74390d667"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT_AUTO_KILL&#160;&#160;&#160;(-1)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a66e094a1460f371bf6407f91afe9919b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_SINGLE_SHOT_SUSPENDED&#160;&#160;&#160;(-2)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="ad04c6c784c9e2233898108b0c6ebfd59"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define TIMER_STATE_KILLED&#160;&#160;&#160;(-3)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a20b49b55678bd229a5a4fd324a019c21"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define sizeoffield</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">c, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">m&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;sizeof(((const c*)NULL)-&gt;m)</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a09d1cb20cec1bbe341cf91ba32d1c964"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define INVALID_DISPATCHER_HANDLE&#160;&#160;&#160;NULL</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The invalid event dispatcher handle. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a class="anchor" id="aca0c655f3fe403fb6a024efc5cf8fa52"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ede_dispatcherSystem_t ede_dispatcherSystem_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a7b8ada5a56ea28293ae25dd4fa43ab90"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ede_eventDispatcher_t ede_eventDispatcher_t</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a2940b23e2877f7abcd389c7a7e812896"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct eventSrc_t  eventSrc_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The internal representation of a registered event source.<br />
 Note, this typedef relates to the internal events; see eventSrcExt_t for external events. The concept is, that the external source event class extends the internal source event class. This requires careful identical maintenance of both types, but correctness is double-checked by compile time assertions. </p>

</div>
</div>
<a class="anchor" id="a60251d57ef6ad3972549eb3bf01345de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct eventSrcExt_t  eventSrcExt_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The internal representation of a registered event source.<br />
 Note, this typedef relates to the external events; see eventSrc_t for internal events. The concept is, that the external source event class extends the internal source event class. This requires careful identical maintenance of both types, but correctness is double-checked by compile time assertions. </p>

</div>
</div>
<a class="anchor" id="abeaaaa3e9114acf72faa9398e06286c7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef union ptrToEvtSrc_t  ptrToEvtSrc_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A reference to an event source, which can be used to type-safely assign a pointer value and to read it type-safely if the kind of event source is known. For any kind of event source, the base class pointer can be used to safely access the common fields. </p>

</div>
</div>
<a class="anchor" id="a9f8986a97b4d0b117d772f1c799ca52a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct ede_timer_t  <a class="el" href="ede__event_dispatcher_engine_8c.html#a9f8986a97b4d0b117d772f1c799ca52a">timer_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A timer object. </p>

</div>
</div>
<a class="anchor" id="a0ef7bd37f26407c9b1ddefac14a4aace"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct event_t  event_t</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>An event for the client code, i.e. the callback into the client code, is based on or controlled by this kind of object. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ae8e2baa029b22ce38d5d937844f8b189"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Static_assert </td>
          <td>(</td>
          <td class="paramtype">offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>, refEventSrcData)&#160;</td>
          <td class="paramname"> = <code>=offsetof(struct&#160;<a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>,&#160;refEventSrcData)&amp;&amp;<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>,&#160;refEventSrcData)==<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(struct&#160;<a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>,&#160;refEventSrcData)&amp;&amp;sizeof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a2940b23e2877f7abcd389c7a7e812896">eventSrc_t</a>)==offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#a60251d57ef6ad3972549eb3bf01345de">eventSrcExt_t</a>,&#160;callback)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Construction of extended class definition is bad&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a61ed1519c7fb4bd6c422e3b2f88d102f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Static_assert </td>
          <td>(</td>
          <td class="paramtype">offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>, ext)&#160;</td>
          <td class="paramname"> = <code>=offsetof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>,&#160;base)&amp;&amp;<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>,&#160;ext)==<a class="el" href="ede__event_dispatcher_engine_8c.html#a20b49b55678bd229a5a4fd324a019c21">sizeoffield</a>(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>,&#160;base)&amp;&amp;sizeof(<a class="el" href="ede__event_dispatcher_engine_8c.html#abeaaaa3e9114acf72faa9398e06286c7">ptrToEvtSrc_t</a>)==sizeof(void&#160;*)</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Construction of extended class definition is bad&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="aaa40169333aa1715af8ff4e68e86a7fb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Static_assert </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a550231c7d9af9163faba9a68d9e1df75">EDE_COMMON_MACHINE_ALIGNMENT</a> &gt;=_Alignof(uintptr_t)||&#160;</td>
          <td class="paramname"><em>EDE_COMMON_MACHINE_ALIGNMENT</em> = <code>=1u||EDE_COMMON_MACHINE_ALIGNMENT==2u||EDE_COMMON_MACHINE_ALIGNMENT==4u||EDE_COMMON_MACHINE_ALIGNMENT==8u||EDE_COMMON_MACHINE_ALIGNMENT==16u</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&quot;Bad configuration of alignment&quot;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a class="anchor" id="a4f6cb6a9250a5f4ff0076a4e56b19e40"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_createDispatcherSystem </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a0cb1fc00f09a5921434b9da748eb44d9">ede_handleDispatcherSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pHandleDispSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noEventDispatcherEngines</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoEventSourcesExt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxNoEventSourcesInt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolDispatchingProcess</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a dispatcher.<br />
 The dispatcher delivers events to the client code, which is completely organized as set of callbacks, which implement the reaction on the events. The root of all is the initialization call(back), which is made for each registered event source.<br />
 Events can be external events (their meaning is fully determined by the integration code) or internal timer events.<br />
 A dispatcher is single-threaded. There are no race conditions between callbacks, which makes the design of the event handling code easy and safe. If events are logically connected to several application tasks then one would create an according number of dispatchers and each events goes to the dispatcher in the appropriate, associated application task. For use case CAN communication, this could mean to process fast regular messages with one dispatcher in a fast application task and all other messages in a slower task.<br />
 Events can carry data of variable size. For use case CAN communication, this could be the message payload in case of message reception events or some fault status information for message send acknowledge events.<br />
 In general, the data elements are opaque to the dispatcher engine. Filling the contents is done as part of the integration code and evaluating the data elements, too. The engine will just ensure proper delivery of the event together with the data it carries. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the new system could be created and <em>false</em> otherwise.<br />
 The function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. If the assertion doesn't fire throughout the development and test phase then it won't in the production code. Anyhow, the dispatcher system must never be used if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pHandleDispSystem</td><td>Get the handle of the newly created dispatcher object by reference. This handle is later needed to use the dispatcher. If the function returns <em>false</em> then it'll return the special handle <a class="el" href="ede__event_dispatcher_engine_8h.html#ad911c9983b5b27deb9707e95d961718d">EDE_INVALID_DISPATCHER_SYSTEM_HANDLE</a> in * <em>pHandleDispSystem</em>.<br />
 </td></tr>
    <tr><td class="paramname">tiTick</td><td>The processing of the queue needs to be done on a regular time base using function <em><a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain()</a></em>. The time distance between two calls of this function needs to be known for the timer operations and is passed in as <em>tiTick</em>.<br />
 The value needs to be a positive integer and should not be too large: No timing operation shorter or faster than the value passed in here will become possible. This relates to raising events and checking timeouts of operations.<br />
 The unit is arbitrary but the chosen unit defines the unit of all other timer operations at the same time. Usually it'll be a Millisecond. </td></tr>
    <tr><td class="paramname">maxNoEventSourcesExt</td><td>The maximum number of different sources of external events, that will be received through the ports. This number of event sources can be registered for the new dispatcher and using <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>. </td></tr>
    <tr><td class="paramname">maxNoEventSourcesExt</td><td>The maximum number of different sources of external events, that will be received through the ports. This number of event sources can be registered fot the new dispatcher and using <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>. </td></tr>
    <tr><td class="paramname">mapSdrEvHdlToEdeEvSrcIdx</td><td>The (externally implemented) map, which associates the abstract handle of an external event with the internally used event source index. See data type <em><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a></em> for more details. </td></tr>
    <tr><td class="paramname">pMemPoolDispatchingProcess</td><td>A memory pool by reference, which provides the memory needed for construction of the dispatcher object.<br />
 The memory dealt out by this pool needs to grant write-access to the context that runs the dispatching process, i.e. which is going to regularly call <a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain()</a> for the here created dispatcher object. All other contexts don't need access to the memory. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function is assumed to be done in a race condition free environment, prior to entering the multi-tasking phase of the application. Most platforms will offer an initialization task for this purpose.<br />
 See <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a> for more details on race conditions and use in concurrent environments. </dd></dl>

</div>
</div>
<a class="anchor" id="a5cf8525218dded99c9b1688aa2ac53e5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool ede_createDispatcher </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8c.html#aca0c655f3fe403fb6a024efc5cf8fa52">ede_dispatcherSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pSys</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiTick</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a>&#160;</td>
          <td class="paramname"><em>portAry</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>noPorts</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a>&#160;</td>
          <td class="paramname"><em>mapSdrEvHdlToEdeEvSrcIdx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a dispatcher.<br />
 The dispatcher delivers events to the client code, which is completely organized as set of callbacks, which implement the reaction on the events. The root of all is the initialization call(back), which is made for each registered event source.<br />
 Events can be external events (their meaning is fully determined by the integration code) or internal events. An internal event actually means the initialization callback and later timer events, triggered from there.<br />
 A dispatcher is single-threaded. There are no race conditions between callbacks, which makes the design of the event handling code easy and safe. If events are logically connected to several application tasks then one would create an according number of dispatchers and each events goes to the dispatcher in the appropriate, associated application task. For use case CAN communication, this could mean to process fast regular messages with one dispatcher in a fast application task and all other messages in a slower task.<br />
 Events can carry data of variable size. For use case CAN communication, this could be the message payload in case of message reception events or some fault status information for message send acknowledge events.<br />
 In general, the data elements are opaque to the dispatcher engine. Filling the contents is done as part of the integration code and evaluating the data elements, too, inside the external callback implementation. The engine will just ensure proper delivery of the event together with the data it carries. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if dispatcher creation succeeded. <em>false</em> would be returned in case of bad function arguments or if an already created dispatcher instance is re-created (both caught by assertion, too) or if the dispatcher system's memory pool is exhausted.<br />
 Beside obvious programming errors in the calling code, the function will fail only in case of lack of memory. Since all memory allocation is static and deterministic an appropriate and recommended failure handling concept is to check the return value by assertion only. If the assertion doesn't fire throughout the development and test phase then it won't in the production code. Anyhow, the dispatcher must never be used if this function returns <em>false</em>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pSys</td><td>The dispatcher system by reference, which owns the dispatcher. At creation time of a system, the number of contained dispatchers is specified and one out of these is now initialized. All of these dispatchers share the same memory space and access rights and they share the index spaces of external and internal event sources. (Although not the event sources themselves.) </td></tr>
    <tr><td class="paramname">tiTick</td><td>The processing of the received and timer events needs to be done on a regular time base using function <em><a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain()</a></em>. The time distance between two calls of this function needs to be known for the timer operations and is passed in as <em>tiTick</em>.<br />
 The value needs to be a positive integer and should not be too large: No timing operation shorter or faster than the value passed in here will become possible. This relates to raising events and checking timeouts of operations.<br />
 The unit is arbitrary but the chosen unit defines the unit of all other timer operations at the same time. Usually it'll be a Millisecond and this is what the function documentation normally assumes. </td></tr>
    <tr><td class="paramname">portAry</td><td>The input port instances. They are passed in and copied as an array and the index order in <em>portAry</em> is the same as later used at run-time, it is e.g. visible as origin of an event in the callback. </td></tr>
    <tr><td class="paramname">noPorts</td><td>The number of input ports of this dispatcher. </td></tr>
    <tr><td class="paramname">mapSdrEvHdlToEdeEvSrcIdx</td><td>The (externally implemented) map, which associates the abstract handle of an external event with the internally used event source index. See data type <em><a class="el" href="structede__map_sender_ev_handle_to_idx__t.html">ede_mapSenderEvHandleToIdx_t</a></em> for more details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function is assumed to be done in a still race condition free environment, prior to entering the multi-tasking phase of the application. Most platforms will offer an initialization task for this purpose.<br />
 Race conditions occur inside one dispatcher system between creation of different dispatchers and registering of events. All of these functions need to be called strictly sequentially for one and the same system.<br />
 Race conditions between different dispatcher systems do only occur through their memory pool. If both use the same one (and if it doesn't do the mutual exclusion internally), then the statement before holds for the union of both systems. </dd></dl>

</div>
</div>
<a class="anchor" id="a094049b2a8687b18a16778faa8f5fd00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_registerExternalEventSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a0cb1fc00f09a5921434b9da748eb44d9">ede_handleDispatcherSystem_t</a> const&#160;</td>
          <td class="paramname"><em>hDispatcherSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a>&#160;</td>
          <td class="paramname"><em>kindOfEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#ada49b99ab4bcca0e08fdac728087eb65">ede_senderHandleEvent_t</a>&#160;</td>
          <td class="paramname"><em>senderHandleEvent</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>refEventSourceData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of an external event source: A newly created event source object shapes the association between the abstract handle of the event as used by its producer/origin, a given dispatcher and an event callback. Having this association for all possible events, the dispatcher engine can receive events, decode their handle and delegate the processing of the event to the dedicated (external) callback. This event processing can be done safely and free of race conditions in the context, which owns the dispatcher. This context can be another application task as the event producing context, on the same or on another core. </p><dl class="section return"><dt>Returns</dt><dd>Internally, the dispatcher organizes all registered external event sources in an array. The linear, zero based index into this array is returned in case of success.<br />
 Please note, the returned index is basically redundant information since the indexes will be dealt out in strictly incremental order in each invocation of this method. Knowing this, the design of the client code can make use of pre-determined constants rather than dealing with run time stored IDs.<br />
 Note that internal events (see <a class="el" href="ede__event_dispatcher_engine_8c.html#ad58d14d5107064bdfcce3c2be2f600f9">ede_registerInternalEventSource()</a>) spawn their own, zero based index. An index on its own can't identify an event source.<br />
 <a class="el" href="ede__event_dispatcher_engine_8h.html#aeaaf2731e13ea132413f04a34c68c52b">EDE_INVALID_EVENT_SOURCE_INDEX</a> is returned if more external event sources are registered as had been declared in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDispatcherSystem</td><td>The event dispatcher system, which owns the dispatcher engine to use with the registered event source. </td></tr>
    <tr><td class="paramname">idxDispatcher</td><td>The dispatcher object that is associated with the registered event source and which is going process its events. The dispatcher is identified by the index in the owning system, the index which had been specified in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>, too.<br />
 All existing dispatchers are functionally identical but the integration code can configure them differently and assign them to different use cases, and most often to different application task contexts. The appropriate dispatcher for the registered event source is passed in. </td></tr>
    <tr><td class="paramname">kindOfEvent</td><td>The kind of event. It is passed together with <em>senderHandleEvent</em> to the handle map owned by the dispatcher.<br />
 The enumeration <em>kindOfEvent</em> is meaningless to the sender and dispatcher object. Which values are passed is entirely in the scope of the integration code, which defines both, the event reporting interrupts and the client code, which eventually evaluates the transmitted events. In the case of CAN communication, this will e.g. be the CAN message reception event. </td></tr>
    <tr><td class="paramname">senderHandleEvent</td><td>The event's handle as used (and issued) by the external integration code. In the case of CAN communication, this will e.g. be the operating system's handle of a registered CAN message. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback related to the registered event source. The evaluation of all events associated with the registered source will be delegated to this (external) function. The callback is invoked the first time immediately after registration of the event source (and still from within this method), which permits to do further initialization there.<br />
 Note, for the first, initializing callback, the kind of event will be set to <a class="el" href="ede__event_dispatcher_engine_8h.html#a466ce9eb8cfb932df9195fc7a79edecc">EDE_EV_EVENT_SOURCE_EXT_INIT</a>; all later events received events from the registered source will have <em>kindOfEvent</em> as kind of event. </td></tr>
    <tr><td class="paramname">refEventSourceData</td><td>Some context data associated with the event source can be specified by reference. The reference can be an index or a pointer. The same reference is available to the callback, which is invoked later whenever an event from this source is processed.<br />
 Reference and referenced data are entirely meaningless to the dispatcher. The only thing it does is providing the service to store and deliver the reference. (And, particularly, not the data behind the reference!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function is assumed to be done in a still race condition free environment, prior to entering the multi-tasking phase of the application when actual event dispatching takes place. Most platforms will offer an initialization task for this purpose.<br />
 See <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a> for more details on race conditions and use in concurrent environments. </dd></dl>

</div>
</div>
<a class="anchor" id="ad58d14d5107064bdfcce3c2be2f600f9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_registerInternalEventSource </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8c.html#aca0c655f3fe403fb6a024efc5cf8fa52">ede_dispatcherSystem_t</a> *const&#160;</td>
          <td class="paramname"><em>pSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>refEventSourceData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Registration of an internal event source. An internal event source is transient in a certain way: It emits just one event, its initialization event. The use case is having the initialization of some timing logic in the initialization call back, i.e., the creation of some timers, which control some later activities.<br />
 Use case CAN communication: We could implement outbound messages in this way. The initialization callback from the registration of a Tx message would install a periodic timer, and the on-elapse callback of this timer would implement the send message operation.<br />
 Note, the registered event source is persistent, although it produces just one event: It remains the parent of all created timers and these timers have therefore access to the context data associated with the event source (see below). </p><dl class="section return"><dt>Returns</dt><dd>Internally, the dispatcher organizes all registered internal event sources in an array. The linear, zero based index into this array is returned in case of success.<br />
 Please note, the returned index is basically redundant information since the indexes will be dealt out in strictly incremental order in each invocation of this method. Knowing this, the design of the client code can make use of pre-determined constants rather than dealing with run time stored IDs.<br />
 Note that external events (see <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>) spawn their own, zero based index. An index on its own can't identify an event source.<br />
 <a class="el" href="ede__event_dispatcher_engine_8h.html#aeaaf2731e13ea132413f04a34c68c52b">EDE_INVALID_EVENT_SOURCE_INDEX</a> is returned if more internal event sources are registered as had been declared in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDispatcherSystem</td><td>The event dispatcher system, which owns the dispatcher engine to use with the registered event source. </td></tr>
    <tr><td class="paramname">idxDispatcher</td><td>The dispatcher object that is associated with the registered event source and which is going process its events. The dispatcher is identified by the index in the owning system, the index which had been specified in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>, too.<br />
 All existing dispatchers are functionally identical but the integration code can configure them differently and assign them to different use cases, and most often to different application task contexts. The appropriate dispatcher for the registered event source is passed in. </td></tr>
    <tr><td class="paramname">hDispatcher</td><td>The handle of the dispatcher object that is associated with the registered event source and which is going process its event. The dispatcher is identified by the index in the owning system, the index which had been specified in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>, too.<br />
 All existing dispatchers are functionally identical but the integration code can configure them differently and assign them to different use cases, and most often to different application task contexts. The appropriate dispatcher for the registered event source is passed in. </td></tr>
    <tr><td class="paramname">callback</td><td>The callback related to the registered event source. The callback is invoked immediately after registration of the event source (and still from within this method), which permits to do further initialization there. The initializing callback receives <a class="el" href="ede__event_dispatcher_engine_8h.html#a6f6c95733889c68bd1a8d296b5451e56">EDE_EV_EVENT_SOURCE_INT_INIT</a> as kind of event. </td></tr>
    <tr><td class="paramname">refEventSourceData</td><td>Some context data associated with the event source can be specified by reference. The reference can be an index or a pointer. The same reference is available to the initialization callback and the callbacks of all timers, which are created in the initialization callback.<br />
 Reference and referenced data are entirely meaningless to the dispatcher. The only thing it does is providing the service to store and deliver the reference. (And, particularly, not the data behind the reference!) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function is assumed to be done in a still race condition free environment, prior to entering the multi-tasking phase of the application when actual event dispatching takes place. Most platforms will offer an initialization task for this purpose.<br />
 See <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a> for more details on race conditions and use in concurrent environments. </dd></dl>

</div>
</div>
<a class="anchor" id="a92423b842e575d300f2128781b88fde4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ede_dispatcherMain </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#aa57c811b7b1b41219c699d9d6652a121">ede_handleConstDispatcherSystem_t</a> const&#160;</td>
          <td class="paramname"><em>hDispatcherSystem</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxDispatcher</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The regular tick function of a dispatcher. This function is invoked from the (periodic) task, which processes the dispatched events. Example CAN communication: This is normally the APSW task, which receives and sends the CAN frames, which are associated with the given dispatcher.<br />
 All notifications and timer operations and thus all event related actions are done in the context of this function call (actually as sub-routines of this invokation) and they are therefore completely race conidtion free with the rest of the same task's code. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">hDispatcherSystem</td><td>The event dispatcher system, which owns the dispatcher engine to be clocked. </td></tr>
    <tr><td class="paramname">idxDispatcher</td><td>The dispatcher object, which is clocked. The dispatcher is identified by the index in the owning system, the index which had been specified in <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The call of this function is race condition free with respect to other dispatchers, regardless whether they belong to the same or another dispatcher system. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000004">Todo:</a></b></dt><dd>Should this be counted like a lost event due to queue full? </dd></dl>

</div>
</div>
<a class="anchor" id="a23d83e118d5b270be853ff99c1b3c199"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> ede_createPeriodicTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiPeriod</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a periodic timer event from a callback.<br />
 Typical use case in the context of CAN communication is a timer, which triggers sending of regular frames. </p><dl class="section return"><dt>Returns</dt><dd>The timer handle is returned; this handle is used to identify a timer (if several timers should share the same callback function) or to perform other operations on this timer.<br />
 If no timer can be created due to a lack of memory then <a class="el" href="ede__event_dispatcher_engine_8h.html#a085cf262fcca3b3c43df4c23d724aa63">EDE_INVALID_TIMER_HANDLE</a> is returned instead. Due to the static, deterministic error allocation concept this error should preferrably be handled by a simple assertion only; if this assertion doesn't fire in the DEBUG compilation then there won't be an error in the production code neither. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">tiPeriod</td><td>The timer will invoke the specified callback <em>callback</em> every <em>tiPeriod</em> time units. The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time; the timer will fire in every tick of the dispatcher.<br />
 The cycle time is not rounded to a multiple of the dispatcher's clock tick. If <em>tiPeriod</em> is not a multiple of the clock tick then the timer will always fire at the first tick at or after the next nominal due time. The timer events are no longer equidistant but the nominal cycle time is kept in average. </td></tr>
    <tr><td class="paramname">callback</td><td>Please refer to <em>tiPeriod</em>. </td></tr>
    <tr><td class="paramname">refUserContextData</td><td>The user specified context information, which is stored with the timer and which will be brought back into its callback at due time. In the timer's callback, use <em><a class="el" href="ede__event_dispatcher_engine_8c.html#ac75fb1045ab6453d893e179253225e31">ede_getEventData()</a></em> to retrieve the value passed in here. The data type of the user specified context data is <em>uintptr_t</em>; if you pass in a pointer to some data then <a class="el" href="ede__event_dispatcher_engine_8c.html#ac75fb1045ab6453d893e179253225e31">ede_getEventData()</a> will only return the pointer - not the data it points to.<br />
 This argument is available only if <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a3e9cf46c02aa8ae9348d21b686f0f466">EDE_ENABLE_TIMER_CONTEXT_DATA</a> is set to 1. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method and <a class="el" href="ede__event_dispatcher_engine_8c.html#a503c8559e732bf76760492e901c086de">ede_createSingleShotTimer()</a> are the only pieces of code in the dispatcher implementation, which could suffer from race conditions. The timer objects are created from the memory pool specified in <a class="el" href="ede__event_dispatcher_engine_8c.html#a4f6cb6a9250a5f4ff0076a4e56b19e40">ede_createDispatcherSystem()</a>. Race conditions would occur if another task calls <a class="el" href="ede__event_dispatcher_engine_8c.html#a92423b842e575d300f2128781b88fde4">ede_dispatcherMain()</a> for another dispatcher object and that dispatcher coincidently creates a timer and both dispatchers use the same memory pool. (Two dispatchers will always use the same memory pool if they belong to the same system!)<br />
 In such a scenario, you'd need to use an implementation of the memory pool interface with appropriate mutual exclusion mechanism. The default implementation of the CAN interface, <a class="el" href="mem__malloc_8c.html">mem_malloc.c</a>, allows using a guard function provided by the integration code, see argument <em>mutualExclusionGuard</em> of its constructor <a class="el" href="mem__malloc_8c.html#ac1ac51c7cb5049f67cd999016d97a864">mem_createMemoryPool()</a>.<br />
 Even better is either having separated memory pools for concurrently executed dispatchers (not possible for same system) or not using the timer creation API at dispatcher run time. Instead, create your timers preferably at system initialization time. </dd></dl>

</div>
</div>
<a class="anchor" id="a503c8559e732bf76760492e901c086de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> ede_createSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiFromNow</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td>
          <td class="paramname"><em>callback</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>killAtDueTime</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Create a single shot timer event from a callback.<br />
 Typical use case is a timer, which triggers once after a while to notify a timeout. This timer can be re-triggered before it elapses and it can be reused after having elapsed. </p><dl class="section return"><dt>Returns</dt><dd>The timer handle is returned; this handle is used to identify a timer (if several timers should share the same callback function) or to perform other operations on this timer.<br />
 If no timer can be created due to a lack of memory then <a class="el" href="ede__event_dispatcher_engine_8h.html#a085cf262fcca3b3c43df4c23d724aa63">EDE_INVALID_TIMER_HANDLE</a> is returned instead. Due to the static, deterministic error allocation concept this error should preferrably be handled by a simple assertion only; if this assertion doesn't fire in the DEBUG compilation then there won't be an error in the production code neither. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">tiFromNow</td><td>The timer will invoke the specified callback <em>tiFromNow</em> time units later.<br />
 The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time and the timer fires in the next tick of the dispatcher.<br />
 For single-shot timers with <em>killAtDueTime</em> == <em>false</em> the value 0 is permitted, too; is means to create the timer in suspended state. Doing so can give better control of memory allocation; all ever required timers can be created in the initialization callback for later use at runtime and dynamic object creation at runtime is entirely avoided. </td></tr>
    <tr><td class="paramname">callback</td><td>Please refer to <em>tiFromNow</em>. </td></tr>
    <tr><td class="paramname">refUserContextData</td><td>The user specified context information, which is stored with the timer and which will be brought back into its callback at due time. In the timer's callback, use <em><a class="el" href="ede__event_dispatcher_engine_8c.html#ac75fb1045ab6453d893e179253225e31">ede_getEventData()</a></em> to retrieve the value passed in here. The data type of the user specified context data is <em>uintptr_t</em>; if you pass in a pointer to some data then <a class="el" href="ede__event_dispatcher_engine_8c.html#ac75fb1045ab6453d893e179253225e31">ede_getEventData()</a> will only return the pointer - not the data it points to.<br />
 This argument is available only if <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a3e9cf46c02aa8ae9348d21b686f0f466">EDE_ENABLE_TIMER_CONTEXT_DATA</a> is set to 1. </td></tr>
    <tr><td class="paramname">killAtDueTime</td><td>Single shot timers can be killed at due time (and after callback processing) or they can stay alive in suspended state for later reprogramming of a new single-shot time. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This method and <a class="el" href="ede__event_dispatcher_engine_8c.html#a23d83e118d5b270be853ff99c1b3c199">ede_createPeriodicTimer()</a> are the only pieces of code in the CAN interface implementation, which potentially suffer from race conditions with other threads, that concurrenly run another dispatcher object. These race conditions are easily to avoid, see <a class="el" href="ede__event_dispatcher_engine_8c.html#a23d83e118d5b270be853ff99c1b3c199">ede_createPeriodicTimer()</a> for details. </dd></dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ede__event_dispatcher_engine_8c.html#a3a5a552181f095bf9f2b8582201dfabf">ede_retriggerSingleShotTimer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a6e5ec6bbc83a0b2e667410d0d650cd44"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ede_killTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A timer is killed. No later callbacks will appear for periodic and single shot timers and nor will it be possible to reset the due time of a killed timer. Killing of a timer can be done at any reasonable time. Exceptions are: The operation must neither be applied twice or more often to the same timer and nor after leaving the callback of a single-shot timer with auto kill property. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the killed timer as got from the timer create function. The handle becomes invalid with return from this function!<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a timer. In which case the operation affects this timer. This operation is permitted but useless for a single-shot timer with auto-kill property. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="ede__event_dispatcher_engine_8c.html#a503c8559e732bf76760492e901c086de">ede_createSingleShotTimer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ac69c32323b63b4bea1f9071d8c1c2d43"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ede_suspendSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Stop a running timer. The difference to kill is that the timer object is not marked for reuse (which is the substitute for object destroying in our static, deterministic memory allocation concept). The handle stays valid and the timer can later be reused by reprogramming its due time with <a class="el" href="ede__event_dispatcher_engine_8c.html#a3a5a552181f095bf9f2b8582201dfabf">ede_retriggerSingleShotTimer()</a>.<br />
 The concept of suspending and later reusing timers only holds for single shot timers without the auto-kill property set. Calling this function for an auto-kill single shot timer is still permitted but the operation is effectively a kill. These timers can't be reprogrammed after suspend. Calling this function for a periodic timer is forbidden; this is caught by assertion. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the suspended timer as got from the timer create function. It needs to be a single-shot timer. Otherwise an assertion fires.<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a single-shot timer. In which case the operation affects this timer.<br />
 If the function is called from the on-elapse callback of a single-shot timer with auto-kill property set then the operation is without effect since the timer would be killed anyway. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a3a5a552181f095bf9f2b8582201dfabf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void ede_retriggerSingleShotTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a>&#160;</td>
          <td class="paramname"><em>hTimer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">signed int&#160;</td>
          <td class="paramname"><em>tiNewFromNow</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>A single shot timer can be reprogrammed during elapsing or - but only if it doesn't have the auto-kill property set - even after firing or explicit suspend command. Use this function to redefine the due time.<br />
 For running single shot timers with or without auto-kill property this operation means to postpone the timer event by a new time span counting from now.<br />
 For suspended timers it means the reactivation of an inactive timer object. Reactivation after suspend is functionally identical to killing a timer (explicit or by auto-kill) and creating a new one. The only difference is the different memory management impact, kill and create can mean to allocate a new object on the heap, whereas suspend/resume guarantees not to do any heap operation.<br />
 Please note: Single shot timers with auto-kill can't have a suspended state. They are either running or killed, i.e. no longer existant and not accessible. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">hTimer</td><td>The handle of the reprogrammed timer as got from the create function. It needs to be a single-shot timer. Otherwise an assertion fires.<br />
 The handle may be <em>NULL</em> if the function is used from the on-elapse callback of a single-shot timer. In which case the operation affects this timer.<br />
 If the function is called from the on-elapse callback of a single-shot timer with auto-kill property set then the operation is without effect: These timers won't fire again but are definitly killed after firing their event. </td></tr>
    <tr><td class="paramname">tiNewFromNow</td><td>The new due time is defined to be <em>tiNewFromNow</em> time units in the future. The unit is the same as that of argument <em>tiTick</em> in the call of <a class="el" href="ede__event_dispatcher_engine_8c.html#a5cf8525218dded99c9b1688aa2ac53e5">ede_createDispatcher()</a>.<br />
 The value needs to be positive. If it is less than the tick time of the dispatcher than it is rounded upwards to this tick time and the timer fires in the next tick of the dispatcher. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a45d2c1ba696c37c8f106cc15ce3c8ab7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a> ede_installCallback </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="ede__event_dispatcher_engine_8h.html#a7cfe8df11ef987f63d977be714cede21">ede_callback_t</a>&#160;</td>
          <td class="paramname"><em>newCallback</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>All events related to a registered event source or a timer are reported through the registered callback. In general this callback can have a switch/case to handle different kinds of events. Sometime it might be better to (temporarily) redefine the callback function to handle anticipated, specific events. From within a callback the client code may use this function to re-register the callback function for all future events from the same source. </p><dl class="section return"><dt>Returns</dt><dd>The callback function registered so far is returned. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">newCallback</td><td>The new callback function. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from only from timer callbacks or from callbacks of external events. (But never from the initialization callback of an internal event, where it is anway useless as there won't ever be another callback.)<br />
 For external events, received via the dispatcher queue, it relates to the callback of the the event causing registered event source. For timer events it relates to the timer object, i.e., to future <a class="el" href="ede__event_dispatcher_engine_8h.html#aa813e101ee238d72530cb92e8b832c80">EDE_EV_TIMER_ELAPSED</a> events of the same timer object. </dd></dl>

</div>
</div>
<a class="anchor" id="a0a06daa815dbab9f66d90ffb10530556"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_getIdxEventSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool *const&#160;</td>
          <td class="paramname"><em>pIsExternalEventSrc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index of the event source, which has posted the event. The index is the same, which had been returned by the registration of that event source (see <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>). If this method is called from a timer callback then the operation relates to the parent event source of the timer. </p><dl class="section return"><dt>Returns</dt><dd>Get the zero based, linear event source index.<br />
 </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">pIsExternalEventSrc</td><td>Registered event sources has separate index spaces for internal and external sources. It is returned by reference, whether the returned index relates to an external source (<em>true</em>) or an internal one (<em>false</em>). </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="af72e0545d32cb2e6e50fea0771122b67"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_getIdxExternalEventSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index of the external event source, which has posted the event, which had raised the callback, which invokes this method. The index is the same, which had been returned by the registration of that external event source (see <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>). If this method is called from a timer callback then the operation relates to the parent external event source of the timer. </p><dl class="section return"><dt>Returns</dt><dd>Get the zero based, linear index of the external event source.<br />
 The method must be used only from callbacks caused by an external event source. Function result and behavior are undefined if it is invoked from a callback initiated by an external event source. This is caught by assertion only. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Registered event sources have separate index spaces for internal and external sources. Never call this method from a callback initiated by an internal event source! (This includes callback from timers, which had been created in earlier callbacks from internal sources.) Use <a class="el" href="ede__event_dispatcher_engine_8c.html#a0a06daa815dbab9f66d90ffb10530556">ede_getIdxEventSource()</a> in case of doubts. </dd></dl>

</div>
</div>
<a class="anchor" id="a9ed35b6cbccf1eb503828775cd6c7854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int ede_getIdxInternalEventSource </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index of the internal event source, which has posted the event, which had raised the callback, which invokes this method. The index is the same, which had been returned by the registration of that internal event source (see <a class="el" href="ede__event_dispatcher_engine_8c.html#ad58d14d5107064bdfcce3c2be2f600f9">ede_registerInternalEventSource()</a>). If this method is called from a timer callback then the operation relates to the parent internal event source of the timer. </p><dl class="section return"><dt>Returns</dt><dd>Get the zero based, linear index of the internal event source.<br />
 The method must be used only from callbacks caused by an internal event source. Function result and behavior are undefined if it is invoked from a callback initiated by an external event source. This is caught by assertion only. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Registered event sources have separate index spaces for internal and external sources. Never call this method from a callback initiated by an external event source! (This includes callback from timers, which had been created in earlier callbacks from external sources.) Use <a class="el" href="ede__event_dispatcher_engine_8c.html#a0a06daa815dbab9f66d90ffb10530556">ede_getIdxEventSource()</a> in case of doubts. </dd></dl>

</div>
</div>
<a class="anchor" id="acc88cc6f4cf3f139e83e000b55723644"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uintptr_t ede_getEventSourceData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Event sources are registered with a reference to some data object, which characterizes the event source. Accessing this data may be useful for processing the received event.<br />
 Note, reference and referenced data object are meaningless to the dispatcher engine. See <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the data reference, which had been registered with the causing custom event source; see argument <em>refEventSourceData</em> of <a class="el" href="ede__event_dispatcher_engine_8c.html#a094049b2a8687b18a16778faa8f5fd00">ede_registerExternalEventSource()</a>. The reference can be an index or a pointer. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The other API <a class="el" href="ede__event_dispatcher_engine_8c.html#a0a06daa815dbab9f66d90ffb10530556">ede_getIdxEventSource()</a>, which identifies the causing event source by index, is an alternative to using the event source's referenced data object. </dd></dl>

</div>
</div>
<a class="anchor" id="ac0abddb80f7d066a177947b80dc8baf5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> ede_getIdxPort </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the index of the port, which had received the event that caused the callback. This method is useless when called from a timer callback. </p><dl class="section return"><dt>Returns</dt><dd>The zero based index of the receiving dispatcher port or UINT_MAX for a timer callback. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a782303d6e966906d0b22007efd4bc90b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8h.html#a63e9256208333c366bb2d5f49f0ba2f2">ede_handleTimer_t</a> ede_getHandleTimer </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the handle of the timer causing the callback, which this method is called from. The method can be useful to identify the due timer if several timer objects share the same callback. </p><dl class="section return"><dt>Returns</dt><dd>The handle of the timer object as initially got from either <a class="el" href="ede__event_dispatcher_engine_8c.html#a23d83e118d5b270be853ff99c1b3c199">ede_createPeriodicTimer()</a> or <a class="el" href="ede__event_dispatcher_engine_8c.html#a503c8559e732bf76760492e901c086de">ede_createSingleShotTimer()</a>.<br />
 The function returns NULL if not called from a timer elapsed callback. However, this situation is considered a fault in the (external) code and reported by assertion in DEBUG compilation. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aea92c4aed177111187726f4113e23a0a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a77c0796970c19f653ef7d7d95d3d90c1">ede_kindOfEvent_t</a> ede_getKindOfEvent </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the "kind of event", i.e., the reason for invokation of the callback, this method is called from. </p><dl class="section return"><dt>Returns</dt><dd>The reason for invokation or the causing event. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ac75fb1045ab6453d893e179253225e31"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const void* ede_getEventData </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="ede__event_dispatcher_engine_8h.html#a3b9d6c6b8ea95bfd1581bff336f18358">ede_callbackContext_t</a> *const&#160;</td>
          <td class="paramname"><em>pContext</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pSizeOfEvData</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Get the data contents of an event from within a callback.<br />
 For use case CAN communication, this normally relates to the content bytes of a received message but it may have any other meaning, which is aggreed on between data producer and consumer and which are both defined in the integration code.<br />
 For timer events and if user specified timer context data is supported (see <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a3e9cf46c02aa8ae9348d21b686f0f466">EDE_ENABLE_TIMER_CONTEXT_DATA</a>) then the data contents of the event is the user specified context data. This method will return the value, which had been specified as parameter <em>refUserContextData</em> in the timer creation methods, either <a class="el" href="ede__event_dispatcher_engine_8c.html#a23d83e118d5b270be853ff99c1b3c199">ede_createPeriodicTimer()</a> or <a class="el" href="ede__event_dispatcher_engine_8c.html#a503c8559e732bf76760492e901c086de">ede_createSingleShotTimer()</a>. Note, for timer callbacks, it'll normally be more to the point to use the alternative method <a class="el" href="ede__event_dispatcher_engine_8h.html#aea0200aaf04b4f9817e9d9c5c29066cb">ede_getTimerContextData()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the pointer to the content data of the event. The calling client code has read-only access to the data and the data the returned pointer points to is valid only during the execution of the callback, which this method is called from. The data needs to be copied by the callback code if this doesn't suffice.<br />
 The data has the alignment of a pointer to <em>void</em> or an (<em>unsigned</em>) <em>int</em>, whatever is the stronger constraint. If you e.g. know that it actually is an <em>int</em> then you may on most platforms cast the returned pointer to an <em>int</em> pointer and read the integer as a whole. (As opposed to reading all the integer's bytes as <em>uint8_t</em> and composing the number from these.) </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pContext</td><td>The dispatcher context this callback is invoked from. </td></tr>
    <tr><td class="paramname">pSizeOfEvData</td><td>The number of bytes the returned pointer points to. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Event data is not defined for timer events if the code is not compiled with support of user specified timer context data. The function will return NULL and set * <em>pSizeOfEvData</em> to zero in this case. See <a class="el" href="ede__event_dispatcher_engine_8config_8h.html#a3e9cf46c02aa8ae9348d21b686f0f466">EDE_ENABLE_TIMER_CONTEXT_DATA</a> for more. </dd>
<dd>
The alignment of the pointer is not ensured by the implementation of the dispatcher. At least for external events, the dispatcher just passes through the data pointer from the connection element, which is connected to the dispatcher's input port. Nevertheless, the alignment promise is still kept, though by requirement only; any implementation of a connection element must regard this alignment constraint. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_081dba3b7b2444bc5b95b682ee9f194a.html">eventDispatcher</a></li><li class="navelem"><a class="el" href="ede__event_dispatcher_engine_8c.html">ede_eventDispatcherEngine.c</a></li>
    <li class="footer">Generated on Fri Feb 18 2022 19:44:45 for comFramework-CANInterface by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.8 </li>
  </ul>
</div>
</body>
</html>
