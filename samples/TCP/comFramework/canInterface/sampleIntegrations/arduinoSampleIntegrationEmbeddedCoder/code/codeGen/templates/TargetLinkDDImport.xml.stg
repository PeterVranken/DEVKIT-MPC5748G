//
// TargetLinkDDImport.xml.stg
// This is a template group file for StringTemplate V4, see www.stringtemplate.org.
//
// The contents of the network databases are presented as a TargetLink DataDictionary
// import file. It supports the "extended" XML import. TargetLink is a C code generator
// from dSPACE for model based software design and the generated import file specifies the
// CAN interface, which is generated by the other template globalInterface.stg, to the
// TargetLink code generator so that both portions of generated C code directly fit
// together.
//
// Copyright (C) 2015-2016 Peter Vranken (mailto:Peter_Vranken@Yahoo.de)
//
// This program is free software: you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by the
// Free Software Foundation, either version 3 of the License, or any later
// version.
//
// This program is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License
// for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this program. If not, see <http://www.gnu.org/licenses/>.

delimiters "$", "$"

import "typeMapTL.stg"
import "lib/iterations.stg"
import "symbols.stg"

tlDDImport(cluster, info) ::= <<
<?xml version="1.0" encoding="ISO-8859-1"?>
<!-- This is an interface specification for the dSPACE TargetLink C code generator -->
<!-- Created with $info.application$ version $info.version$, see http://sourceforge.net/projects/comframe/ -->
<!-- The interface is generated from these network database files: -->
$listOfDbcFiles(cluster)$$\\$
<ddObj Name="Pool" Kind="Pool">
  <ddObj Name="Variables" Kind="VariableGroup" xmlns="http://www.dspace.de/DataDictionaryExtended" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
    <ddObj Name="$cluster.name$" Kind="VariableGroup">
      $cluster.busAry:renderBusVariables()$$\\$
    </ddObj>
  </ddObj>
  <ddObj Name="Typedefs" Kind="TypedefGroup">
    <ddObj Name="$cluster.name$" Kind="TypedefGroup">
      $cluster.busAry:renderBusTypedefs()$$\\$
    </ddObj>
  </ddObj>
  <ddObj Name="Modules" Kind="ModuleGroup">
    <ddObj Name="$file.canApi$" Kind="Module">
      <ddObj Name="ModuleInfo" Kind="DSDDEmbedded">
        <ddProperty Name="NameTemplate">\$D</ddProperty>
        <ddProperty Name="CodeGenerationBasis">ModelBased</ddProperty>
        <ddProperty Name="Responsibility">External</ddProperty>
      </ddObj>
      <ddObj Name="FileSpecifications" Kind="DSDDEmbedded"></ddObj>
      <ddObj Name="IncludedFiles" Kind="DSDDEmbedded"></ddObj>
    </ddObj>
  </ddObj>
  <ddObj Name="ModuleOwners" Kind="ModuleOwnerShipGroup">
    <ddObj Name="$file.canApi$" Kind="ModuleOwnerShip">
      <ddProperty Name="Description"></ddProperty>
      <ddProperty Name="ExcludeFromCodeGeneration">off</ddProperty>
      <ddProperty Name="SystemName">$file.canApi$</ddProperty>
      <ddObj Name="ModuleRefs" Kind="DSDDEmbedded">
        <ddProperty Name="ModuleRef">$file.canApi$</ddProperty>
      </ddObj>
      <ddObj Name="ModuleGroupRefs" Kind="DSDDEmbedded"></ddObj>
    </ddObj>
  </ddObj>
</ddObj>
>>

listOfDbcFiles(cluster) ::= <<
$cluster.busAry:{b|<!-- $b.networkFile$ -->$\n$}$
>>

renderBusTypedefs(bus) ::= <<
<ddObj Name="$symbol.structBus_t$" Kind="Typedef">
  <ddProperty Name="Description">The type definition of the struct representing CAN bus $bus.name$ with its frames and signals</ddProperty>
  <ddProperty Name="IsBaseType">off</ddProperty>
  <ddProperty Name="BaseType">Struct</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="CreateTypedef">on</ddProperty>
  <ddObj Name="Components" Kind="DSDDEmbedded">
    $iterateFramesOfBus(bus,"both","renderFrameStsTypedefComponentRef")$$\\$
  </ddObj>
</ddObj>
<ddObj Name="frames_$bus.name$" Kind="TypedefGroup">
  $iterateFramesOfBus(bus,"both","renderFrameTypedef")$$\\$
</ddObj>$\n$
>>


renderFrameTypedef(frame) ::= <<
<ddObj Name="$symbol.structFrameSts_t$" Kind="Typedef">
  <ddProperty Name="Description">Type definition of API struct, which represents CAN frame $frameRef()$</ddProperty>
  <ddProperty Name="IsBaseType">off</ddProperty>
  <ddProperty Name="BaseType">Struct</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="CreateTypedef">on</ddProperty>
  <ddObj Name="Components" Kind="DSDDEmbedded">
    <ddObj Name="$symbol.fieldSignals$" Kind="TypedefComponent">
     <ddProperty Name="Description">Reference to type definition of struct, which bundles all signals of frame $frameRef()$</ddProperty>
     <ddProperty Name="Type">$cluster.name$/frames_$bus.name$/$symbol.structFrame_t$</ddProperty>
     <ddProperty Name="Width"></ddProperty>
     <ddProperty Name="Volatile">off</ddProperty>
     <ddProperty Name="Const">off</ddProperty>
   </ddObj>
   <ddObj Name="$symbol.fieldStsTransmission$" Kind="TypedefComponent">
     <ddProperty Name="Description">Transmission status of frame $frameRef()$</ddProperty>
     <ddProperty Name="Type">$bt("uint8_t")$</ddProperty>
     <ddProperty Name="Width"></ddProperty>
     <ddProperty Name="Volatile">off</ddProperty>
     <ddProperty Name="Const">off</ddProperty>
   </ddObj>
  </ddObj>
</ddObj>
<ddObj Name="$symbol.structFrame_t$" Kind="Typedef">
  <ddProperty Name="Description">Type definition of struct, which bundles all signals of frame $frameRef()$</ddProperty>
  <ddProperty Name="IsBaseType">off</ddProperty>
  <ddProperty Name="BaseType">Struct</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="CreateTypedef">on</ddProperty>
  <ddObj Name="Components" Kind="DSDDEmbedded">
    $iterateSignalsOfFrame(frame,"all","all","renderSignalTypedefComponent")$$\\$
  </ddObj>
</ddObj>$\n$
>>


renderFrameStsTypedefComponentRef(frame) ::= <<
<ddObj Name="$symbol.structFrameSts$" Kind="TypedefComponent">
  <ddProperty Name="Description">This field is a collection of all frames of bus $bus.name$</ddProperty>
  <ddProperty Name="Type">$cluster.name$/frames_$bus.name$/$symbol.structFrameSts_t$</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="Volatile">off</ddProperty>
  <ddProperty Name="Const">off</ddProperty>
</ddObj>$\n$
>>


renderSignalTypedefComponent(signal,kind) ::= <<
<ddObj Name="$symbol.signal$" Kind="TypedefComponent">
  <ddProperty Name="Description">Type definition of signal $signal.name$ of frame $frameRef()$</ddProperty>
  <ddProperty Name="Type">$bt(signal.type)$</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="Volatile">off</ddProperty>
  <ddProperty Name="Const">off</ddProperty>
</ddObj>$\n$
>>


renderBusVariables(bus) ::= <<
<ddObj Name="$symbol.structBus$" Kind="Variable">
  <ddProperty Name="Description">This struct represents the CAN bus $bus.name$. It collects the frames of the bus</ddProperty>
  <ddProperty Name="Class">EXTERN_DISP</ddProperty>
  <ddProperty Name="Type">$cluster.name$/$symbol.structBus_t$</ddProperty>
  <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="Value"></ddProperty>
  <ddProperty Name="Min"></ddProperty>
  <ddProperty Name="Max"></ddProperty>
  <ddProperty Name="Address"></ddProperty>
  <ddProperty Name="NameTemplate">\$D</ddProperty>
  <ddProperty Name="ModuleRef">$file.canApi$</ddProperty>
  <ddObj Name="Components" Kind="DSDDEmbedded">
    $iterateFramesOfBus(bus,"both","renderFrameStsVariables")$$\\$
  </ddObj>
</ddObj>$\n$
>>


renderFrameStsVariables(frame) ::= <<
<ddObj Name="$symbol.structFrameSts$" Kind="Variable">
  <ddProperty Name="Description">Representation of frame $frameRef()$ plus transmission status</ddProperty>
  <ddProperty Name="Class">default</ddProperty>
  <ddProperty Name="Type">$cluster.name$/frames_$bus.name$/$symbol.structFrameSts_t$</ddProperty>
  <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
  <ddProperty Name="Width"></ddProperty>
  <ddProperty Name="Value"></ddProperty>
  <ddProperty Name="Min"></ddProperty>
  <ddProperty Name="Max"></ddProperty>
  <ddProperty Name="Address"></ddProperty>
  <ddProperty Name="NameTemplate">\$D</ddProperty>
  <ddObj Name="Components" Kind="DSDDEmbedded">
    <ddObj Name="$symbol.fieldSignals$" Kind="Variable">
      <ddProperty Name="Description">This field is a struct, which bundles all signals of frame $frameRef()$</ddProperty>
      <ddProperty Name="Class">default</ddProperty>
      <ddProperty Name="Type">$cluster.name$/frames_$bus.name$/$symbol.structFrame_t$</ddProperty>
      <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
      <ddProperty Name="Width"></ddProperty>
      <ddProperty Name="Value"></ddProperty>
      <ddProperty Name="Min"></ddProperty>
      <ddProperty Name="Max"></ddProperty>
      <ddProperty Name="Address"></ddProperty>
      <ddProperty Name="NameTemplate">\$D</ddProperty>
      <ddObj Name="Components" Kind="DSDDEmbedded">
        $iterateSignalsOfFrame(frame,"all","all","renderSignalVariables")$$\\$
      </ddObj>
    </ddObj>
    <ddObj Name="$symbol.fieldStsTransmission$" Kind="Variable">
      <ddProperty Name="Description">Transmission status of frame $frameRef()$</ddProperty>
      <ddProperty Name="Class">default</ddProperty>
      <ddProperty Name="Type">$bt("uint8_t")$</ddProperty>
      <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
      <ddProperty Name="Width"></ddProperty>
      <ddProperty Name="Value"></ddProperty>
      <ddProperty Name="Min"></ddProperty>
      <ddProperty Name="Max"></ddProperty>
      <ddProperty Name="Address"></ddProperty>
      <ddProperty Name="NameTemplate">\$D</ddProperty>
    </ddObj>
  </ddObj>
</ddObj>$\n$
>>


renderSignalVariables(signal,kind) ::= <<
<ddObj Name="$symbol.signal$" Kind="Variable">
  <ddProperty Name="Description">$signalDescription(signal)$</ddProperty>
  <ddProperty Name="Class">default</ddProperty>
  <ddProperty Name="Type">$bt(signal.type)$</ddProperty>
$if(signal.isVoidScaling)$
  <ddProperty Name="Scaling">VOID_SCALING</ddProperty>
$else$
  <ddProperty Name="Scaling">./LocalScaling</ddProperty>
$endif$
  <ddProperty Name="Width"/>
  <ddProperty Name="Value"/>
$! This particular sample itentionally uses a min>max specification of a signal. TL fails
   to process this. For this particular sample we must not set min and max for TL !$
$!  <ddProperty Name="Min">$signal.min$</ddProperty>
  <ddProperty Name="Max">$signal.max$</ddProperty>!$
  <ddProperty Name="Address"/>
  <ddProperty Name="NameTemplate">\$D</ddProperty>
$if(!signal.isVoidScaling)$
  <ddObj Name="LocalScaling" Kind="ScalingObject">
    <ddProperty Name="Description">Linear scaling</ddProperty>
    <ddProperty Name="ConversionType">LINEAR</ddProperty>
    <ddProperty Name="LSB">$signal.factor$</ddProperty>
    <ddProperty Name="Offset">$signal.offset$</ddProperty>
    <ddProperty Name="Format">%g</ddProperty>
    <ddProperty Name="Unit">$signal.unit$</ddProperty>
  </ddObj>
$endif$
</ddObj>$\n$
>>

frameRef() ::= <<
frame $frame.name$ ($frame.id$, $frame.id; format="0x%03x"$) on bus $bus.name$
>>

frameDescription(signal) ::= <<
Frame $frameRef()$. $frame.desc; format="xml-encode"$
>>

signalDescription(signal) ::= <<
Signal $signal$ of frame $frameRef()$. $signal.desc; format="xml-encode"$&#10;  $\\$
Range (world values): $signal.min$ ... $signal.max$ [$signal.unit$].&#10;  $\\$
Scaling: WorldValue = $\\$
$if(signal.isVoidScaling)$BinaryValue$else$$signal.factor$*BinaryValue + $signal.offset$$endif$ [$signal.unit$]
>>
