<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>comFramework - CAN Interface: vsq_dispatcherPortInterface.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">comFramework - CAN Interface<span id="projectnumber">&#160;2.0</span>
   </div>
   <div id="projectbrief">comFramework - CAN Interface - A highly flexible CAN interface for embedded platforms</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('vsq__dispatcher_port_interface_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">vsq_dispatcherPortInterface.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &quot;<a class="el" href="ede__basic_definitions_8h_source.html">ede_basicDefinitions.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="ede__external_interfaces_8h_source.html">ede_externalInterfaces.h</a>&quot;</code><br />
</div>
<p><a href="vsq__dispatcher_port_interface_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a101d4174f91e08362e9bdbe3a5b6f367"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8h.html#a101d4174f91e08362e9bdbe3a5b6f367">vsq_createEventQueue</a> (<a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *pPortHead, <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *pPortTail, unsigned int maxQueueLength, unsigned int maxElementSize, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *pMemPoolHead, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *pMemPoolTail)</td></tr>
<tr class="separator:a101d4174f91e08362e9bdbe3a5b6f367"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a852ed9626db583faa703c9041132799f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8h.html#a852ed9626db583faa703c9041132799f">vsq_createEventQueueHead</a> (<a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *pPortHead, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolHead)</td></tr>
<tr class="separator:a852ed9626db583faa703c9041132799f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aecf9117372229fabddc581075c95a568"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8h.html#aecf9117372229fabddc581075c95a568">vsq_createEventQueueTail</a> (<a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *pPortTail, unsigned int maxQueueLength, unsigned int maxPayloadSize, <a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const pMemPoolTail)</td></tr>
<tr class="separator:aecf9117372229fabddc581075c95a568"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae95a47e3a7c7fcb69093ceb5198f8627"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8h.html#ae95a47e3a7c7fcb69093ceb5198f8627">vsq_linkEventQueueTailWithHead</a> (const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portTail, const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> portHead)</td></tr>
<tr class="separator:ae95a47e3a7c7fcb69093ceb5198f8627"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20f009be1515bb07783a256132da7011"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="vsq__dispatcher_port_interface_8h.html#a20f009be1515bb07783a256132da7011">vsq_linkEventQueueHeadWithTail</a> (const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> portHead, const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> portTail)</td></tr>
<tr class="separator:a20f009be1515bb07783a256132da7011"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Definition of global interface of module <a class="el" href="vsq__dispatcher_port_interface_8c.html">vsq_dispatcherPortInterface.c</a></p>
<p >Copyright (C) 2022 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="a101d4174f91e08362e9bdbe3a5b6f367" name="a101d4174f91e08362e9bdbe3a5b6f367"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a101d4174f91e08362e9bdbe3a5b6f367">&#9670;&nbsp;</a></span>vsq_createEventQueue()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueue </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create a thread-safe event queue and return it as pair of dispatcher engine ports.</p>
<p >Create a thread-safe queue with variable element size for external dispatcher events and return it as pair of ports, which provide access to head and tail of the queue. The ports are compliant with the port interfaces of sender and dispatcher from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortHead</td><td>If the function returns <em>true</em>, then a port object, which provides access to the head of the queue for fetching queued elements, has been placed into * <em>pPortHead</em>. </td></tr>
    <tr><td class="paramname">pPortTail</td><td>If the function returns <em>true</em>, then a port object, which provides access to the tail of the queue for adding elements, has been placed into * <em>pPortTail</em>. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many events with a payload of <em>sizeOfPayload</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the actually storable number.<br  />
 A queue length of zero is considered an error in the client code. This is caught by assertion and <em>false</em> is returned. </td></tr>
    <tr><td class="paramname">maxPayloadSize</td><td>The size of the payload of a queued standard event, which should be storable <em>maxQueueLength</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
    <tr><td class="paramname">pMemPoolHead</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the head of the queue, i.e., for fetching queued elements.<br  />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue tail to queue elements, needs to have at least read access to the memory from this pool. </td></tr>
    <tr><td class="paramname">pMemPoolTail</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the tail of the queue, i.e., for queueing elements.<br  />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue head to fetch queued elements, needs to have at least read access to the memory from this pool. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section warning"><dt>Warning</dt><dd>The creation of a complete, ready-to-use queue object requires initialization of both, head and tail object. Therefore, the caller of this routine needs to have write access to the memory from both memory pools. In memory protected environments, this will normally be only a supervisor context! </dd></dl>

</div>
</div>
<a id="a852ed9626db583faa703c9041132799f" name="a852ed9626db583faa703c9041132799f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a852ed9626db583faa703c9041132799f">&#9670;&nbsp;</a></span>vsq_createEventQueueHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueueHead </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create the head of a thread-safe event queue and return it as dispatcher input port.</p>
<p >Create the head object of a thread-safe queue with variable element size for external dispatcher events and return it as a port, which provide access to the head of the queue. The port is compliant with the port interface of the dispatcher from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortHead</td><td>If the function returns <em>true</em>, then a port object, which provides access to the head of the queue for fetching queued elements, has been placed into * <em>pPortHead</em>. </td></tr>
    <tr><td class="paramname">pMemPoolHead</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the head of the queue, i.e., for fetching queued elements.<br  />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue tail to queue elements, needs to have at least read access to the memory from this pool, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates the complete quene, including both ports - all in one call. </dd></dl>

</div>
</div>
<a id="aecf9117372229fabddc581075c95a568" name="aecf9117372229fabddc581075c95a568"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aecf9117372229fabddc581075c95a568">&#9670;&nbsp;</a></span>vsq_createEventQueueTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool vsq_createEventQueueTail </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a> *&#160;</td>
          <td class="paramname"><em>pPortTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxQueueLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>maxPayloadSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structede__memory_pool__t.html">ede_memoryPool_t</a> *const&#160;</td>
          <td class="paramname"><em>pMemPoolTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Create the tail of a thread-safe event queue and return it as sender output port.</p>
<p >Create a thread-safe queue with variable element size for external dispatcher events and return it as a port, which provides access to the tail of the queue. The port is compliant with the port interfaces of the sender from the event dipatcher mechanism. </p><dl class="section return"><dt>Returns</dt><dd>The function returns <em>true</em> in case of success, <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pPortTail</td><td>If the function returns <em>true</em>, then a port object, which provides access to the tail of the queue for adding elements, has been placed into * <em>pPortTail</em>. </td></tr>
    <tr><td class="paramname">maxQueueLength</td><td>The queue implementation imposes a fixed maximum size of the queue. The size is specified in terms of how many events with a payload of <em>sizeOfPayload</em> would fit into the queue. At run-time, stored elements can have arbitrary sizes so that no statement is possible about the actually storable number.<br  />
 A queue length of zero is considered an error in the client code. This is caught by assertion and <em>false</em> is returned. </td></tr>
    <tr><td class="paramname">maxPayloadSize</td><td>The size of the payload of a queued standard event, which should be storable <em>maxQueueLength</em> times in the queue. This size is just used for specification of the queue's capacity but has no meaning at run-time any more. </td></tr>
    <tr><td class="paramname">pMemPoolTail</td><td>All elements of the queue are allocated in a memory pool. This is the pool (by reference), which is used for those elements, which are required for accessing the tail of the queue, i.e., for queueing elements.<br  />
 Note, the shared-memory concept of the queue implementation requires that the execution context (ISR, task, process), which makes use of the queue head to fetch queued elements, needs to have at least read access to the memory from this pool, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates the complete quene, including both ports - all in one call. </dd></dl>

</div>
</div>
<a id="ae95a47e3a7c7fcb69093ceb5198f8627" name="ae95a47e3a7c7fcb69093ceb5198f8627"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae95a47e3a7c7fcb69093ceb5198f8627">&#9670;&nbsp;</a></span>vsq_linkEventQueueTailWithHead()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkEventQueueTailWithHead </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portTail</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a>&#160;</td>
          <td class="paramname"><em>portHead</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect the tail of a queue with its head.</p>
<p >A new event queue's head and tail objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the tail object and can thus be used by the same process that created the tail object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> will do the same for the head object and from another process.<br  />
 Note, this function is just the same as <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> but for port objects as used in the dispatcher engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portTail</td><td>The newly created queue tail port object, which is now linked to its head. </td></tr>
    <tr><td class="paramname">portHead</td><td>This is the head port object, * <em>portTail</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates both ports, head and tail, and links them - all in one call. </dd></dl>

</div>
</div>
<a id="a20f009be1515bb07783a256132da7011" name="a20f009be1515bb07783a256132da7011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a20f009be1515bb07783a256132da7011">&#9670;&nbsp;</a></span>vsq_linkEventQueueHeadWithTail()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void vsq_linkEventQueueHeadWithTail </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structede__event_receiver_port__t.html">ede_eventReceiverPort_t</a>&#160;</td>
          <td class="paramname"><em>portHead</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="structede__event_sender_port__t.html">ede_eventSenderPort_t</a>&#160;</td>
          <td class="paramname"><em>portTail</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Connect the head of a queue with its tail.</p>
<p >A new event queue's tail and head objects are created independently. Because of the separation of memories of producer and consumer of the queued data, this will typically be done independently and by distinct processes and the two objects don't know yet about one another. They can cooperate only after being mutually linked with one another. The linkage is done in two steps and after creation of both queue ends: This API allows to update the link in the head object and can thus be used by the same process that created the head object and the counterpart <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a3c25adfaa1191482b13867dd12cc0479">vsq_linkQueueTailWithHead()</a> will do the same for the tail object and from another process.<br  />
 Note, this function is just the same as <a class="el" href="vsq__thread_safe_queue_variable_size_8c.html#a8cb622a1c7423e6b7f7cbe657670c299">vsq_linkQueueHeadWithTail()</a> but for port objects as used in the dispatcher engine. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">portHead</td><td>The newly created queue head port object, which is now linked to its tail. </td></tr>
    <tr><td class="paramname">portTail</td><td>This is the tail port object, * <em>portHead</em> is going to cooperate with. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If memory access restrictions don't play a role, then function <a class="el" href="vsq__dispatcher_port_interface_8c.html#a48c782da13efd442ea5c208afc3b3c85">vsq_createEventQueue()</a> will be the better alternative, it creates both ports, head and tail, and links them - all in one call. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_083cb9b71a0904a1342a47f5208adb1c.html">connectors</a></li><li class="navelem"><a class="el" href="vsq__dispatcher_port_interface_8h.html">vsq_dispatcherPortInterface.h</a></li>
    <li class="footer">Generated on Tue Oct 4 2022 15:29:09 for comFramework - CAN Interface by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
