<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>safe-RTOS: rtos_scheduler.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">safe-RTOS<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">safe-RTOS - A simple RTOS with safety support for MPC5748G</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtos__scheduler_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rtos_scheduler.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &quot;MPC5748G.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos_8h_source.html">rtos.h</a>&quot;</code><br />
</div>
<p><a href="rtos__scheduler_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:af0330dcbcc59b2eecf68580d503a170a"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#af0330dcbcc59b2eecf68580d503a170a">RTOS_SYSCALL_SEND_EVENT</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:af0330dcbcc59b2eecf68580d503a170a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aee3854fa52abb8a035b65816e1ace014"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#aee3854fa52abb8a035b65816e1ace014">rtos_eventProcDesc_t</a></td></tr>
<tr class="separator:aee3854fa52abb8a035b65816e1ace014"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a5e6e4c34e1b55dccfd5ddd75fe0d7af3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#a5e6e4c34e1b55dccfd5ddd75fe0d7af3">rtos_osGetCurrentInterruptPriority</a> (void)</td></tr>
<tr class="separator:a5e6e4c34e1b55dccfd5ddd75fe0d7af3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a7570c639d852a572a5d24c2b05e369"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#a1a7570c639d852a572a5d24c2b05e369">rtos_osIsInterrupt</a> (void)</td></tr>
<tr class="separator:a1a7570c639d852a572a5d24c2b05e369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab4b1e3ab8979d773d9901b00516ba6f4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#ab4b1e3ab8979d773d9901b00516ba6f4">rtos_osCreateEventProcessor</a> (unsigned int *pEventId, unsigned int tiCycleInMs, unsigned int tiFirstActivationInMs, unsigned int priority, unsigned int minPIDToTriggerThisEvProc, bool useCountableEvents, uint32_t taskParam)</td></tr>
<tr class="separator:ab4b1e3ab8979d773d9901b00516ba6f4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afa05f4b19f31a1df4b2aff6874b2b3fc"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#afa05f4b19f31a1df4b2aff6874b2b3fc">rtos_osCreateSwTriggeredEventProcessor</a> (unsigned int *pEventId, unsigned int priority, unsigned int minPIDToTriggerThisEvProc)</td></tr>
<tr class="separator:afa05f4b19f31a1df4b2aff6874b2b3fc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addefdb75681eaad3fd2699f2dabf85ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#addefdb75681eaad3fd2699f2dabf85ba">rtos_osRegisterInitTask</a> (int32_t(*initTaskFct)(uint32_t PID), unsigned int PID, unsigned int tiMaxInUs)</td></tr>
<tr class="separator:addefdb75681eaad3fd2699f2dabf85ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefee2f51c59b76dc3607ab9b2800f778"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#aefee2f51c59b76dc3607ab9b2800f778">rtos_osRegisterUserTask</a> (unsigned int idEventProc, int32_t(*userModeTaskFct)(uint32_t PID, uint32_t evMaskOrTaskParam), unsigned int PID, unsigned int tiMaxInUs)</td></tr>
<tr class="separator:aefee2f51c59b76dc3607ab9b2800f778"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af4d5d3b76d417abfcd2e1104fb4e1781"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#af4d5d3b76d417abfcd2e1104fb4e1781">rtos_osRegisterOSTask</a> (unsigned int idEventProc, void(*osTaskFct)(uint32_t evMaskOrTaskParam))</td></tr>
<tr class="separator:af4d5d3b76d417abfcd2e1104fb4e1781"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel</a> (void)</td></tr>
<tr class="separator:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90505523c85decbc51c6835d425f861e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#a90505523c85decbc51c6835d425f861e">rtos_osSuspendAllTasksByPriority</a> (uint32_t suspendUpToThisTaskPriority)</td></tr>
<tr class="separator:a90505523c85decbc51c6835d425f861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority</a> (uint32_t resumeDownToThisTaskPriority)</td></tr>
<tr class="separator:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af741852d8d40bcd61fc141fc96c0523b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#af741852d8d40bcd61fc141fc96c0523b">rtos_getNoActivationLoss</a> (unsigned int idTask)</td></tr>
<tr class="separator:af741852d8d40bcd61fc141fc96c0523b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b8aa11db60df29c343007d79157eef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8h.html#a11b8aa11db60df29c343007d79157eef">rtos_osGetTaskBasePriority</a> (void)</td></tr>
<tr class="separator:a11b8aa11db60df29c343007d79157eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Definition of global interface of module <a class="el" href="rtos__scheduler_8c.html">rtos_scheduler.c</a></p>
<p >Copyright (C) 2019-2024 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="af0330dcbcc59b2eecf68580d503a170a" name="af0330dcbcc59b2eecf68580d503a170a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af0330dcbcc59b2eecf68580d503a170a">&#9670;&nbsp;</a></span>RTOS_SYSCALL_SEND_EVENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_SYSCALL_SEND_EVENT&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >System call index of function <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>, offered by this module. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aee3854fa52abb8a035b65816e1ace014" name="aee3854fa52abb8a035b65816e1ace014"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aee3854fa52abb8a035b65816e1ace014">&#9670;&nbsp;</a></span>rtos_eventProcDesc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The representation of a task triggering event processor.<br  />
 Note, to support APIs for configuration at runtime, the object contains both, runtime information and static configuration data. A resource optimized implementation could separate both parts and it could then put the configuration data into ROM. (Instead of offering the run-time configuration by APIs.) This holds for the task representation, too. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a5e6e4c34e1b55dccfd5ddd75fe0d7af3" name="a5e6e4c34e1b55dccfd5ddd75fe0d7af3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5e6e4c34e1b55dccfd5ddd75fe0d7af3">&#9670;&nbsp;</a></span>rtos_osGetCurrentInterruptPriority()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> unsigned int rtos_osGetCurrentInterruptPriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Query the current interrupt priority level. </p><dl class="section return"><dt>Returns</dt><dd>Get the interrupt level in the range 0..15. 1..15 are returned to ISRs running on that level and 0 ist returned if the function is called from an OS task. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from the OS context only. User tasks don't have the privileges to call this function. </dd></dl>

</div>
</div>
<a id="a1a7570c639d852a572a5d24c2b05e369" name="a1a7570c639d852a572a5d24c2b05e369"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a7570c639d852a572a5d24c2b05e369">&#9670;&nbsp;</a></span>rtos_osIsInterrupt()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool rtos_osIsInterrupt </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Query if we are running code inside an ISR. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if we are in an External Interrupt and <em>false</em> otherwise (i.e. including system calls, which are often considered software interrupts). </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from the OS context only. User tasks don't have the privileges to call this function. </dd></dl>

</div>
</div>
<a id="ab4b1e3ab8979d773d9901b00516ba6f4" name="ab4b1e3ab8979d773d9901b00516ba6f4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab4b1e3ab8979d773d9901b00516ba6f4">&#9670;&nbsp;</a></span>rtos_osCreateEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiCycleInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiFirstActivationInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timerUsesCountableEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timerTaskTriggerParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creation of an event. The event can be cyclically triggering or software triggerd.</p>
<p >Creation of an event processor. The event processor can produce a periodic timer event or it can be software triggered. An event processor is needed to activate a user task. Therefore, any reasonable application will create at least one event processor.<br  />
 This function is repeatedly called by the application code for each required event processor. All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>.<br  />
 </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>All event processors are identified by a positive integer. Normally this ID is returned by reference in * <em>pEvProcId</em>. If the event processor cannot be created then <a class="el" href="rtos_8h.html#a6e59eb94bd87ab947627170aa96ba093">RTOS_INVALID_EVENT_PROC_ID</a> is returned in * <em>pEvProcId</em>.<br  />
 Note, it is guaranteed to the caller that the returned ID is not an arbitrary, meaningless number. Instead, the ID is counted from zero in order of creating event processors. The first call of this function will return 0, the second 1, and so on. This simplifies ID handling in the application code, constants can mostly be applied as the IDs are effectively known at compile time. </td></tr>
    <tr><td class="paramname">tiCycleInMs</td><td>The period time for regularly triggering events in ms.<br  />
 The permitted range is 0..2^30-1. 0 means no regular, timer controlled trigger and the event processor is enabled only for software trigger using <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> (permitted for interrupts or other tasks). </td></tr>
    <tr><td class="paramname">tiFirstActivationInMs</td><td>The first trigger by timer event in ms after start of kernel. The permitted range is 0..2^30-1.<br  />
 Note, this setting is useless if a cycle time zero in <em>tiCycleInMs</em> specifies a non regular event. <em>tiFirstActivationInMs</em> needs to be zero in this case, too. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor in the range 1..UINT_MAX. Different event processors can share the same priority. The priority of an event processor is the priority of all associated tasks at the same time. The execution of tasks, which share the priority will be serialized when they are activated at same time or with overlap.<br  />
 Note the safety constraint that task priorities above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> are available only to event processors, which solely have associated tasks that belong to the process with highest process ID in use. (Which is assumed to be the safety process.)<br  />
 Note, the order in which event processors are created can affect the priority in a certain sense. If two event processors are created with same priority and when they at runtime become due at the same OS time tick then the earlier created processor will activate its associated tasks before the later created. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Events can be notified by user code, e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>. However, tasks belonging to less privileged processes must not generally have permission to trigger event processors that may activate tasks of higher privileged processes. Since an event processor is not process related, we make the minimum process ID, which is required to notify the event to the processor, an explicitly configured property of the processor.<br  />
 Only tasks belonging to a process with PID &gt;= <em>minPIDToTriggerThisEvProc</em> are permitted to trigger this event processor.<br  />
 The range of <em>minPIDToTriggerThisEvProc</em> is 0 ... (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1). 0 and 1 both mean, all processes may trigger the event processor, (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) means only OS code can trigger it. (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) is available as <a class="el" href="rtos_8h.html#a60b38f5e5b8a935733b453bfd6b18c2b">RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</a>, too. </td></tr>
    <tr><td class="paramname">timerUsesCountableEvents</td><td>When the OS timer triggers a due event processor then it needs to decide whether to use it as countable or ordinary event. This decision is configured per event but once for ever.<br  />
 <em>timerUsesCountableEvents</em> doesn't care for solely SW notified events, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
    <tr><td class="paramname">timerTaskTriggerParam</td><td>For timer triggered event processors, this is the argument of the trigger operation. For countable events, this is the mask specifying the variable storing the multiplicity of the notified event. Timer triggers always use multiplicity 1 per trigger, i.e., per due time. The number of bits set determine, how many triggers can be stored until a task overflow is reported. For example, with <em>timerTaskTriggerParam=3</em>, a task overflow would be recorded only, when the event has been found non-idle at four consecutive due times. For countable events, <em>timerTaskTriggerParam</em> must not be zero.<br  />
 If <em>timerUsesCountableEvents=false</em> then <em>timerTaskTriggerParam</em> will be used as task parameter that is delivered to all associated task functions on every successful trigger. <em>timerTaskTriggerParam</em> doesn't care for solely SW triggered event processors, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Effectively, this object can be considered the descriptor of the idle task. </dd></dl>

</div>
</div>
<a id="afa05f4b19f31a1df4b2aff6874b2b3fc" name="afa05f4b19f31a1df4b2aff6874b2b3fc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afa05f4b19f31a1df4b2aff6874b2b3fc">&#9670;&nbsp;</a></span>rtos_osCreateSwTriggeredEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateSwTriggeredEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creation of an event, which will be triggered by software only. No timer triggers.</p>
<p >A simplified call of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> to create an event processor, which won't be triggered by timer events. (The function internally calls <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> with <em>tiCycleInMs=0</em>.) Most of the function arguments of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> are meaningless for event processors triggered by software only, which makes the use of this API more appropriate. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>The event processor ID is returned by reference. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Privileges management for this event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addefdb75681eaad3fd2699f2dabf85ba" name="addefdb75681eaad3fd2699f2dabf85ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addefdb75681eaad3fd2699f2dabf85ba">&#9670;&nbsp;</a></span>rtos_osRegisterInitTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterInitTask </td>
          <td>(</td>
          <td class="paramtype">int32_t(*)(uint32_t PID)&#160;</td>
          <td class="paramname"><em>initTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for user mode or operating system initialization task.</p>
<p >Registration of a process initialization task. This function is typically repeatedly called by the operating system initialization code as often as there are processes, which need initialization.<br  />
 Initialization functions are particularly useful for the user processes. They allow having user provided code, that is run prior to the start of the scheduler, in a still race condition free environment but already with full protection against runtime failures.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of initialization tasks is one per process and one for the OS. If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initTaskFct</td><td>The initialization function, which is run once in process <em>PID</em>.<br  />
 The function gets the ID of the process it belongs to as argument.<br  />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process and the scheduler will not start up. </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>) plus the kernel process, which has ID 0. The range of process IDs to be used here is 0 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br  />
 At kernel initialization time, the registered user process initialization functions will be called in the order of rising PID, followed by the registered kernel process initialization function. </td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the function execution in Microseconds. The budget relates to deadline monitoring, i.e., it is a world time budget, not an execution time budget.<br  />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br  />
 A value of zero means that deadline monitoring is disabled for the run of the initialization function.<br  />
 There's no deadline monitoring for OS tasks. If <em>PID</em> is zero then <em>tiTaskMaxInUS</em> meeds to be zero, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="aefee2f51c59b76dc3607ab9b2800f778" name="aefee2f51c59b76dc3607ab9b2800f778"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefee2f51c59b76dc3607ab9b2800f778">&#9670;&nbsp;</a></span>rtos_osRegisterUserTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterUserTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(uint32_t PID, uint32_t evMaskOrTaskParam)&#160;</td>
          <td class="paramname"><em>userModeTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for scheduled user mode tasks. </p>

</div>
</div>
<a id="af4d5d3b76d417abfcd2e1104fb4e1781" name="af4d5d3b76d417abfcd2e1104fb4e1781"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af4d5d3b76d417abfcd2e1104fb4e1781">&#9670;&nbsp;</a></span>rtos_osRegisterOSTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterOSTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint32_t evMaskOrTaskParam)&#160;</td>
          <td class="paramname"><em>osTaskFct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for scheduled operating system tasks. </p>

</div>
</div>
<a id="ab24d0fa9208d5675e03cc931a08e52fd" name="ab24d0fa9208d5675e03cc931a08e52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24d0fa9208d5675e03cc931a08e52fd">&#9670;&nbsp;</a></span>rtos_osInitKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osInitKernel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kernel initialization.</p>
<p >Initialization and start of the RTOS kernel.<br  />
 The function initializes a hardware device to produce a regular clock tick and connects the OS schedule function onOsTimerTick() with the interrupt raised by this timer device. After return, the RTOS is running with a regular clock tick for scheduling the tasks. Period time is <a class="el" href="rtos_8config_8h.html#a7bf97b46b6e438370c03ef73f06df753">RTOS_CLOCK_TICK_IN_MS_CORE_0</a> (_1, _2) Milliseconds.<br  />
 The function can be called before or after the External Interrupts are enabled at the CPU (see <a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a>). Normal behavior is however, no to resume the interrupt processing before and let this be done by <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the scheduler could be started. The function returns a non zero value from enumeration <em>rtos_errorCode_t</em> if a configuration error is detected. The software must not start up in this case. Since it is only about static configuration, the returned error may be appropriately handled by an assertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The RTOS kernel applies the Periodic Interrupt Timer 0 (PIT0) as clock source. This timer is reserved to the RTOS and must not be used at all by some other code. </dd>
<dd>
All application tasks need to be registered before invoking this function, see <a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask()</a>, <a class="el" href="rtos__scheduler_8c.html#af7038ee6faaa29605b9129d4f0c9d840">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask()</a>. </dd>
<dd>
This function must be called from the OS context only. The call of this function will end the operating system initialization phase. </dd></dl>

</div>
</div>
<a id="a90505523c85decbc51c6835d425f861e" name="a90505523c85decbc51c6835d425f861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90505523c85decbc51c6835d425f861e">&#9670;&nbsp;</a></span>rtos_osSuspendAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtos_osSuspendAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suspendUpToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enter critcal section; partially suspend task scheduling.</p>
<p >Priority ceiling protocol (PCP), partial scheduler lock: All tasks up to the specified task priority level won't be handled by the CPU any more. This function is intended for implementing mutual exclusion of sub-sets of tasks.<br  />
 Note, the use of the other function pairs<br  />
</p><ul>
<li><a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ae6935dc959dd97bcbe04070a477c2ac3">rtos_osLeaveCriticalSection()</a><br  />
or<br  />
</li>
<li><a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a><br  />
locks all interrupt processing and no other task (or interrupt handler) can become active while the task is inside the critical section code. With respect to behavior, using the PCP API is much better: Call this function with the highest priority of all tasks, which should be locked, i.e., which compete for the resource or critical section to protect. This may still lock other, non competing tasks, but at least all interrupts and all non competing tasks of higher priority will be served.<br  />
 The major drawback of using the PCP instead of the interrupt lock API is the significantly higher expense; particularly at the end of the critical section, when resuming the scheduling again: A recursive call of the scheduler is required to see if some tasks of higher priority had become ready during the lock time. Therefore, locking the interrupts is likely the better choice for very short critical sections.<br  />
 To release the protected resource or to leave the critical section, call the counterpart function <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>, which restores the original task priority level. <dl class="section return"><dt>Returns</dt><dd>The task priority level at entry into this function (and into the critical section) is returned. This level needs to be restored on exit from the critical section using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suspendUpToThisTaskPriority</td><td>All tasks up to and including this priority will be locked, i.e., they won't be executed even if they'd become ready. The CPU will not handle them until the priority level is lowered again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The critical section shaped with this API from an OS task guarantees mutual exclusion with critical section code shaped with the other API <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a> from a user code task. </dd>
<dd>
To support the use case of nested calls of OSEK/VDX like GetResource/ReleaseResource functions, this function compares the stated value to the current priority level. If <em>suspendUpToThisTaskPriority</em> is less than the current value then the current value is not altered. The function still returns the current value and the calling code doesn't need to take care: It can unconditionally end a critical section with <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> stating the returned priority level value. (The resume function will have no effect in this case.) This makes the OSEK like functions usable without deep inside or full transparency of the priority levels behind the scene; just use the pairs of Get-/ResumeResource, be they nested or not. </dd>
<dd>
The use of this function to implement critical sections is usually quite static. For any protected entity (usually a data object or I/O device) the set of competing tasks normally is a compile time known. The priority level to set for entry into the critical section is the maximum of the priorities of all tasks in the set. The priority level to restore on exit from the critical section is the priority of the calling task. All of this static knowledge would typically be put into encapsulating macros that actually invoke this function. (OSEK/VDX like environments would use this function pair to implement the GetResource/ReleaseResource concept.) </dd>
<dd>
Any change of the current priority level made with this function needs to be undone using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> and still inside the same task. It is not possible to consider this function a mutex, which can be acquired in one task activation and which can be released in an arbitrary later task activation or from another task.<br  />
 Moreover, different to the user mode variant of the PCP function pair, there is no restoration of the current priority level at task termination time.<br  />
 An assertion in the scheduler will likely fire if the two PCP APIs are not properly used in pairs. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3edc62289271a4f7bcdbcc02b1680c8e" name="a3edc62289271a4f7bcdbcc02b1680c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edc62289271a4f7bcdbcc02b1680c8e">&#9670;&nbsp;</a></span>rtos_osResumeAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osResumeAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resumeDownToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Leave critical section; resume scheduling of tasks.</p>
<p >This function is called to end a critical section of code, which requires mutual exclusion of two or more tasks. It is the counterpart of function rtos_osSuspendAllInterruptsByPriority(), refer to that function for more details.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resumeDownToThisTaskPriority</td><td>All tasks/interrupts above this priority level are resumed again. All tasks/interrupts up to and including this priority remain locked.<br  />
 You will normally pass in the value got from the related call of rtos_osSuspendAllInterruptsByPriority(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caution, this function lowers the current task priority level to the stated value regardless of the initial value for the task. Accidentally lowering the task priority level below the configured task priority (i.e., the priority inherited from the triggering event processor) will have unpredictable consequences. </dd>
<dd>
Different to the user mode variant of the function, <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>, there is no restoration of the current priority level at task termination time. For OS tasks, there's no option to omit the resume operation if a critical section should last till the end of the task - and there's no need to attempt this neither: The OS variant of the function doesn't involve the overhead of a system call and no execution time would be saved as for the user variant. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>

</div>
</div>
<a id="af741852d8d40bcd61fc141fc96c0523b" name="af741852d8d40bcd61fc141fc96c0523b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af741852d8d40bcd61fc141fc96c0523b">&#9670;&nbsp;</a></span>rtos_getNoActivationLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoActivationLoss </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the current number of failed task activations since start of the RTOS scheduler.</p>
<p >An event processor, which becomes due may not be able to activate all its associated tasks because they didn't terminate yet after their previous activation. It doesn't matter if this happens because a cyclic task becomes due or because the event processor has been triggered by software (e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>). The scheduler counts the failing activations on a per event processor base. The current value can be queried with this function. </p><dl class="section return"><dt>Returns</dt><dd>Get the current number of triggers of the given event processor, which have failed since start of the RTOS scheduler. The counter is saturated and will not wrap around.<br  />
 The returned count can be understood as number of task overrun events for all associated tasks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>Each event processor has its own counter. The value is returned for the given processor. The range is 0 .. number of registered event processors minus one (double-checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, the OS context and a user task. </dd></dl>

</div>
</div>
<a id="a11b8aa11db60df29c343007d79157eef" name="a11b8aa11db60df29c343007d79157eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b8aa11db60df29c343007d79157eef">&#9670;&nbsp;</a></span>rtos_osGetTaskBasePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_osGetTaskBasePriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A cyclic or event task can query its base priority. For OS tasks only.</p>
<p >A cyclic or event task can query its base priority. </p><dl class="section return"><dt>Returns</dt><dd>Get the base priority of the task, which calls this function. It's the priority of the event processor it is associated with. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from an OS task only. Any attempt to call it from a user task will cause a privileged exception. </dd>
<dd>
The function must not be called from an ISR. The result would be undefined as there is no event processor, which such a handler function would be associated with. However, with respect to safety or stability, there's no problem in doing this. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_9cd24f4fec2e6f6bedbcc5407321d78a.html">system</a></li><li class="navelem"><a class="el" href="dir_34effe5aae1be93d744f092611be46f1.html">RTOS</a></li><li class="navelem"><a class="el" href="rtos__scheduler_8h.html">rtos_scheduler.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
