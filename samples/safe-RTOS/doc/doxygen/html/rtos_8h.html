<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>safe-RTOS: rtos.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">safe-RTOS<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">safe-RTOS - A simple RTOS with safety support for MPC5748G</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtos_8h.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rtos.h File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;MPC5748G.h&quot;</code><br />
<code>#include &quot;<a class="el" href="typ__types_8h_source.html">typ_types.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos_8config_8h_source.html">rtos.config.h</a>&quot;</code><br />
</div>
<p><a href="rtos_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a18500a557ecd5ebbcefbacba22b58d7e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a18500a557ecd5ebbcefbacba22b58d7e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab004fb06d9894fe6afdc8385f33602cb"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab004fb06d9894fe6afdc8385f33602cb">RTOS_NO_CORES</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:ab004fb06d9894fe6afdc8385f33602cb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e59eb94bd87ab947627170aa96ba093"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a6e59eb94bd87ab947627170aa96ba093">RTOS_INVALID_EVENT_PROC_ID</a>&#160;&#160;&#160;(<a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>)</td></tr>
<tr class="separator:a6e59eb94bd87ab947627170aa96ba093"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f387767ac5768e23a4a7aa1ef5084f7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a>&#160;&#160;&#160;26843545</td></tr>
<tr class="separator:a1f387767ac5768e23a4a7aa1ef5084f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a60b38f5e5b8a935733b453bfd6b18c2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a60b38f5e5b8a935733b453bfd6b18c2b">RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</a>&#160;&#160;&#160;((<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>)+1u)</td></tr>
<tr class="separator:a60b38f5e5b8a935733b453bfd6b18c2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3e599fcdd6c1ffc7c78aa83bf3d890c6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a3e599fcdd6c1ffc7c78aa83bf3d890c6">RTOS_NO_ERR_PRC</a>&#160;&#160;&#160;13</td></tr>
<tr class="separator:a3e599fcdd6c1ffc7c78aa83bf3d890c6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92e9d0974a02d2aeaa4a4728551f094e"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a92e9d0974a02d2aeaa4a4728551f094e">RTOS_ERR_PRC_PROCESS_ABORT</a>&#160;&#160;&#160;0</td></tr>
<tr class="separator:a92e9d0974a02d2aeaa4a4728551f094e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c3c87d0d5a675b6ebe299611b001193"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a5c3c87d0d5a675b6ebe299611b001193">RTOS_ERR_PRC_MACHINE_CHECK</a>&#160;&#160;&#160;1</td></tr>
<tr class="separator:a5c3c87d0d5a675b6ebe299611b001193"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34966960c63fafadc4a26f975463ecf5"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a34966960c63fafadc4a26f975463ecf5">RTOS_ERR_PRC_DEADLINE</a>&#160;&#160;&#160;2</td></tr>
<tr class="separator:a34966960c63fafadc4a26f975463ecf5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5167e186d61f53208b26de65a6ad48e2"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a5167e186d61f53208b26de65a6ad48e2">RTOS_ERR_PRC_DI_STORAGE</a>&#160;&#160;&#160;3</td></tr>
<tr class="separator:a5167e186d61f53208b26de65a6ad48e2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6e76056aa81bac40477ab9beecb6c9c4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a6e76056aa81bac40477ab9beecb6c9c4">RTOS_ERR_PRC_SYS_CALL_BAD_ARG</a>&#160;&#160;&#160;4</td></tr>
<tr class="separator:a6e76056aa81bac40477ab9beecb6c9c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3d24664c8ff5376976146cfa2950311f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a3d24664c8ff5376976146cfa2950311f">RTOS_ERR_PRC_ALIGNMENT</a>&#160;&#160;&#160;5</td></tr>
<tr class="separator:a3d24664c8ff5376976146cfa2950311f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0172049df63fe882ed7bacdb1d395600"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a0172049df63fe882ed7bacdb1d395600">RTOS_ERR_PRC_PROGRAM_INTERRUPT</a>&#160;&#160;&#160;6</td></tr>
<tr class="separator:a0172049df63fe882ed7bacdb1d395600"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9b1aca495ec0f1b9dec99119f75b89e7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a9b1aca495ec0f1b9dec99119f75b89e7">RTOS_ERR_PRC_FPU_UNAVAIL</a>&#160;&#160;&#160;7</td></tr>
<tr class="separator:a9b1aca495ec0f1b9dec99119f75b89e7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17067175c3c4f70b96f59a1b85192e8"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#af17067175c3c4f70b96f59a1b85192e8">RTOS_ERR_PRC_TBL_DATA</a>&#160;&#160;&#160;8</td></tr>
<tr class="separator:af17067175c3c4f70b96f59a1b85192e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad85879d045e06a015caa8cd62a907500"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ad85879d045e06a015caa8cd62a907500">RTOS_ERR_PRC_TBL_INSTRUCTION</a>&#160;&#160;&#160;9</td></tr>
<tr class="separator:ad85879d045e06a015caa8cd62a907500"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af17be265e573ec7a6908a84693422c0c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#af17be265e573ec7a6908a84693422c0c">RTOS_ERR_PRC_SPE_INSTRUCTION</a>&#160;&#160;&#160;10</td></tr>
<tr class="separator:af17be265e573ec7a6908a84693422c0c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32453f0c8f6c8845c879a54e4288c2b4"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a>&#160;&#160;&#160;11</td></tr>
<tr class="separator:a32453f0c8f6c8845c879a54e4288c2b4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a82df28472250ffa82b5cf33dbb41c93f"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a82df28472250ffa82b5cf33dbb41c93f">RTOS_ERR_PRC_RESERVED</a>&#160;&#160;&#160;12</td></tr>
<tr class="separator:a82df28472250ffa82b5cf33dbb41c93f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eac206295711ad1e5346d367f9ce74c"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a7eac206295711ad1e5346d367f9ce74c">RTOS_SC_TABLE_ENTRY</a>(addrOfFct,  confClass)</td></tr>
<tr class="separator:a7eac206295711ad1e5346d367f9ce74c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f4937c654a76ca43d70366f0f461cd"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#af6f4937c654a76ca43d70366f0f461cd">RTOS_TI_MS2TICKS</a>(tiInMs)&#160;&#160;&#160;((tiInMs)*80000u)</td></tr>
<tr class="separator:af6f4937c654a76ca43d70366f0f461cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50879c034063dd071531d12bc8c3f6d6"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a50879c034063dd071531d12bc8c3f6d6">RTOS_TI_US2TICKS</a>(tiInUs)&#160;&#160;&#160;((tiInUs)*80u)</td></tr>
<tr class="separator:a50879c034063dd071531d12bc8c3f6d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a83cb2901c9810c8c160a1b0d8cf7fa2b"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a83cb2901c9810c8c160a1b0d8cf7fa2b">RTOS_CORE_Z4A</a>&#160;&#160;&#160;0u</td></tr>
<tr class="separator:a83cb2901c9810c8c160a1b0d8cf7fa2b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7728701da34558de9c44cad1f8ff7bda"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a7728701da34558de9c44cad1f8ff7bda">RTOS_CORE_Z4B</a>&#160;&#160;&#160;1u</td></tr>
<tr class="separator:a7728701da34558de9c44cad1f8ff7bda"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4bdfa60bad6565f0e56183f260550e60"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a4bdfa60bad6565f0e56183f260550e60">RTOS_CORE_Z2</a>&#160;&#160;&#160;2u</td></tr>
<tr class="separator:a4bdfa60bad6565f0e56183f260550e60"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4679400d0f8b946b562d7efd20d09573"><td class="memItemLeft" align="right" valign="top"><a id="a4679400d0f8b946b562d7efd20d09573" name="a4679400d0f8b946b562d7efd20d09573"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><b>RTOS_SPR_PIR</b>&#160;&#160;&#160;286 /* SPR index of PIR. */</td></tr>
<tr class="separator:a4679400d0f8b946b562d7efd20d09573"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="typedef-members" name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa9ea5e791ee7404aad7ae37ef35cde7d"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aa9ea5e791ee7404aad7ae37ef35cde7d">rtos_interruptServiceRoutine_t</a>) (void)</td></tr>
<tr class="separator:aa9ea5e791ee7404aad7ae37ef35cde7d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acb6b370f441999d9f539d81ac6118f9e"><td class="memItemLeft" align="right" valign="top">typedef enum <a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#acb6b370f441999d9f539d81ac6118f9e">rtos_errorCode_t</a></td></tr>
<tr class="separator:acb6b370f441999d9f539d81ac6118f9e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a140a5125319655d63a8a353a6c29ba90"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a140a5125319655d63a8a353a6c29ba90">rtos_taskDesc_t</a></td></tr>
<tr class="separator:a140a5125319655d63a8a353a6c29ba90"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="enum-members" name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:ae6a79bdc418d571b34528a8d2c9f49d1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> { <br />
&#160;&#160;<b>rtos_err_noError</b> = 0
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a19304aaba258a01530cb891f69fa78dc">rtos_err_tooManyEventsCreated</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a88b39e365c36b7864305b1020d167917">rtos_err_invalidEventPrio</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a7997aabfed01a9d3dc744a0971b21292">rtos_err_badEventTiming</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a19dd8bb137f08cb4484ba25522bfeaf4">rtos_err_eventNotTriggerable</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a9d20065342c519702d9db027a9487ce6">rtos_err_configurationOfRunningKernel</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1aa229366559e09226d96b6c8e418d6c31">rtos_err_badEventProcId</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1aedf7c2df4f697093e634b0b7060743ea">rtos_err_badCountableTimerEventMask</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a218ea0e64c7b0278fa114aa3aac80d60">rtos_err_badProcessId</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a385adfe034f15b8a93c11278c1d01aba">rtos_err_tooManyTasksRegistered</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a0a3176c426b81c3eed1a4b7cbd5ef371">rtos_err_noEvOrTaskRegistered</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a5c68548c849e3bab1e3b1a0eaba95b4e">rtos_err_evProcWithoutTask</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a6227d0116801a4e94ab0b613b747407f">rtos_err_badTaskFunction</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a4658c821f83b720ed7d7b4713a178e0d">rtos_err_taskBudgetTooBig</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1ad285146c97ddb0e2318b0e58c0f4644b">rtos_err_initTaskRedefined</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1ab430b681a53eb533e44a6260874452fb">rtos_err_initTaskFailed</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a5535320638a30f3fcdfc642712eb5c6f">rtos_err_prcStackInvalid</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a30eeebbb9e9807fcd75e7359cf358953">rtos_err_taskBelongsToInvalidPrc</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1abae1c422a879faa29d9034e7a4db112c">rtos_err_highPrioTaskInLowPrivPrc</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a5125283431d030b220aefa5244ebb89b">rtos_err_runTaskBadPermission</a>
, <br />
&#160;&#160;<a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1a998a63eb85afdba5f8dbdfd1bdd15d0e">rtos_err_suspendPrcBadPermission</a>
, <br />
&#160;&#160;<b>rtor_err_noErrorCodes</b>
<br />
 }</td></tr>
<tr class="separator:ae6a79bdc418d571b34528a8d2c9f49d1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aae28a732a3918bcd90346b192bf46293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor</a> (unsigned int *pEvProcId, unsigned int tiCycleInMs, unsigned int tiFirstActivationInMs, unsigned int priority, unsigned int minPIDToTriggerThisEvProc, bool timerUsesCountableEvents, uint32_t timerTaskTriggerParam)</td></tr>
<tr class="separator:aae28a732a3918bcd90346b192bf46293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b10ac33293a44882ccbc069f1c9af2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor</a> (unsigned int *pEvProcId, unsigned int priority, unsigned int minPIDToTriggerThisEvProc)</td></tr>
<tr class="separator:a3b10ac33293a44882ccbc069f1c9af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addefdb75681eaad3fd2699f2dabf85ba"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#addefdb75681eaad3fd2699f2dabf85ba">rtos_osRegisterInitTask</a> (int32_t(*initTaskFct)(uint32_t PID), unsigned int PID, unsigned int tiMaxInUs)</td></tr>
<tr class="separator:addefdb75681eaad3fd2699f2dabf85ba"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c0aa893b9fa5476eb375842517340c9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a0c0aa893b9fa5476eb375842517340c9">rtos_osRegisterUserTask</a> (unsigned int idEventProc, int32_t(*userModeTaskFct)(uint32_t PID, uint32_t taskParam), unsigned int PID, unsigned int tiMaxInUs)</td></tr>
<tr class="separator:a0c0aa893b9fa5476eb375842517340c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd8691016ac24135e19b2477008750e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask</a> (unsigned int idEventProc, void(*osTaskFct)(uint32_t taskParam))</td></tr>
<tr class="separator:a2cd8691016ac24135e19b2477008750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a271864adecb3d629668674fa0815a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a88a271864adecb3d629668674fa0815a">rtos_osInitINTCInterruptController</a> (void)</td></tr>
<tr class="separator:a88a271864adecb3d629668674fa0815a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:accff5b6fe96e98a366aeab1442a3efe9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#accff5b6fe96e98a366aeab1442a3efe9">rtos_osRegisterInterruptHandler</a> (<a class="el" href="rtos_8h.html#aa9ea5e791ee7404aad7ae37ef35cde7d">rtos_interruptServiceRoutine_t</a> interruptServiceRoutine, unsigned int processorID, unsigned int vectorNum, unsigned int psrPriority, bool isPreemptable)</td></tr>
<tr class="separator:accff5b6fe96e98a366aeab1442a3efe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeaae84408e099b28495d703994100c16"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aeaae84408e099b28495d703994100c16">rtos_osGrantPermissionRunTask</a> (unsigned int pidOfCallingTask, unsigned int targetPID)</td></tr>
<tr class="separator:aeaae84408e099b28495d703994100c16"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a68f8200c57d5390e8937fc2a78af55b6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a68f8200c57d5390e8937fc2a78af55b6">rtos_osGrantPermissionSuspendProcess</a> (unsigned int pidOfCallingTask, unsigned int targetPID)</td></tr>
<tr class="separator:a68f8200c57d5390e8937fc2a78af55b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel</a> (void)</td></tr>
<tr class="separator:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb904958a596625132235635ab2a191"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent</a> (unsigned int idEventProc, uint32_t taskParam)</td></tr>
<tr class="separator:acdb904958a596625132235635ab2a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3edcc197ad85b1f309ad2efe03586"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable</a> (unsigned int idEventProc, uint32_t evMask)</td></tr>
<tr class="separator:a2ac3edcc197ad85b1f309ad2efe03586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae428115e507b116469a1859cf20b4c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aae428115e507b116469a1859cf20b4c5">rtos_osSendEventMultiple</a> (unsigned int idEventProc, uint32_t evMask, uint8_t count)</td></tr>
<tr class="separator:aae428115e507b116469a1859cf20b4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90505523c85decbc51c6835d425f861e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a90505523c85decbc51c6835d425f861e">rtos_osSuspendAllTasksByPriority</a> (uint32_t suspendUpToThisTaskPriority)</td></tr>
<tr class="separator:a90505523c85decbc51c6835d425f861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority</a> (uint32_t resumeDownToThisTaskPriority)</td></tr>
<tr class="separator:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4e09fafaef05f7c20adb63eaefe0b29"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority</a> (uint32_t suspendUpToThisPriority)</td></tr>
<tr class="separator:aa4e09fafaef05f7c20adb63eaefe0b29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab749e1296f04521109c29ce521ea770e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority</a> (uint32_t resumeDownToThisPriority)</td></tr>
<tr class="separator:ab749e1296f04521109c29ce521ea770e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5d61ad8cb2aced31246ad1fdbb44faa7"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a5d61ad8cb2aced31246ad1fdbb44faa7">rtos_systemCall</a> (uint32_t idxSysCall,...)</td></tr>
<tr class="separator:a5d61ad8cb2aced31246ad1fdbb44faa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4f1f4dbf31cbe5dd7c48a1f4ea2d594f"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a4f1f4dbf31cbe5dd7c48a1f4ea2d594f">rtos_checkUserCodeWritePtr</a> (unsigned int PID, const void *address, size_t noBytes)</td></tr>
<tr class="separator:a4f1f4dbf31cbe5dd7c48a1f4ea2d594f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a42156b46c1f83c80cd7a1630d91e12cc"><td class="memItemLeft" align="right" valign="top">_Noreturn void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a42156b46c1f83c80cd7a1630d91e12cc">rtos_osSystemCallBadArgument</a> (void)</td></tr>
<tr class="separator:a42156b46c1f83c80cd7a1630d91e12cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec7855aa3c9d3d400011adab6c8893"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab1ec7855aa3c9d3d400011adab6c8893">rtos_getNoActivationLoss</a> (unsigned int idEventProc)</td></tr>
<tr class="separator:ab1ec7855aa3c9d3d400011adab6c8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab0f1e1a247f858577c1d9d04e4a4331c"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab0f1e1a247f858577c1d9d04e4a4331c">rtos_getNoTotalTaskFailure</a> (unsigned int PID)</td></tr>
<tr class="separator:ab0f1e1a247f858577c1d9d04e4a4331c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb25bad5cf1976808e7acb79c30290bd"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#abb25bad5cf1976808e7acb79c30290bd">rtos_getNoTaskFailure</a> (unsigned int PID, unsigned int kindOfErr)</td></tr>
<tr class="separator:abb25bad5cf1976808e7acb79c30290bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a240a9b010103563bb950b8d69017703b"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a240a9b010103563bb950b8d69017703b">rtos_getStackReserve</a> (unsigned int PID)</td></tr>
<tr class="separator:a240a9b010103563bb950b8d69017703b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeddb4b88dd8c1052eb41763e7164e7fa"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aeddb4b88dd8c1052eb41763e7164e7fa">rtos_osSuspendProcess</a> (uint32_t PID)</td></tr>
<tr class="separator:aeddb4b88dd8c1052eb41763e7164e7fa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a63296923146f8dff5b8754ca1c6003dc"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a63296923146f8dff5b8754ca1c6003dc">rtos_isProcessSuspended</a> (uint32_t PID)</td></tr>
<tr class="separator:a63296923146f8dff5b8754ca1c6003dc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a733dddf34c1ab3a828e5e2e98daa8b90"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a733dddf34c1ab3a828e5e2e98daa8b90">rtos_getIdxCore</a> (void)</td></tr>
<tr class="separator:a733dddf34c1ab3a828e5e2e98daa8b90"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa300833f2f5ca8b0ff0afa30916a0d1e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aa300833f2f5ca8b0ff0afa30916a0d1e">rtos_getCoreStatusRegister</a> (void)</td></tr>
<tr class="separator:aa300833f2f5ca8b0ff0afa30916a0d1e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6621923bed2b7ca031f158a305704048"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a6621923bed2b7ca031f158a305704048">rtos_osGetIdxCore</a> (void)</td></tr>
<tr class="separator:a6621923bed2b7ca031f158a305704048"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a545491943035300af3886c05538290de"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a545491943035300af3886c05538290de">rtos_osRunTask</a> (const <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a> *pUserTaskConfig, uint32_t taskParam)</td></tr>
<tr class="separator:a545491943035300af3886c05538290de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c1c26ac4a21ca0ce27df5484d87cdc2"><td class="memItemLeft" align="right" valign="top">static int32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask</a> (const <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a> *pUserTaskConfig, uint32_t taskParam)</td></tr>
<tr class="separator:a2c1c26ac4a21ca0ce27df5484d87cdc2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50aa791209542d3078b18c24acbb46c1"><td class="memItemLeft" align="right" valign="top">static _Noreturn void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a50aa791209542d3078b18c24acbb46c1">rtos_terminateTask</a> (int32_t taskReturnValue)</td></tr>
<tr class="separator:a50aa791209542d3078b18c24acbb46c1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab154b2923ad0d102fa1515e89d42c898"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts</a> (void)</td></tr>
<tr class="separator:ab154b2923ad0d102fa1515e89d42c898"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad580381efb7808b37da052d3a51a7901"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts</a> (void)</td></tr>
<tr class="separator:ad580381efb7808b37da052d3a51a7901"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3876d0769f82d504e4f88c825461e315"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a3876d0769f82d504e4f88c825461e315">rtos_osGetAllInterruptsSuspended</a> (void)</td></tr>
<tr class="separator:a3876d0769f82d504e4f88c825461e315"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4a9eb6b285b58c2e2f8f6f02e995bf59"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection</a> (void)</td></tr>
<tr class="separator:a4a9eb6b285b58c2e2f8f6f02e995bf59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae6935dc959dd97bcbe04070a477c2ac3"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#ae6935dc959dd97bcbe04070a477c2ac3">rtos_osLeaveCriticalSection</a> (uint32_t msr)</td></tr>
<tr class="separator:ae6935dc959dd97bcbe04070a477c2ac3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa32c2851008be051b3a644e081da3298"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent</a> (unsigned int idEventProc, uintptr_t taskParam)</td></tr>
<tr class="separator:aa32c2851008be051b3a644e081da3298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d385fa8723adabb76b583dad031438"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#af2d385fa8723adabb76b583dad031438">rtos_sendEventCountable</a> (unsigned int idEventProc, uint32_t evMask)</td></tr>
<tr class="separator:af2d385fa8723adabb76b583dad031438"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9bb888dce5e1f9a94d8c77ce3e3395ec"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a9bb888dce5e1f9a94d8c77ce3e3395ec">rtos_sendEventMultiple</a> (unsigned int idEventProc, uint32_t evMask, uint8_t count)</td></tr>
<tr class="separator:a9bb888dce5e1f9a94d8c77ce3e3395ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac7a5ed04ef56818262cd5288d327648"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#aac7a5ed04ef56818262cd5288d327648">rtos_checkUserCodeReadPtr</a> (const void *address, size_t noBytes)</td></tr>
<tr class="separator:aac7a5ed04ef56818262cd5288d327648"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a50d3acde6c733f5dcf8decab6299e3ff"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos_8h.html#a50d3acde6c733f5dcf8decab6299e3ff">rtos_suspendProcess</a> (uint32_t PID)</td></tr>
<tr class="separator:a50d3acde6c733f5dcf8decab6299e3ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >Public interface of safe-RTOS. The functions, which are published here as prototypes or which are implemented here as inline functions, are intended for use. Most typical, an operating system (sometimes called Basic Software) will be built on this interface.</p>
<p >safe-RTOS application interface:</p>
<p >System configuration and initialization:</p>
<p >rtos_osCreateEventProcessor rtos_osCreateEvent (deprecated alias of rtos_osCreateEventProcessor) rtos_osCreateSwTriggeredEventProcessor rtos_osRegisterInitTask rtos_osRegisterUserTask rtos_osRegisterOSTask rtos_osInitINTCInterruptController rtos_osRegisterInterruptHandler rtos_osGrantPermissionRunTask rtos_osGrantPermissionSuspendProcess rtos_osInitKernel</p>
<p >Control tasks and processes:</p>
<p >rtos_osSendEvent rtos_osTriggerEvent (deprecated alias of rtos_osSendEvent) rtos_sendEvent (inline) rtos_triggerEvent (deprecated alias of rtos_sendEvent) rtos_osSendEventCountable rtos_sendEventCountable (inline) rtos_osSendEventMultiple rtos_sendEventMultiple (inline) rtos_osRunTask (inline) rtos_runTask (inline) rtos_terminateTask (inline) rtos_osSuspendProcess rtos_suspendProcess (inline)</p>
<p >Critical sections:</p>
<p >rtos_osSuspendAllInterrupts (inline) rtos_osResumeAllInterrupts (inline) rtos_osEnterCriticalSection (inline) rtos_osLeaveCriticalSection (inline) rtos_osSuspendAllTasksByPriority rtos_osResumeAllTasksByPriority rtos_suspendAllTasksByPriority rtos_resumeAllTasksByPriority</p>
<p >System call interface:</p>
<p >rtos_systemCall rtos_osSystemCallBadArgument rtos_checkUserCodeReadPtr (inline) rtos_checkUserCodeWritePtr</p>
<p >Query system state:</p>
<p >rtos_osGetIdxCore (inline) rtos_getIdxCore rtos_getCoreStatusRegister rtos_osGetAllInterruptsSuspended (inline) rtos_isProcessSuspended</p>
<p >Diagnostic interface:</p>
<p >rtos_getNoActivationLoss rtos_getNoTotalTaskFailure rtos_getNoTaskFailure rtos_getStackReserve</p>
<p >Copyright (C) 2017-2024 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a18500a557ecd5ebbcefbacba22b58d7e" name="a18500a557ecd5ebbcefbacba22b58d7e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a18500a557ecd5ebbcefbacba22b58d7e">&#9670;&nbsp;</a></span>RTOS_NO_PROCESSES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_PROCESSES&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of configured processes. The definition is not core specific &ndash; processes are shared between cores.<br  />
 Although it looks like a matter of application dependent configuration, this is a fixed setting in our RTOS. We have the HW constraint of a limited number of memory region descriptors in MMU and MPU. Four processes can be comfortably supported with enough descriptors each. Having less regions per process is possible with reduced programming comfort and so we could have more processes even without changing the run-time code (i.e., implementation of dynamic change of regions). However, the aimed use cases of this RTOS, applications with higher safety integrity level, can be handled with two or three processes so that pre-configured four should always be fine.<br  />
 The big advantage of having a fixed number of processes is the avoidance of configuration changes. The MMU and MPU configuration would need changes on C code level and the linker script would need more or altered section filters.<br  />
 No using all pre-configured processes doesn't matter. Just use a process in a task specification or leave it. An unused process doesn't produce any overhead. </p>

</div>
</div>
<a id="ab004fb06d9894fe6afdc8385f33602cb" name="ab004fb06d9894fe6afdc8385f33602cb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab004fb06d9894fe6afdc8385f33602cb">&#9670;&nbsp;</a></span>RTOS_NO_CORES</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_CORES&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of cores in the MCU and the maximum number of cores that can run the RTOS. If an MCU derivative should have a deviating number of cores then a source code migration is required. This is not a variable configuration setting. </p>

</div>
</div>
<a id="a6e59eb94bd87ab947627170aa96ba093" name="a6e59eb94bd87ab947627170aa96ba093"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e59eb94bd87ab947627170aa96ba093">&#9670;&nbsp;</a></span>RTOS_INVALID_EVENT_PROC_ID</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_INVALID_EVENT_PROC_ID&#160;&#160;&#160;(<a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This event ID is returned if creation of a new event is impossible. The ID is unusable, no task can be created specifying this event ID. </p>

</div>
</div>
<a id="a1f387767ac5768e23a4a7aa1ef5084f7" name="a1f387767ac5768e23a4a7aa1ef5084f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1f387767ac5768e23a4a7aa1ef5084f7">&#9670;&nbsp;</a></span>RTOS_TI_DEADLINE_MAX_IN_US</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_TI_DEADLINE_MAX_IN_US&#160;&#160;&#160;26843545</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Deadline monitoring for tasks is supported up to a task maximum execution time of this number of Microseconds: (2^31-1)*1e6/f_c, f_c is 80e6 (clock rate of STM timers).<br  />
 The macro denotes a technical limitation. It is not a configurable item and must not be changed. </p>

</div>
</div>
<a id="a60b38f5e5b8a935733b453bfd6b18c2b" name="a60b38f5e5b8a935733b453bfd6b18c2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a60b38f5e5b8a935733b453bfd6b18c2b">&#9670;&nbsp;</a></span>RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE&#160;&#160;&#160;((<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>)+1u)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An RTOS event can normally be triggered by user tasks belonging to a process of sufficient privileges. See argument <em>minPIDToTriggerThisEvProc</em> of <a class="el" href="rtos_8h.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a>. If it should not be accessible even by the process of highest privileges than <a class="el" href="rtos_8h.html#a60b38f5e5b8a935733b453bfd6b18c2b">RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</a> can be specified for <em>minPIDToTriggerThisEvProc</em>. </p>

</div>
</div>
<a id="a3e599fcdd6c1ffc7c78aa83bf3d890c6" name="a3e599fcdd6c1ffc7c78aa83bf3d890c6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e599fcdd6c1ffc7c78aa83bf3d890c6">&#9670;&nbsp;</a></span>RTOS_NO_ERR_PRC</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_NO_ERR_PRC&#160;&#160;&#160;13</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The number of different kinds of process errors, which let to task abortion. </p>

</div>
</div>
<a id="a92e9d0974a02d2aeaa4a4728551f094e" name="a92e9d0974a02d2aeaa4a4728551f094e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92e9d0974a02d2aeaa4a4728551f094e">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_PROCESS_ABORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_PROCESS_ABORT&#160;&#160;&#160;0</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >The enumeration of different kinds of process errors, which lead to task abortion.<br  />
 Here: Process abort from user/scheduler. </p>

</div>
</div>
<a id="a5c3c87d0d5a675b6ebe299611b001193" name="a5c3c87d0d5a675b6ebe299611b001193"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5c3c87d0d5a675b6ebe299611b001193">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_MACHINE_CHECK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_MACHINE_CHECK&#160;&#160;&#160;1</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #1, Machine check, mostly memory protection. </p>

</div>
</div>
<a id="a34966960c63fafadc4a26f975463ecf5" name="a34966960c63fafadc4a26f975463ecf5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34966960c63fafadc4a26f975463ecf5">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_DEADLINE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_DEADLINE&#160;&#160;&#160;2</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Task exceeded deadline. </p>

</div>
</div>
<a id="a5167e186d61f53208b26de65a6ad48e2" name="a5167e186d61f53208b26de65a6ad48e2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5167e186d61f53208b26de65a6ad48e2">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_DI_STORAGE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_DI_STORAGE&#160;&#160;&#160;3</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #2 or #3, MMU storage error. </p>

</div>
</div>
<a id="a6e76056aa81bac40477ab9beecb6c9c4" name="a6e76056aa81bac40477ab9beecb6c9c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6e76056aa81bac40477ab9beecb6c9c4">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_SYS_CALL_BAD_ARG</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_SYS_CALL_BAD_ARG&#160;&#160;&#160;4</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Task referred to invalid system call or an existing system call has been made with invalid arguments. </p>

</div>
</div>
<a id="a3d24664c8ff5376976146cfa2950311f" name="a3d24664c8ff5376976146cfa2950311f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3d24664c8ff5376976146cfa2950311f">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_ALIGNMENT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_ALIGNMENT&#160;&#160;&#160;5</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #5, Alignment. </p>

</div>
</div>
<a id="a0172049df63fe882ed7bacdb1d395600" name="a0172049df63fe882ed7bacdb1d395600"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0172049df63fe882ed7bacdb1d395600">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_PROGRAM_INTERRUPT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_PROGRAM_INTERRUPT&#160;&#160;&#160;6</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #6, mostly illegal instruction. </p>

</div>
</div>
<a id="a9b1aca495ec0f1b9dec99119f75b89e7" name="a9b1aca495ec0f1b9dec99119f75b89e7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9b1aca495ec0f1b9dec99119f75b89e7">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_FPU_UNAVAIL</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_FPU_UNAVAIL&#160;&#160;&#160;7</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #7, Book E FPU instructions. </p>

</div>
</div>
<a id="af17067175c3c4f70b96f59a1b85192e8" name="af17067175c3c4f70b96f59a1b85192e8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17067175c3c4f70b96f59a1b85192e8">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_TBL_DATA</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_TBL_DATA&#160;&#160;&#160;8</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #13, TBL data access mismatch. </p>

</div>
</div>
<a id="ad85879d045e06a015caa8cd62a907500" name="ad85879d045e06a015caa8cd62a907500"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad85879d045e06a015caa8cd62a907500">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_TBL_INSTRUCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_TBL_INSTRUCTION&#160;&#160;&#160;9</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #14, TBL instr access mismatch. </p>

</div>
</div>
<a id="af17be265e573ec7a6908a84693422c0c" name="af17be265e573ec7a6908a84693422c0c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af17be265e573ec7a6908a84693422c0c">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_SPE_INSTRUCTION</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_SPE_INSTRUCTION&#160;&#160;&#160;10</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Exception IVOR #32, use of SPE instruction. </p>

</div>
</div>
<a id="a32453f0c8f6c8845c879a54e4288c2b4" name="a32453f0c8f6c8845c879a54e4288c2b4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32453f0c8f6c8845c879a54e4288c2b4">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_USER_ABORT</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_USER_ABORT&#160;&#160;&#160;11</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: User code returned error code. </p>

</div>
</div>
<a id="a82df28472250ffa82b5cf33dbb41c93f" name="a82df28472250ffa82b5cf33dbb41c93f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a82df28472250ffa82b5cf33dbb41c93f">&#9670;&nbsp;</a></span>RTOS_ERR_PRC_RESERVED</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_ERR_PRC_RESERVED&#160;&#160;&#160;12</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kind of process error: Not yet in use, reserved for extensions. </p>

</div>
</div>
<a id="a7eac206295711ad1e5346d367f9ce74c" name="a7eac206295711ad1e5346d367f9ce74c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eac206295711ad1e5346d367f9ce74c">&#9670;&nbsp;</a></span>RTOS_SC_TABLE_ENTRY</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_SC_TABLE_ENTRY</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">addrOfFct, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">confClass&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">            { .addressOfFct = (uint32_t)addrOfFct                       \</div>
<div class="line">            , .conformanceClass = RTOS_HDLR_CONF_CLASS_##confClass      \</div>
<div class="line">            }</div>
</div><!-- fragment --><p >Helper macro for I/O driver implementation. If the driver wants to declare a system call then it'll define RTOS_SYSCALL_TABLE_ENTRY_dddd to be <a class="el" href="rtos_8h.html#a7eac206295711ad1e5346d367f9ce74c">RTOS_SC_TABLE_ENTRY(addrOfFct, confClass)</a>, where <em>dddd</em> is the decimal representation of the system call index, <em>addrOfFct</em> is the address of the handler, which implements the system call, and <em>confClass</em> its conformance class. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">addrOfFct</td><td>Address of handler implementation </td></tr>
    <tr><td class="paramname">confClass</td><td>One out of BASIC (see <a class="el" href="rtos__system_call_8h.html#a8af1e781fbefe00906766498a29cf681">RTOS_HDLR_CONF_CLASS_BASIC</a>), SIMPLE (see <a class="el" href="rtos__system_call_8h.html#ad71ba99d7500f0d82ab40b64d3d1a7ab">RTOS_HDLR_CONF_CLASS_SIMPLE</a>) or FULL (see <a class="el" href="rtos__system_call_8h.html#a28067013553598a98217116e03aca91a">RTOS_HDLR_CONF_CLASS_FULL</a>) </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6f4937c654a76ca43d70366f0f461cd" name="af6f4937c654a76ca43d70366f0f461cd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6f4937c654a76ca43d70366f0f461cd">&#9670;&nbsp;</a></span>RTOS_TI_MS2TICKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_TI_MS2TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tiInMs</td><td>)</td>
          <td>&#160;&#160;&#160;((tiInMs)*80000u)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Helper for data initialization: Task time budgets are internally represented in STM counter ticks. Using this macro one can specify it more conveniently in Milliseconds. The macro just converts its argument from Milliseconds to clock ticks. </p>

</div>
</div>
<a id="a50879c034063dd071531d12bc8c3f6d6" name="a50879c034063dd071531d12bc8c3f6d6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50879c034063dd071531d12bc8c3f6d6">&#9670;&nbsp;</a></span>RTOS_TI_US2TICKS</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_TI_US2TICKS</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">tiInUs</td><td>)</td>
          <td>&#160;&#160;&#160;((tiInUs)*80u)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Helper for data initialization: Task time budgets are internally represented in STM(0) counter ticks. Using this macro one can specify it more conveniently in Microseconds. The macro just converts its argument from Microseconds to clock ticks. </p>

</div>
</div>
<a id="a83cb2901c9810c8c160a1b0d8cf7fa2b" name="a83cb2901c9810c8c160a1b0d8cf7fa2b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a83cb2901c9810c8c160a1b0d8cf7fa2b">&#9670;&nbsp;</a></span>RTOS_CORE_Z4A</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_CORE_Z4A&#160;&#160;&#160;0u</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Index of core Z4 A or value of read-only register PIR on this core and return value of function <a class="el" href="rtos_8h.html#a6621923bed2b7ca031f158a305704048">rtos_osGetIdxCore()</a> if called from this core. </p>

</div>
</div>
<a id="a7728701da34558de9c44cad1f8ff7bda" name="a7728701da34558de9c44cad1f8ff7bda"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7728701da34558de9c44cad1f8ff7bda">&#9670;&nbsp;</a></span>RTOS_CORE_Z4B</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_CORE_Z4B&#160;&#160;&#160;1u</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Index of core Z4 B or value of read-only register PIR on this core and return value of function <a class="el" href="rtos_8h.html#a6621923bed2b7ca031f158a305704048">rtos_osGetIdxCore()</a> if called from this core. </p>

</div>
</div>
<a id="a4bdfa60bad6565f0e56183f260550e60" name="a4bdfa60bad6565f0e56183f260550e60"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4bdfa60bad6565f0e56183f260550e60">&#9670;&nbsp;</a></span>RTOS_CORE_Z2</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define RTOS_CORE_Z2&#160;&#160;&#160;2u</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Index of core Z2 or value of read-only register PIR on this core and return value of function <a class="el" href="rtos_8h.html#a6621923bed2b7ca031f158a305704048">rtos_osGetIdxCore()</a> if called from this core. </p>

</div>
</div>
<h2 class="groupheader">Typedef Documentation</h2>
<a id="aa9ea5e791ee7404aad7ae37ef35cde7d" name="aa9ea5e791ee7404aad7ae37ef35cde7d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa9ea5e791ee7404aad7ae37ef35cde7d">&#9670;&nbsp;</a></span>rtos_interruptServiceRoutine_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* rtos_interruptServiceRoutine_t) (void)</td>
        </tr>
      </table>
</div><div class="memdoc">
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000001">Todo:</a></b></dt><dd>Consider switching the next code block off to find deprecated code locations, which require migration. </dd></dl>
<p>Type of a single interrupt service as registered with function <a class="el" href="rtos_8h.html#accff5b6fe96e98a366aeab1442a3efe9">rtos_osRegisterInterruptHandler()</a>. </p>

</div>
</div>
<a id="acb6b370f441999d9f539d81ac6118f9e" name="acb6b370f441999d9f539d81ac6118f9e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acb6b370f441999d9f539d81ac6118f9e">&#9670;&nbsp;</a></span>rtos_errorCode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef enum <a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> <a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This enumeration collects the errors, which are recognized during system configuration and initialization. </p>

</div>
</div>
<a id="a140a5125319655d63a8a353a6c29ba90" name="a140a5125319655d63a8a353a6c29ba90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a140a5125319655d63a8a353a6c29ba90">&#9670;&nbsp;</a></span>rtos_taskDesc_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a> <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Specification of a task function. Objects of this type are used internally by the scheduler for the regularly or event triggered user mode and OS tasks but also visibly by the client code, when running a user mode task using <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a>. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="ae6a79bdc418d571b34528a8d2c9f49d1" name="ae6a79bdc418d571b34528a8d2c9f49d1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6a79bdc418d571b34528a8d2c9f49d1">&#9670;&nbsp;</a></span>rtos_errorCode_t</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This enumeration collects the errors, which are recognized during system configuration and initialization. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a19304aaba258a01530cb891f69fa78dc" name="ae6a79bdc418d571b34528a8d2c9f49d1a19304aaba258a01530cb891f69fa78dc"></a>rtos_err_tooManyEventsCreated&#160;</td><td class="fielddoc"><p >Can't create no more than <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a> events. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a88b39e365c36b7864305b1020d167917" name="ae6a79bdc418d571b34528a8d2c9f49d1a88b39e365c36b7864305b1020d167917"></a>rtos_err_invalidEventPrio&#160;</td><td class="fielddoc"><p >Priority needs to be in range [1; <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a>) </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a7997aabfed01a9d3dc744a0971b21292" name="ae6a79bdc418d571b34528a8d2c9f49d1a7997aabfed01a9d3dc744a0971b21292"></a>rtos_err_badEventTiming&#160;</td><td class="fielddoc"><p >Inconsistent or bad timing configuration stated for event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a19dd8bb137f08cb4484ba25522bfeaf4" name="ae6a79bdc418d571b34528a8d2c9f49d1a19dd8bb137f08cb4484ba25522bfeaf4"></a>rtos_err_eventNotTriggerable&#160;</td><td class="fielddoc"><p >Bad configuration makes event unusable. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a9d20065342c519702d9db027a9487ce6" name="ae6a79bdc418d571b34528a8d2c9f49d1a9d20065342c519702d9db027a9487ce6"></a>rtos_err_configurationOfRunningKernel&#160;</td><td class="fielddoc"><p >Attempt to (re-)configure a running kernel. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1aa229366559e09226d96b6c8e418d6c31" name="ae6a79bdc418d571b34528a8d2c9f49d1aa229366559e09226d96b6c8e418d6c31"></a>rtos_err_badEventProcId&#160;</td><td class="fielddoc"><p >The ID of the event is invalid. No such event exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1aedf7c2df4f697093e634b0b7060743ea" name="ae6a79bdc418d571b34528a8d2c9f49d1aedf7c2df4f697093e634b0b7060743ea"></a>rtos_err_badCountableTimerEventMask&#160;</td><td class="fielddoc"><p >Invalid mask specified for a countable timer event. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a218ea0e64c7b0278fa114aa3aac80d60" name="ae6a79bdc418d571b34528a8d2c9f49d1a218ea0e64c7b0278fa114aa3aac80d60"></a>rtos_err_badProcessId&#160;</td><td class="fielddoc"><p >The ID of the process is invalid. No such process exists. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a385adfe034f15b8a93c11278c1d01aba" name="ae6a79bdc418d571b34528a8d2c9f49d1a385adfe034f15b8a93c11278c1d01aba"></a>rtos_err_tooManyTasksRegistered&#160;</td><td class="fielddoc"><p >More than <a class="el" href="rtos_8config_8h.html#a132fbde1ccf910d5a3ba069232db0709">RTOS_MAX_NO_TASKS</a> registered. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a0a3176c426b81c3eed1a4b7cbd5ef371" name="ae6a79bdc418d571b34528a8d2c9f49d1a0a3176c426b81c3eed1a4b7cbd5ef371"></a>rtos_err_noEvOrTaskRegistered&#160;</td><td class="fielddoc"><p >No event and/or no task defined at start of system. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a5c68548c849e3bab1e3b1a0eaba95b4e" name="ae6a79bdc418d571b34528a8d2c9f49d1a5c68548c849e3bab1e3b1a0eaba95b4e"></a>rtos_err_evProcWithoutTask&#160;</td><td class="fielddoc"><p >A useless event exists, which has no task to activate. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a6227d0116801a4e94ab0b613b747407f" name="ae6a79bdc418d571b34528a8d2c9f49d1a6227d0116801a4e94ab0b613b747407f"></a>rtos_err_badTaskFunction&#160;</td><td class="fielddoc"><p >Bad task function NULL specified. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a4658c821f83b720ed7d7b4713a178e0d" name="ae6a79bdc418d571b34528a8d2c9f49d1a4658c821f83b720ed7d7b4713a178e0d"></a>rtos_err_taskBudgetTooBig&#160;</td><td class="fielddoc"><p >Task budget greater than <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a>. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1ad285146c97ddb0e2318b0e58c0f4644b" name="ae6a79bdc418d571b34528a8d2c9f49d1ad285146c97ddb0e2318b0e58c0f4644b"></a>rtos_err_initTaskRedefined&#160;</td><td class="fielddoc"><p >Attempt to redefine an already defined initialization task. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1ab430b681a53eb533e44a6260874452fb" name="ae6a79bdc418d571b34528a8d2c9f49d1ab430b681a53eb533e44a6260874452fb"></a>rtos_err_initTaskFailed&#160;</td><td class="fielddoc"><p >Process initialization function failed or returned neg. value. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a5535320638a30f3fcdfc642712eb5c6f" name="ae6a79bdc418d571b34528a8d2c9f49d1a5535320638a30f3fcdfc642712eb5c6f"></a>rtos_err_prcStackInvalid&#160;</td><td class="fielddoc"><p >Configured stack misaligned or too small. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a30eeebbb9e9807fcd75e7359cf358953" name="ae6a79bdc418d571b34528a8d2c9f49d1a30eeebbb9e9807fcd75e7359cf358953"></a>rtos_err_taskBelongsToInvalidPrc&#160;</td><td class="fielddoc"><p >Task assigned to not configured process. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1abae1c422a879faa29d9034e7a4db112c" name="ae6a79bdc418d571b34528a8d2c9f49d1abae1c422a879faa29d9034e7a4db112c"></a>rtos_err_highPrioTaskInLowPrivPrc&#160;</td><td class="fielddoc"><p >Task of highest prio belongs to process of low privileges. </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a5125283431d030b220aefa5244ebb89b" name="ae6a79bdc418d571b34528a8d2c9f49d1a5125283431d030b220aefa5244ebb89b"></a>rtos_err_runTaskBadPermission&#160;</td><td class="fielddoc"><p >"Unsafe" permissions granted to <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a> </p>
</td></tr>
<tr><td class="fieldname"><a id="ae6a79bdc418d571b34528a8d2c9f49d1a998a63eb85afdba5f8dbdfd1bdd15d0e" name="ae6a79bdc418d571b34528a8d2c9f49d1a998a63eb85afdba5f8dbdfd1bdd15d0e"></a>rtos_err_suspendPrcBadPermission&#160;</td><td class="fielddoc"><p >"Unsafe" permissions granted to <a class="el" href="rtos_8h.html#a50d3acde6c733f5dcf8decab6299e3ff">rtos_suspendProcess()</a> </p>
</td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="aae28a732a3918bcd90346b192bf46293" name="aae28a732a3918bcd90346b192bf46293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae28a732a3918bcd90346b192bf46293">&#9670;&nbsp;</a></span>rtos_osCreateEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiCycleInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiFirstActivationInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timerUsesCountableEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timerTaskTriggerParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creation of an event processor. The event processor can use cyclic time triggering or be triggerd by software.</p>
<p >Creation of an event processor. The event processor can produce a periodic timer event or it can be software triggered. An event processor is needed to activate a user task. Therefore, any reasonable application will create at least one event processor.<br  />
 This function is repeatedly called by the application code for each required event processor. All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>.<br  />
 </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>All event processors are identified by a positive integer. Normally this ID is returned by reference in * <em>pEvProcId</em>. If the event processor cannot be created then <a class="el" href="rtos_8h.html#a6e59eb94bd87ab947627170aa96ba093">RTOS_INVALID_EVENT_PROC_ID</a> is returned in * <em>pEvProcId</em>.<br  />
 Note, it is guaranteed to the caller that the returned ID is not an arbitrary, meaningless number. Instead, the ID is counted from zero in order of creating event processors. The first call of this function will return 0, the second 1, and so on. This simplifies ID handling in the application code, constants can mostly be applied as the IDs are effectively known at compile time. </td></tr>
    <tr><td class="paramname">tiCycleInMs</td><td>The period time for regularly triggering events in ms.<br  />
 The permitted range is 0..2^30-1. 0 means no regular, timer controlled trigger and the event processor is enabled only for software trigger using <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> (permitted for interrupts or other tasks). </td></tr>
    <tr><td class="paramname">tiFirstActivationInMs</td><td>The first trigger by timer event in ms after start of kernel. The permitted range is 0..2^30-1.<br  />
 Note, this setting is useless if a cycle time zero in <em>tiCycleInMs</em> specifies a non regular event. <em>tiFirstActivationInMs</em> needs to be zero in this case, too. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor in the range 1..UINT_MAX. Different event processors can share the same priority. The priority of an event processor is the priority of all associated tasks at the same time. The execution of tasks, which share the priority will be serialized when they are activated at same time or with overlap.<br  />
 Note the safety constraint that task priorities above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> are available only to event processors, which solely have associated tasks that belong to the process with highest process ID in use. (Which is assumed to be the safety process.)<br  />
 Note, the order in which event processors are created can affect the priority in a certain sense. If two event processors are created with same priority and when they at runtime become due at the same OS time tick then the earlier created processor will activate its associated tasks before the later created. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Events can be notified by user code, e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>. However, tasks belonging to less privileged processes must not generally have permission to trigger event processors that may activate tasks of higher privileged processes. Since an event processor is not process related, we make the minimum process ID, which is required to notify the event to the processor, an explicitly configured property of the processor.<br  />
 Only tasks belonging to a process with PID &gt;= <em>minPIDToTriggerThisEvProc</em> are permitted to trigger this event processor.<br  />
 The range of <em>minPIDToTriggerThisEvProc</em> is 0 ... (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1). 0 and 1 both mean, all processes may trigger the event processor, (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) means only OS code can trigger it. (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) is available as <a class="el" href="rtos_8h.html#a60b38f5e5b8a935733b453bfd6b18c2b">RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</a>, too. </td></tr>
    <tr><td class="paramname">timerUsesCountableEvents</td><td>When the OS timer triggers a due event processor then it needs to decide whether to use it as countable or ordinary event. This decision is configured per event but once for ever.<br  />
 <em>timerUsesCountableEvents</em> doesn't care for solely SW notified events, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
    <tr><td class="paramname">timerTaskTriggerParam</td><td>For timer triggered event processors, this is the argument of the trigger operation. For countable events, this is the mask specifying the variable storing the multiplicity of the notified event. Timer triggers always use multiplicity 1 per trigger, i.e., per due time. The number of bits set determine, how many triggers can be stored until a task overflow is reported. For example, with <em>timerTaskTriggerParam=3</em>, a task overflow would be recorded only, when the event has been found non-idle at four consecutive due times. For countable events, <em>timerTaskTriggerParam</em> must not be zero.<br  />
 If <em>timerUsesCountableEvents=false</em> then <em>timerTaskTriggerParam</em> will be used as task parameter that is delivered to all associated task functions on every successful trigger. <em>timerTaskTriggerParam</em> doesn't care for solely SW triggered event processors, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Effectively, this object can be considered the descriptor of the idle task. </dd></dl>

</div>
</div>
<a id="a3b10ac33293a44882ccbc069f1c9af2a" name="a3b10ac33293a44882ccbc069f1c9af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b10ac33293a44882ccbc069f1c9af2a">&#9670;&nbsp;</a></span>rtos_osCreateSwTriggeredEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateSwTriggeredEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creation of an event processor, which is intended for software notified events only.</p>
<p >A simplified call of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> to create an event processor, which won't be triggered by timer events. (The function internally calls <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> with <em>tiCycleInMs=0</em>.) Most of the function arguments of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> are meaningless for event processors triggered by software only, which makes the use of this API more appropriate. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>The event processor ID is returned by reference. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Privileges management for this event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="addefdb75681eaad3fd2699f2dabf85ba" name="addefdb75681eaad3fd2699f2dabf85ba"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addefdb75681eaad3fd2699f2dabf85ba">&#9670;&nbsp;</a></span>rtos_osRegisterInitTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterInitTask </td>
          <td>(</td>
          <td class="paramtype">int32_t(*)(uint32_t PID)&#160;</td>
          <td class="paramname"><em>initTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for user mode or operating system initialization task.</p>
<p >Registration of a process initialization task. This function is typically repeatedly called by the operating system initialization code as often as there are processes, which need initialization.<br  />
 Initialization functions are particularly useful for the user processes. They allow having user provided code, that is run prior to the start of the scheduler, in a still race condition free environment but already with full protection against runtime failures.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of initialization tasks is one per process and one for the OS. If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initTaskFct</td><td>The initialization function, which is run once in process <em>PID</em>.<br  />
 The function gets the ID of the process it belongs to as argument.<br  />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process and the scheduler will not start up. </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>) plus the kernel process, which has ID 0. The range of process IDs to be used here is 0 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br  />
 At kernel initialization time, the registered user process initialization functions will be called in the order of rising PID, followed by the registered kernel process initialization function. </td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the function execution in Microseconds. The budget relates to deadline monitoring, i.e., it is a world time budget, not an execution time budget.<br  />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br  />
 A value of zero means that deadline monitoring is disabled for the run of the initialization function.<br  />
 There's no deadline monitoring for OS tasks. If <em>PID</em> is zero then <em>tiTaskMaxInUS</em> meeds to be zero, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="a0c0aa893b9fa5476eb375842517340c9" name="a0c0aa893b9fa5476eb375842517340c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c0aa893b9fa5476eb375842517340c9">&#9670;&nbsp;</a></span>rtos_osRegisterUserTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterUserTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(uint32_t PID, uint32_t taskParam)&#160;</td>
          <td class="paramname"><em>userModeTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for scheduled user mode tasks.</p>
<p >Registration of an event triggered user mode task. Normal, event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as user mode tasks are required.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8config_8h.html#a132fbde1ccf910d5a3ba069232db0709">RTOS_MAX_NO_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The task is activated by an event. This call associates the registered task with an already created event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a>.<br  />
 The order of registration of several tasks (both, OS and user mode) with one and the same event processor matters. The tasks will be acivated in order of registration whenever the event processor becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">userModeTaskFct</td><td>The task function, which is run in process <em>PID</em> every time the event processor <em>idEventProc</em> becomes due of is triggered by software.<br  />
 The function gets the ID of the process it belongs to as argument.<br  />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process. (And after a number of errors a supervisory task could force a shutdown of the process). </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>). The range of process IDs to be used here is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br  />
</td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the task in Microseconds. This budget is granted for each activation of the task, i.e., each run of <em>userModeTaskFct()</em>. The budget relates to deadline monitoring, i.e., it is a world time budget, not an execution time budget.<br  />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br  />
 A value of zero means that deadline monitoring is disabled for the task.<br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="a2cd8691016ac24135e19b2477008750e" name="a2cd8691016ac24135e19b2477008750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd8691016ac24135e19b2477008750e">&#9670;&nbsp;</a></span>rtos_osRegisterOSTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterOSTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint32_t taskParam)&#160;</td>
          <td class="paramname"><em>osTaskFct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Task registration for scheduled operating system tasks.</p>
<p >Registration of an event triggered operating system task. Event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as operating system tasks are required.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8config_8h.html#a132fbde1ccf910d5a3ba069232db0709">RTOS_MAX_NO_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The task is activated by an event. This call associates the registered task with an already created event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a>.<br  />
 The order of registration of several tasks (both, OS and user mode) with one and the same event processor matters. The tasks will be acivated in order of registration whenever the event processor becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">osTaskFct</td><td>The task function, which is run in the OS context every time the event processor <em>idEventProc</em> becomes due or is triggered by software. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="a88a271864adecb3d629668674fa0815a" name="a88a271864adecb3d629668674fa0815a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a271864adecb3d629668674fa0815a">&#9670;&nbsp;</a></span>rtos_osInitINTCInterruptController()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osInitINTCInterruptController </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialize the interrupt controller INTC.</p>
<p >Initialize the interrupt controller INTC. The interrupt table with all interrupt service descriptors is initialized to contain a dummy ISR for all interrupts and it is then registered at the hardware device INTC for use.<br  />
 The interrupt default handler is rtos_dummyINTCInterruptHandler(). It does nothing in PRODUCTION compilation but an assertion will fire in DEBUG compilation in order to indicate the missing true handler for an enabled interrupt. The dummy interrupt handlers are registered for handling by core 0.<br  />
 Note, this function temporarily clears the enable External Interrupts bit in the machine status register but won't have changed it on return. Usually, you will call it at system startup time, when all interrupts are still disabled, then call <a class="el" href="rtos__external_interrupt_8c.html#a10a6460ff9e902f2d0ac42394e0e4fea">rtos_osRegisterInterruptHandler()</a> repeatedly for all interrupts your code is interested in, then start the other cores and eventually enable the interrupt processing at the CPUs. </p><dl class="section remark"><dt>Remarks</dt><dd>This function must be called from supervisor mode only. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000008">Todo:</a></b></dt><dd>This can become a sub-routine, which can then be applied in registerService to check user input </dd></dl>

</div>
</div>
<a id="accff5b6fe96e98a366aeab1442a3efe9" name="accff5b6fe96e98a366aeab1442a3efe9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#accff5b6fe96e98a366aeab1442a3efe9">&#9670;&nbsp;</a></span>rtos_osRegisterInterruptHandler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osRegisterInterruptHandler </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="rtos_8h.html#aa9ea5e791ee7404aad7ae37ef35cde7d">rtos_interruptServiceRoutine_t</a>&#160;</td>
          <td class="paramname"><em>pInterruptHandler</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>processorID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>vectorNum</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>psrPriority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>isPreemptable</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Install an interrupt service for a given I/O device.</p>
<p >This function can be used to install an interrupt service for a given I/O device and a given core. It will also set the Priority Select Register for the I/O device's IRQ to the desired value. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pInterruptHandler</td><td>The interrupt service routine by reference. An ordinary C function in the user code area, which is called when the according interrupt is served. </td></tr>
    <tr><td class="paramname">processorID</td><td>The interrupt is assigned to the processor of this ID. Allowed are: 0 for Z4A, 1 for Z4B or 2 for Z2.<br  />
 Note, the implementation avoids having different vector tables for the three cores. The work assumption is that an I/O interrupt will normally be served by either one or another core. The INTC HW permits signalling any interrupt to any set of cores. Both statements are combined in that setting an interrupt vector to a core A will cause an assertion if the same interrupt had been registered already before for another core B and the registration for A had specified another interrupt service routine.<br  />
 In the rare case of needing one interrupt on different cores the ISR needs to query the processor ID so that the implementation of the handler can become processor dependent. </td></tr>
    <tr><td class="paramname">vectorNum</td><td>All possible external interrupt sources are hardwired to the interrupt controller. They are indentified by index. The table, which interrupt source (mostly I/O device) is connected to the controller at which index can be found in the MCU reference manual, section 23.1.2, table 23-1, p. 523ff. </td></tr>
    <tr><td class="paramname">psrPriority</td><td>The priority at which the interrupt is served. Range is 0..15, checked by assertion. 0 is useless, it would never be served, 1 is the lowest real priority and 15 the highest. Preemption of a handler (if enabled), which serves an interrupt of priority n will be possible only by another interrupt of priority n+1 or higher. </td></tr>
    <tr><td class="paramname">isPreemptable</td><td>For each interrupt it can be said, whether it is preemptable by other interrupts of higher priority or not. If this is <em>false</em> then the interrupt handler will always be entered with the status bit EE reset in the machine status register MSR of the servicing core.<br  />
 Note, a handler, which has been declared non-premptable is allowed to set the EE bit itself. It can thus first do some operations without any race-conditions with other interrupts and then continue without further locking normal interrupt processing. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function can be used at any time. It is possible to exchange a handler at run-time, while interrrupts are being processed, but only on the processor, which invokes this function. However, the normal use case will rather be to call this function for all required interrupts and only then call the other function inc_resumeAllInterrupts() on all the processors.<br  />
 This function must not be called for an interrupt vector number n from within an ISR of that interrupt vector number and it must not be called from processor i for processor j!=i, if that processor is running. </dd>
<dd>
On an MPC5748G, all cores share the function code. A core should use this function to install its ISRs, regardless whether or not it runs the RTOS. A typical scenario would be running the RTOS only on one core, but the others should still use this function to install their ISRs. </dd>
<dd>
This function must be called from supervisor mode only. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000009">Todo:</a></b></dt><dd>Check: Why do we have a macro IRQ_Handler with argument isPreemtable but we still need an if? <br  />
 </dd></dl>

</div>
</div>
<a id="aeaae84408e099b28495d703994100c16" name="aeaae84408e099b28495d703994100c16"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeaae84408e099b28495d703994100c16">&#9670;&nbsp;</a></span>rtos_osGrantPermissionRunTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osGrantPermissionRunTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pidOfCallingTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>targetPID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Grant permission to particular processes for using the service <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a>.</p>
<p >Operating system initialization function: Grant permissions for using the service rtos_runTask to particular processes. By default, the use of that service is not allowed.<br  />
 By principle, offering service rtos_runTask makes all processes vulnerable, which are allowed as target for the service. A failing, straying process can always hit some ROM code executing the system call with arbitrary register contents, which can then lead to errors in an otherwise correct process.<br  />
 This does not generally break the safety concept, the potentially harmed process can for example be anyway supervised by another, unaccessible supervisory process. Consequently, we can offer the service at least on demand. A call of this function enables the service for a particular pair of calling process and targeted process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pidOfCallingTask</td><td>The tasks belonging to process with PID <em>pidOfCallingTask</em> are granted permission to run a task in another process. The range is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>, which is double-checked by assertion. </td></tr>
    <tr><td class="paramname">targetPID</td><td>The tasks started with service <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a> may be run in process with PID <em>targetPID</em>. The range is 1 .. maxPIDInUse-1, which is double-checked later at kernel initialization time.<br  />
 <em>pidOfCallingTask</em> and <em>targetPID</em> must not be identical, which is double-checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It would break the safety concept if we permitted the process with highest privileges to become the target of the service. This is double-checked not here (when it is not yet defined, which particular process that will be) but as part of the RTOS startup procedure; a bad configuration can therefore lead to a later reported run-time error. </dd>
<dd>
This function must be called from the OS context only. It is intended for use in the operating system initialization phase. It is not reentrant. The function needs to be called prior to <a class="el" href="rtos_8h.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </dd></dl>

</div>
</div>
<a id="a68f8200c57d5390e8937fc2a78af55b6" name="a68f8200c57d5390e8937fc2a78af55b6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a68f8200c57d5390e8937fc2a78af55b6">&#9670;&nbsp;</a></span>rtos_osGrantPermissionSuspendProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osGrantPermissionSuspendProcess </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>pidOfCallingTask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>targetPID</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Operating system initialization function: Grant permissions for using the service <a class="el" href="rtos_8h.html#a50d3acde6c733f5dcf8decab6299e3ff">rtos_suspendProcess()</a> to particular processes. By default, the use of that service is not allowed.<br  />
 By principle, offering service <a class="el" href="rtos_8h.html#a50d3acde6c733f5dcf8decab6299e3ff">rtos_suspendProcess()</a> makes all processes vulnerable, which are allowed as target for the service. A failing, straying process can always hit some ROM code executing the system call with arbitrary register contents, which can then lead to immediate task abortion in and suspension of an otherwise correct process.<br  />
 This does not generally break the safety concept, the potentially harmed process can for example be anyway supervised by another, non-suspendable supervisory process. Consequently, we can offer the service at least on demand. A call of this function enables the service for a particular pair of calling process and targeted process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pidOfCallingTask</td><td>The tasks belonging to process with PID <em>pidOfCallingTask</em> are granted permission to suspend another process. The range is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>, which is double-checked by assertion. </td></tr>
    <tr><td class="paramname">targetPID</td><td>The process with PID <em>targetPID</em> is suspended. The range is 1 .. maxPIDInUse-1, which is double-checked later. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It would break the safety concept if we permitted the process with highest privileges to become the target of the service. This is double-checked not here (when it is not yet defined, which particular process that will be) but as part of the RTOS startup procedure; a bad configuration can therefore lead to a later reported run-time error. </dd>
<dd>
This function must be called from the OS context only. It is intended for use in the operating system initialization phase. It is not reentrant. The function needs to be called prior to <a class="el" href="rtos_8h.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>.</dd></dl>
<p>Operating system initialization function: Grant permissions for using the service rtos_suspendProcess to particular processes. By default, the use of that service is not allowed.<br  />
 By principle, offering service rtos_suspendProcess makes all processes vulnerable, which are allowed as target for the service. A failing, straying process can always hit some ROM code executing the system call with arbitrary register contents, which can then lead to immediate task abortion in and suspension of an otherwise correct process.<br  />
 This does not generally break the safety concept, the potentially harmed process can for example be anyway supervised by another, non-suspendable supervisory process. Consequently, we can offer the service at least on demand. A call of this function enables the service for a particular pair of calling process and targeted process. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pidOfCallingTask</td><td>The tasks belonging to process with PID <em>pidOfCallingTask</em> are granted permission to suspend another process. The range is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>, which is double-checked by assertion. </td></tr>
    <tr><td class="paramname">targetPID</td><td>The process with PID <em>targetPID</em> is suspended. The range is 1 .. maxPIDInUse-1, which is double-checked later. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It would break the safety concept if we permitted the process with highest privileges to become the target of the service. This is double-checked not here (when it is not yet defined, which particular process that will be) but as part of the RTOS startup procedure; a bad configuration can therefore lead to a later reported run-time error. </dd>
<dd>
This function must be called from the OS context only. It is intended for use in the operating system initialization phase. It is not reentrant. The function needs to be called prior to <a class="el" href="rtos_8h.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </dd></dl>

</div>
</div>
<a id="ab24d0fa9208d5675e03cc931a08e52fd" name="ab24d0fa9208d5675e03cc931a08e52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24d0fa9208d5675e03cc931a08e52fd">&#9670;&nbsp;</a></span>rtos_osInitKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osInitKernel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kernel initialization.</p>
<p >Initialization and start of the RTOS kernel.<br  />
 The function initializes a hardware device to produce a regular clock tick and connects the OS schedule function onOsTimerTick() with the interrupt raised by this timer device. After return, the RTOS is running with a regular clock tick for scheduling the tasks. Period time is <a class="el" href="rtos_8config_8h.html#a7bf97b46b6e438370c03ef73f06df753">RTOS_CLOCK_TICK_IN_MS_CORE_0</a> (_1, _2) Milliseconds.<br  />
 The function can be called before or after the External Interrupts are enabled at the CPU (see <a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a>). Normal behavior is however, no to resume the interrupt processing before and let this be done by <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the scheduler could be started. The function returns a non zero value from enumeration <em>rtos_errorCode_t</em> if a configuration error is detected. The software must not start up in this case. Since it is only about static configuration, the returned error may be appropriately handled by an assertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The RTOS kernel applies the Periodic Interrupt Timer 0 (PIT0) as clock source. This timer is reserved to the RTOS and must not be used at all by some other code. </dd>
<dd>
All application tasks need to be registered before invoking this function, see <a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask()</a>, <a class="el" href="rtos__scheduler_8c.html#af7038ee6faaa29605b9129d4f0c9d840">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask()</a>. </dd>
<dd>
This function must be called from the OS context only. The call of this function will end the operating system initialization phase. </dd></dl>

</div>
</div>
<a id="acdb904958a596625132235635ab2a191" name="acdb904958a596625132235635ab2a191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb904958a596625132235635ab2a191">&#9670;&nbsp;</a></span>rtos_osSendEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>taskParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Software triggered task activation. Can be called from OS context (incl. interrupts).</p>
<p >Notify an event to an event processor to let it activate all associated tasks.<br  />
 This function can be called from any OS task or ISR. However, if the calling task belongs to the set of tasks associated with <em>idEventProc</em>, then it'll have no effect but a recorded activation loss; using this API, an event can be re-triggered only after all associated tasks have been completed. There is no activation queueing. The function returns <em>false</em> in this case.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the triggered event processor then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>There is no activation queuing. Consequently, notifying the event can fail if at least one of the associated tasks has not yet completed after the previous trigger of the event. The function returns <em>false</em> and the activation loss counter of the event processor is incremented. (See <a class="el" href="rtos__scheduler_8c.html#ab1ec7855aa3c9d3d400011adab6c8893">rtos_getNoActivationLoss()</a>.) In this situation, the new trigger is entirely lost, i.e., none of the associated tasks will be activated by the event and <em>the</em> value of taskParam won't be seen by the task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">taskParam</td><td>All associated tasks will receive this value, when they are called because of this trigger.<br  />
 The value is ignored if the function returns <em>false</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodic task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that an event activation loss is not unlikely in this case; the cyclic task may currently be busy. For this purpose, the use of countable events is probably the better choice. See <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. </dd>
<dd>
Events notified with this API are called "ordinary". In most situations, the use of countable events will perform better, see <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. An important exception from this are timer events for ordinary periodic tasks. </dd>
<dd>
It may look like an inconsistent API design if all associated tasks receive the same value <em>taskParam</em>. The service could easily offer an API, which provides an individual value to each associated task. The only reason not to do so is the additional overhead in combination with the very few imaginable use cases. In most cases an explicitly triggered event will have just one associated task; events with more than one task will mostly be regular timer tasks, which make rarely use of the task parameter. </dd>
<dd>
It is not forbidden but useless to let a task activate itself by triggering the event processor it is associated with with this API. This will have no effect besides incrementing the activation loss counter for that event processor. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="a2ac3edcc197ad85b1f309ad2efe03586" name="a2ac3edcc197ad85b1f309ad2efe03586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3edcc197ad85b1f309ad2efe03586">&#9670;&nbsp;</a></span>rtos_osSendEventCountable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEventCountable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Software triggered task activation with countable event. Can be called from OS context (incl. interrupts).</p>
<p >Notify a countable event to activate all associated tasks. Event processors can be used with countable or ordinary events. Please note, the event processor as such is neither countable nor ordinary, but it can be triggered in either way. (For ordinary, see <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a>.)<br  />
 For countable events, the multiplicity of notification is recorded and forwarded to the associated task functions by means of their task parameter. Effectively, this is a kind of activation queing, even if it doesn't mean that an associated task is guaranteed to become activated as often as this function is called.<br  />
 Up to a certain maximum, the number of invocations of this function is counted and stored. The stored number is handed over as task parameter to all associated tasks, when they are activated the next time. If the event processor is idle, when this function is called, then the count is one and this is what the task functions will get. If it is not idle then it depends. If the next call(s) of this function happen before the event processor becomes idle again then the stored multiplicity is 2, 3, 4, ... As soon as the event processor becomes idle, its tasks are activated and their task parameter will carry the 2, 3, 4, ..., respectively. In this example, if the event processor becomes idle after 4 calls, then the tasks will be activated not 4 times but just once with a reported multiplicity of 4 triggers. No activation loss is recorded for the event processor, as long as the counter for storing the multiplicity of the triggers doesn't overflow.<br  />
 Using this API for triggering an event, the associated tasks will strictly know, how many notifications of the event occurred - even if the number of task activations may be lesser.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the notified event then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>Notifying the countable event fails if the counter for the multiplicity of the event overflows. The implementation limit of this counter is determined by the mask <em>evMask</em>. If n bits are set in <em>evMask</em> then the function may be called up to 2^n-1 times while the event processor is not idle. The 2^n-th call will be first one returning <em>false</em> and only now, an activation loss will be recorded for the event processor.<br  />
 As long as the caller gets <em>true</em>, he can be sure that the multiplicity of all notifications so far will be properly delivered to the associated task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See above for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodic task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that a non-idle event processor is not unlikely in this case; <em>evMask</em> should spent a sufficient number of bits to temporarily store the multiplicity of notifications-while-non-idle. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="aae428115e507b116469a1859cf20b4c5" name="aae428115e507b116469a1859cf20b4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae428115e507b116469a1859cf20b4c5">&#9670;&nbsp;</a></span>rtos_osSendEventMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEventMultiple </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Software triggered task activation with more than one occurance of a countable event. Can be called from OS context (incl. interrupts).</p>
<p >A countable event can be notified with multiplicity greater than one. If the event processor is idle then the associated tasks are activated and they will receive the multiplicity <em>count</em> in their task parameter. If the event processor is not idle then the accumulator for the event will be incremented either by <em>count</em> or up to its implementation maximum, whatever comes first. The resulting, accumulated count will be forwarded to the task functions as soon as the processor becomes idle again. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> if the accumulator for the event overflows (and saturates at its maximum). Get <em>true</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a> for details. </td></tr>
    <tr><td class="paramname">count</td><td>The notified multiplicity of the event.<br  />
 The complexity of the operation is O(count), which means that it is intended for rather small multiplicities. To avoid undesired blocking of the function due to excessive high multiplicities, the implementation type for the argument has been chosen 8 Bit, which strictly limits the range of <em>count</em> to 1..255.<br  />
 <em>count</em> = 0 is not allowed and caught by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behavior of this function is similar to calling <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a> for <em>count</em> times. The result of <a class="el" href="rtos__scheduler_8c.html#aae428115e507b116469a1859cf20b4c5">rtos_osSendEventMultiple()</a> would then be the result of the very last call of <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="a90505523c85decbc51c6835d425f861e" name="a90505523c85decbc51c6835d425f861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90505523c85decbc51c6835d425f861e">&#9670;&nbsp;</a></span>rtos_osSuspendAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtos_osSuspendAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suspendUpToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Enter critical section; partially suspend task scheduling.</p>
<p >Priority ceiling protocol (PCP), partial scheduler lock: All tasks up to the specified task priority level won't be handled by the CPU any more. This function is intended for implementing mutual exclusion of sub-sets of tasks.<br  />
 Note, the use of the other function pairs<br  />
</p><ul>
<li><a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ae6935dc959dd97bcbe04070a477c2ac3">rtos_osLeaveCriticalSection()</a><br  />
or<br  />
</li>
<li><a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a><br  />
locks all interrupt processing and no other task (or interrupt handler) can become active while the task is inside the critical section code. With respect to behavior, using the PCP API is much better: Call this function with the highest priority of all tasks, which should be locked, i.e., which compete for the resource or critical section to protect. This may still lock other, non competing tasks, but at least all interrupts and all non competing tasks of higher priority will be served.<br  />
 The major drawback of using the PCP instead of the interrupt lock API is the significantly higher expense; particularly at the end of the critical section, when resuming the scheduling again: A recursive call of the scheduler is required to see if some tasks of higher priority had become ready during the lock time. Therefore, locking the interrupts is likely the better choice for very short critical sections.<br  />
 To release the protected resource or to leave the critical section, call the counterpart function <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>, which restores the original task priority level. <dl class="section return"><dt>Returns</dt><dd>The task priority level at entry into this function (and into the critical section) is returned. This level needs to be restored on exit from the critical section using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suspendUpToThisTaskPriority</td><td>All tasks up to and including this priority will be locked, i.e., they won't be executed even if they'd become ready. The CPU will not handle them until the priority level is lowered again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The critical section shaped with this API from an OS task guarantees mutual exclusion with critical section code shaped with the other API <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a> from a user code task. </dd>
<dd>
To support the use case of nested calls of OSEK/VDX like GetResource/ReleaseResource functions, this function compares the stated value to the current priority level. If <em>suspendUpToThisTaskPriority</em> is less than the current value then the current value is not altered. The function still returns the current value and the calling code doesn't need to take care: It can unconditionally end a critical section with <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> stating the returned priority level value. (The resume function will have no effect in this case.) This makes the OSEK like functions usable without deep inside or full transparency of the priority levels behind the scene; just use the pairs of Get-/ResumeResource, be they nested or not. </dd>
<dd>
The use of this function to implement critical sections is usually quite static. For any protected entity (usually a data object or I/O device) the set of competing tasks normally is a compile time known. The priority level to set for entry into the critical section is the maximum of the priorities of all tasks in the set. The priority level to restore on exit from the critical section is the priority of the calling task. All of this static knowledge would typically be put into encapsulating macros that actually invoke this function. (OSEK/VDX like environments would use this function pair to implement the GetResource/ReleaseResource concept.) </dd>
<dd>
Any change of the current priority level made with this function needs to be undone using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> and still inside the same task. It is not possible to consider this function a mutex, which can be acquired in one task activation and which can be released in an arbitrary later task activation or from another task.<br  />
 Moreover, different to the user mode variant of the PCP function pair, there is no restoration of the current priority level at task termination time.<br  />
 An assertion in the scheduler will likely fire if the two PCP APIs are not properly used in pairs. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3edc62289271a4f7bcdbcc02b1680c8e" name="a3edc62289271a4f7bcdbcc02b1680c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edc62289271a4f7bcdbcc02b1680c8e">&#9670;&nbsp;</a></span>rtos_osResumeAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osResumeAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resumeDownToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Leave critical section; resume scheduling of tasks.</p>
<p >This function is called to end a critical section of code, which requires mutual exclusion of two or more tasks. It is the counterpart of function rtos_osSuspendAllInterruptsByPriority(), refer to that function for more details.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resumeDownToThisTaskPriority</td><td>All tasks/interrupts above this priority level are resumed again. All tasks/interrupts up to and including this priority remain locked.<br  />
 You will normally pass in the value got from the related call of rtos_osSuspendAllInterruptsByPriority(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caution, this function lowers the current task priority level to the stated value regardless of the initial value for the task. Accidentally lowering the task priority level below the configured task priority (i.e., the priority inherited from the triggering event processor) will have unpredictable consequences. </dd>
<dd>
Different to the user mode variant of the function, <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>, there is no restoration of the current priority level at task termination time. For OS tasks, there's no option to omit the resume operation if a critical section should last till the end of the task - and there's no need to attempt this neither: The OS variant of the function doesn't involve the overhead of a system call and no execution time would be saved as for the user variant. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>

</div>
</div>
<a id="aa4e09fafaef05f7c20adb63eaefe0b29" name="aa4e09fafaef05f7c20adb63eaefe0b29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4e09fafaef05f7c20adb63eaefe0b29">&#9670;&nbsp;</a></span>rtos_suspendAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtos_suspendAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suspendUpToThisPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Priority ceiling protocol, partial scheduler lock: All tasks up to the specified task priority level won't be served by the CPU. This function is intended for implementing mutual exclusion of sub-sets of tasks: Call it with the highest priority of all tasks, which should be locked, i.e., which compete for the resource or critical section to protect. This may still lock other, not competing tasks, but at least all non competing tasks of higher priority and the interrupt handlers will be served.<br  />
 To release the protected resource or to leave the critical section, call the counterpart function <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>, which restores the original task priority level.<br  />
 The priority can be raised only up to <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a>. An attempt to raise it beyond this limit will lead to an <a class="el" href="rtos_8h.html#a6e76056aa81bac40477ab9beecb6c9c4">RTOS_ERR_PRC_SYS_CALL_BAD_ARG</a> exception.<br  />
 Safety rationale: A user task cannot shape a critical section with the RTOS scheduler, nor with the user task of priority above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> and nor with an ISR. (The attempt to shape a critical section with a task above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> is caught in DEBUG compilation, see <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>.) The intention is to inhibit a task from blocking a safety task. </p><dl class="section return"><dt>Returns</dt><dd>Get the task priority level at entry into this function (and into the critical section). This priority level needs to be restored on exit from the critical section using system call <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suspendUpToThisPriority</td><td><em>suspendUpToThisPriority</em> is the aimed task priority level. All tasks up to and including this priority will be locked. They won't get the CPU until the priority level is lowered again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The critical section shaped with this API from an user mode task guarantees mutual exclusion with critical section code shaped with the other API <a class="el" href="rtos_8h.html#a90505523c85decbc51c6835d425f861e">rtos_osSuspendAllTasksByPriority()</a> from an OS task. </dd>
<dd>
To support the use case of nested calls of OSEK/VDX like GetResource/ReleaseResource functions, this function compares the stated value to the current task priority level. If <em>suspendUpToThisPriority</em> is less than the current value then the current value is not altered. The function still returns the current value and the calling code doesn't need to take care: It can unconditionally end a critical section with <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a> stating the returned task priority level value. (The resume function will have no effect in this case.) This makes the OSEK like functions usable without deep inside or full transparency of the priority levels behind the scene; just use the pairs of Get-/ResumeResource, be they nested or not. </dd>
<dd>
The expense in terms of CPU consumption of using this function is significant enough to better avoid nested pairs of Get-/ResumeResource. As long as all resource and task relationships are static, it'll be possible to replace nested pairs of function calls by a single one with combined, maximum priority. </dd>
<dd>
The use of this function to implement critical sections is usually quite static. For any protected entity (usually a data object or I/O device) the set of competing tasks normally is a compile time known. The priority level to set for entry into the critical section is the maximum of the priorities of all tasks in the set. The priority level to restore on exit from the critical section is the priority of the calling task. All of this static knowledge would typically be put into encapsulating macros that actually invoke this function. (OSEK/VDX like environments would use this function pair to implement the GetResource/ReleaseResource concept.) </dd>
<dd>
The raised priority is implicitly restored at the end of the task. It is not possible to consider this function a mutex, which can be acquired in one task activation and which can be released in an arbitrary later task activation or from another task. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
<a id="ab749e1296f04521109c29ce521ea770e" name="ab749e1296f04521109c29ce521ea770e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab749e1296f04521109c29ce521ea770e">&#9670;&nbsp;</a></span>rtos_resumeAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_resumeAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resumeDownToThisPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is called to end a critical section of code, which requires mutual exclusion of two or more tasks. It is the counterpart of function <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a>, refer to that function for more details.<br  />
 The priority can be lowered only down to the initial task priority. An attempt to lower it below the initial task priority will lead to an <a class="el" href="rtos_8h.html#a6e76056aa81bac40477ab9beecb6c9c4">RTOS_ERR_PRC_SYS_CALL_BAD_ARG</a> exception. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resumeDownToThisPriority</td><td>All tasks above this task priority level are resumed again. All tasks up to and including this task priority remain locked.<br  />
 The intended use of this function is to restore the priority level of a task after use of a resource, which had been protected by an earlier call of the counterpart function <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a>. Normally, <em>resumeDownToThisPriority</em> will be set to the value returned by the other function (or by a constant since this value is a compile-time known in most use cases). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>To support the use case of nested calls of OSEK/VDX like GetResource/ReleaseResource functions, this function compares the stated prioity value to the current priority level. If <em>resumeDownToThisPriority</em> is greater than the current value then the current value is not altered. </dd>
<dd>
It is impossible to shape a critical section with the safety task of priority above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> and the attempt will always mean a functional error in the design of the application code. To support debugging, this error is caught in DEBUG compilation: Then the function throws a <a class="el" href="rtos_8h.html#a6e76056aa81bac40477ab9beecb6c9c4">RTOS_ERR_PRC_SYS_CALL_BAD_ARG</a> exception if <em>resumeDownToThisPriority</em> is greater than <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a>. In PRODUCTION compilation, we have the normal behavior of silently ignoring attempts to actually raise the priority. </dd>
<dd>
Besides the likely unwanted impact on the scheduling, it doesn't harm if a user task calls <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a> to raise the priority but doesn't lower it later using this function. The effect of <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a> will end with the termination of the task. If a critical section is required at the end of a task function it may even be advantageous to not call <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a> in order to save the overhead of the involved system call. </dd>
<dd>
Due to the task switch it can initiate, this function is implemented as a system call of full conformance class and this means significant overhead. It should be applied with care for frequently acquired resources or for very short critical sections.<br  />
 Alternatives are: Look-free programming techniques or dedicated system calls for the given purpose. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
<a id="a5d61ad8cb2aced31246ad1fdbb44faa7" name="a5d61ad8cb2aced31246ad1fdbb44faa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5d61ad8cb2aced31246ad1fdbb44faa7">&#9670;&nbsp;</a></span>rtos_systemCall()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtos_systemCall </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>idxSysCall</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >System call; entry point into operating system function for user code. </p><dl class="section return"><dt>Returns</dt><dd>The return value depends on the system call. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxSysCall</td><td>Each system call is identified by an index. The index is an unsigned integer. The number is the index into system call descriptor table <em>rtos_systemCallDescAry</em>.<br  />
 See manual, <a href="https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/safe-RTOS-VLE/doc/manual/manual.pdf">https://github.com/PeterVranken/TRK-USB-MPC5643L/blob/master/LSM/safe-RTOS-VLE/doc/manual/manual.pdf</a>, section System calls of RTOS, Table 1, p. 17, for a list of system calls offered by the RTOS kernel. More system calls will be offered by your operating system, which builds on safe-RTOS, please refer to your device driver documentation.<br  />
 The further function arguments depend on the particular system call. </td></tr>
    <tr><td class="paramname">...</td><td>The remaining arguments are passed register based to the system call implementation. "Register based" means that the number of arguments is restricted to 7 values of 8..32 Bit each or accordingly lesser arguments if 64 Bit arguments are in use that require two registers each. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>It depends on the particular system call, which context this function may be called from. Nearly all system calls will be restricted to be called from user code. Only a few, like the assert function, are accessible from operating system code, too. Please, refer to the documentation of the particular system call. </dd>
<dd>
The C signature for system calls is formally not correct. The assembly code, which implements this function, only supports function arguments in CPU registers, which limits the total number to eight. The ... stands for 0..7 arguments of up to 32 Bit. If a system call function has more arguments or if it are 64 Bit arguments then the assembly code may not propagate all arguments properly to the actually implementing system call handler and the behavior will be undefined! </dd></dl>

</div>
</div>
<a id="a4f1f4dbf31cbe5dd7c48a1f4ea2d594f" name="a4f1f4dbf31cbe5dd7c48a1f4ea2d594f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4f1f4dbf31cbe5dd7c48a1f4ea2d594f">&#9670;&nbsp;</a></span>rtos_checkUserCodeWritePtr()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_checkUserCodeWritePtr </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>noBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Check if a pointer value is valid for writing in the context of a given process.</p>
<p >Helper function, mainly intended to support safe system call handler implementation: Check if a pointer value is valid for writing in the context of a given process.<br  />
 A system call handler must never trust a user code provided pointer; evidently not for write access but not even for read operation (a read into the address space of peripherals can have a side effect). The user code could make the system call handler overwrite some non-process owned data objects, cause an access violation in the supervisor code or manipulate some peripherals.<br  />
 Normally, it's strongly disencouraged having pointers as arguments of system calls at all. If not avoidable, one can use this helper function to check that a pointer points into permitted address space and that all bytes of a data object pointed at are still in that address space. Here for write access.<br  />
 Permitted address space is anywhere, where the process may write without causing an exception or any kind of side effect. In particular, this means the process' own RAM and the shared RAM. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the pointer may be used for write access and <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the process the query relates to. Range is 1..4. </td></tr>
    <tr><td class="paramname">address</td><td>The pointer value, or the beginning of the chunk of memory, which needs to be entirely located in writable memory. </td></tr>
    <tr><td class="paramname">noBytes</td><td>The size of the chunk of memory to be checked. Must not be less than one. (Checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The counterpart function <a class="el" href="rtos_8h.html#aac7a5ed04ef56818262cd5288d327648">rtos_checkUserCodeReadPtr()</a> is implemented as inline function in the RTOS API header file, <a class="el" href="rtos_8h.html">rtos.h</a>. </dd>
<dd>
Although this function is intended for use inside a system call handler it can be safely used from user code, too. </dd></dl>

</div>
</div>
<a id="a42156b46c1f83c80cd7a1630d91e12cc" name="a42156b46c1f83c80cd7a1630d91e12cc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a42156b46c1f83c80cd7a1630d91e12cc">&#9670;&nbsp;</a></span>rtos_osSystemCallBadArgument()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">_Noreturn void rtos_osSystemCallBadArgument </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >C signature for an assembly code entry point, which ends a system call handler with user task termination and counted process error. Must be used solely from within the implementation of a system call and only if the abortion is due to a clear fault in the calling user code. </p>

</div>
</div>
<a id="ab1ec7855aa3c9d3d400011adab6c8893" name="ab1ec7855aa3c9d3d400011adab6c8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec7855aa3c9d3d400011adab6c8893">&#9670;&nbsp;</a></span>rtos_getNoActivationLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoActivationLoss </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the current number of failed event triggers since start of the RTOS scheduler.</p>
<p >An event processor, which becomes due may not be able to activate all its associated tasks because they didn't terminate yet after their previous activation. It doesn't matter if this happens because a cyclic task becomes due or because the event processor has been triggered by software (e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>). The scheduler counts the failing activations on a per event processor base. The current value can be queried with this function. </p><dl class="section return"><dt>Returns</dt><dd>Get the current number of triggers of the given event processor, which have failed since start of the RTOS scheduler. The counter is saturated and will not wrap around.<br  />
 The returned count can be understood as number of task overrun events for all associated tasks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>Each event processor has its own counter. The value is returned for the given processor. The range is 0 .. number of registered event processors minus one (double-checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, the OS context and a user task. </dd></dl>

</div>
</div>
<a id="ab0f1e1a247f858577c1d9d04e4a4331c" name="ab0f1e1a247f858577c1d9d04e4a4331c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab0f1e1a247f858577c1d9d04e4a4331c">&#9670;&nbsp;</a></span>rtos_getNoTotalTaskFailure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoTotalTaskFailure </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of task failures counted for the given process since start of the kernel.</p>
<p >Get the number of task failures (and voluntary task abortions at the same time) counted for the given process since start of the kernel on the calling core. </p><dl class="section return"><dt>Returns</dt><dd>Get total number of errors counted for process <em>PID</em>.<br  />
 If the kernel is started on more than one core and if several cores share the same process then the function still returns only those process errors, which had been caught on the calling core. Explicit cross-core communication will be required to query the failures counted for the same process on another core, too. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the queried process in the range 1 .. RTOS_NO_PROCESSES. An out of range PID will always yield UINT_MAX and an assertion fires in DEBUG compilation. An unused process has no errors. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, a user task or the OS context. </dd></dl>

</div>
</div>
<a id="abb25bad5cf1976808e7acb79c30290bd" name="abb25bad5cf1976808e7acb79c30290bd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb25bad5cf1976808e7acb79c30290bd">&#9670;&nbsp;</a></span>rtos_getNoTaskFailure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoTaskFailure </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>kindOfErr</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the number of task failures of given category for the given process.</p>
<p >Get the number of task failures of given category counted for the given process since start of the kernel on the calling core. </p><dl class="section return"><dt>Returns</dt><dd>Get total number of errors of category <em>kindOfErr</em> counted for process <em>PID</em>.<br  />
 If the kernel is started on more than one core and if several cores share the same process then the function still returns only those process errors, which had been caught on the calling core. Explicit cross-core communication will be required to query the failures counted for the same process on another core, too. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the queried process in the range 1 .. RTOS_NO_PROCESSES. An out of range PID will always yield UINT_MAX and an assertion fires in DEBUG compilation. An unused process has no errors. </td></tr>
    <tr><td class="paramname">kindOfErr</td><td>The category of the error. See file rtos_ivorHandler.h, <a class="el" href="rtos_8h.html#a5c3c87d0d5a675b6ebe299611b001193">RTOS_ERR_PRC_MACHINE_CHECK</a> and following, for the enumerated error causes. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, a user task or the OS context. </dd></dl>

</div>
</div>
<a id="a240a9b010103563bb950b8d69017703b" name="a240a9b010103563bb950b8d69017703b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a240a9b010103563bb950b8d69017703b">&#9670;&nbsp;</a></span>rtos_getStackReserve()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getStackReserve </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >How many bytes of the stack area of a process are still unused on the calling core?</p>
<p >Compute how many bytes of the stack area of a process are still unused on the calling core. If the value is requested after an application has been run a long while and has been forced to run through all its conditional code paths, it may be used to optimize the static stack allocation. The function is useful only for diagnostic purpose as there's no chance to dynamically increase or decrease the stack area at runtime.<br  />
 The function may be called from a task, ISR and from the idle task.<br  />
 The algorithm is as follows: The unused part of the stack is initialized with a specific pattern word. This routine counts the number of subsequent pattern words down from the (logical) top of the stack area. The result is returned as number of bytes.<br  />
 The returned result must not be trusted too much: It could of course be that a pattern word is found not because of the initialization but because it has been pushed onto the stack - in which case the return value is too great (too optimistic). The probability that this happens is significantly greater than zero. The chance that two pattern words had been pushed is however much less and the probability of three, four, five such words in sequence is negligible. Any stack size optimization based on this routine should therefore subtract e.g. eight bytes from the returned reserve and diminish the stack outermost by this modified value.<br  />
 Be careful with operating system stack size optimization based only on this routine. The OS stack takes all interrupt stack frames. Even if the application ran a long time there's a significant probability that there has not yet been the deepest possible nesting of interrupts in the very instance that the code execution was busy in the deepest nested sub-routine of any of the service routines, i.e. when having the largest imaginable stack consumption for the OS stack. (Actually, the likelihood of not seeing this is rather close to one than close to zero.) A good suggestion therefore is to add the product of ISR stack frame size with the number of IRQ priority levels in use to the measured OS stack use and reduce the allocated stack memory only on this basis.<br  />
 The IRQ stack frame is 96 Byte for normal IRQs and 200 Byte for those, which may start a user task (SW IRQs and I/O IRQs with callback into user code).<br  />
 In the worst case, with 15 IRQ priority levels, this can sum up to 3 kByte. The stack reserve of a "safe" application should be in this order of magnitude. </p><dl class="section return"><dt>Returns</dt><dd>The number of still unused stack bytes of the given process. See function description for details. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The process ID the query relates to. (Each process has its own stack.) ID 0 relates to the OS/kernel stack. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The computation is a linear search for the first non-pattern word and thus relatively expensive. It's suggested to call it only in some specific diagnosis compilation or occasionally from the idle task. </dd>
<dd>
This function can be called from both, the OS context and a user task. </dd>
<dd>
This function may be called even from a core, which is not running safe-RTOS. However, then, the use is restricted to PID 0, the OS stack, which is the only one in use on such a core. </dd></dl>

</div>
</div>
<a id="aeddb4b88dd8c1052eb41763e7164e7fa" name="aeddb4b88dd8c1052eb41763e7164e7fa"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeddb4b88dd8c1052eb41763e7164e7fa">&#9670;&nbsp;</a></span>rtos_osSuspendProcess()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osSuspendProcess </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kernel function to suspend a process.</p>
<p >Kernel function to suspend a process. All currently running tasks belonging to the process are aborted and the process is stopped forever (i.e. there won't be further task starts or I/O driver callback invocations).<br  />
 If the kernel is started on more than one core and if several cores share the same process then the function still relates to only those tasks of the process, which are configured to run on the calling core. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the process to suspend in the range 1..4. Checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tasks of the suspended process can continue running for a short while until their abort conditions are checked the next time. The likelihood of such a continuation is little and the duration is in the magnitude of a Millisecond. </dd>
<dd>
This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd></dl>

</div>
</div>
<a id="a63296923146f8dff5b8754ca1c6003dc" name="a63296923146f8dff5b8754ca1c6003dc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a63296923146f8dff5b8754ca1c6003dc">&#9670;&nbsp;</a></span>rtos_isProcessSuspended()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_isProcessSuspended </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Kernel function to read the suspend status of a process.</p>
<p >Kernel function to read the suspend status of a process. This function is a simple counterpart to <a class="el" href="rtos__process_8c.html#aeddb4b88dd8c1052eb41763e7164e7fa">rtos_osSuspendProcess()</a>. It will return <em>true</em> after the other function had been called for the given process ID or if the process is not at all in use. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> as long as the process is still active, <em>true</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the queried process in the range 1..4. Checked by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from OS and user context. </dd></dl>

</div>
</div>
<a id="a733dddf34c1ab3a828e5e2e98daa8b90" name="a733dddf34c1ab3a828e5e2e98daa8b90"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a733dddf34c1ab3a828e5e2e98daa8b90">&#9670;&nbsp;</a></span>rtos_getIdxCore()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtos_getIdxCore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function returns the contents of CPU read-only register PIR. </p><dl class="section return"><dt>Returns</dt><dd>Get the index of the core the calling code is running on. The range is 0..2, meaning Z4A, Z4B, Z2, respectively. (The convenience macros <a class="el" href="rtos_8h.html#a83cb2901c9810c8c160a1b0d8cf7fa2b">RTOS_CORE_Z4A</a>, <a class="el" href="rtos_8h.html#a7728701da34558de9c44cad1f8ff7bda">RTOS_CORE_Z4B</a> and <a class="el" href="rtos_8h.html#a4bdfa60bad6565f0e56183f260550e60">RTOS_CORE_Z2</a> can be used.) </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from all contexts. However, OS contexts shouldn't because of the performance penalty. They should only use the intrinsic <a class="el" href="rtos_8h.html#a6621923bed2b7ca031f158a305704048">rtos_osGetIdxCore()</a> instead. </dd></dl>

</div>
</div>
<a id="aa300833f2f5ca8b0ff0afa30916a0d1e" name="aa300833f2f5ca8b0ff0afa30916a0d1e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa300833f2f5ca8b0ff0afa30916a0d1e">&#9670;&nbsp;</a></span>rtos_getCoreStatusRegister()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">rtos_getCoreStatusRegister </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Get the value of the msr. This is an entry point to C code, which can be called from supervisor and user mode. </p><dl class="section return"><dt>Returns</dt><dd>Get the current contents of CPU register MSR on the code executing core. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from OS and user code. OS code should however better use an intrinsic to read the MSR and in order to save the function call overhead. </dd></dl>

</div>
</div>
<a id="a6621923bed2b7ca031f158a305704048" name="a6621923bed2b7ca031f158a305704048"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6621923bed2b7ca031f158a305704048">&#9670;&nbsp;</a></span>rtos_osGetIdxCore()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int rtos_osGetIdxCore </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This function returns the content of the read-only CPU register PIR. </p><dl class="section return"><dt>Returns</dt><dd>Get the zero based index of the core the calling code is excuted on. The range depends on the derivative of the MCU.<br  />
 The convenience macros <a class="el" href="rtos_8h.html#a83cb2901c9810c8c160a1b0d8cf7fa2b">RTOS_CORE_Z4A</a>, <a class="el" href="rtos_8h.html#a7728701da34558de9c44cad1f8ff7bda">RTOS_CORE_Z4B</a> and <a class="el" href="rtos_8h.html#a4bdfa60bad6565f0e56183f260550e60">RTOS_CORE_Z2</a> can be used to evaluate the function result. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function may be called from all supervisor contexts, i.e., OS tasks and ISRs. A call from a user task will cause an exception. </dd></dl>

</div>
</div>
<a id="a545491943035300af3886c05538290de" name="a545491943035300af3886c05538290de"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a545491943035300af3886c05538290de">&#9670;&nbsp;</a></span>rtos_osRunTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t rtos_osRunTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a> *&#160;</td>
          <td class="paramname"><em>pUserTaskConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>taskParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Start a user task. A user task is a C function, which is executed in user mode and in a given process context. The call is synchronous; the calling OS context is immediately preempted and superseded by the started task. The calling OS context is resumed when the task function ends - be it gracefully or by exception/abortion.<br  />
 The started task inherits the priority of the calling OS context. It can be preempted only by contexts of higher priority. </p><dl class="section return"><dt>Returns</dt><dd>The executed task function can return a value, which is propagated to the calling OS context if it is positive. A returned negative task function result is interpreted as failing task and <a class="el" href="rtos_8h.html#a545491943035300af3886c05538290de">rtos_osRunTask()</a> returns <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> instead. Furthermore, this event is counted as process error in the target process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUserTaskConfig</td><td>The read-only configuration data for the task. In particular the task function pointer and the ID of the target process. </td></tr>
    <tr><td class="paramname">taskParam</td><td>This argument is meaningless to the function. The value is just passed on to the started task function. The size is large enough to convey a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd>
<dd>
The function is intended to implement safe user code callbacks from interrupt events. However, deadline monitoring fails for the task execution if the ISR, which makes use of this API has a priority equal to or above the kernel priority <a class="el" href="rtos_8config_8h.html#a924e12a1878c0bf4605df034889631dc">RTOS_KERNEL_IRQ_PRIORITY_CORE_0</a> (or #RTOS_KERNEL_IRQ_PRIORITY_CORE_1, or #RTOS_KERNEL_IRQ_PRIORITY_CORE_2, if the RTOS is running on core 1 or 2, respectively). This would likely break the aimed safety concept; an infinite loop in the user code could make the system hang. In most situations, a reasonable safety requirement will prohibit the use of this function from any ISR with such a high priority. </dd></dl>

</div>
</div>
<a id="a2c1c26ac4a21ca0ce27df5484d87cdc2" name="a2c1c26ac4a21ca0ce27df5484d87cdc2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c1c26ac4a21ca0ce27df5484d87cdc2">&#9670;&nbsp;</a></span>rtos_runTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static int32_t rtos_runTask </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrtos__task_desc__t.html">rtos_taskDesc_t</a> *&#160;</td>
          <td class="paramname"><em>pUserTaskConfig</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>taskParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Start a user task. A user task is a C function, which is executed in user mode and in a given process context. The call is synchronous; the calling user context is immediately preempted and superseded by the started task. The calling user context is resumed when the task function ends - be it gracefully or by exception/abortion.<br  />
 The started task inherits the priority of the calling context. It can be preempted only by contexts of higher priority.<br  />
 The function requires sufficient privileges. See <a class="el" href="rtos_8h.html#aeaae84408e099b28495d703994100c16">rtos_osGrantPermissionRunTask()</a> for details. The task cannot be started in the OS context.<br  />
 The function cannot be used recursively. The created task cannot in turn make use of <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a>. </p><dl class="section return"><dt>Returns</dt><dd>The executed task function can return a value, which is propagated to the calling user context if it is positive. A returned negative task function result is interpreted as failing task and <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a> returns <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> instead. Furthermore, this event is counted as process error in the target process. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pUserTaskConfig</td><td>The read-only configuration data for the task. In particular the task function pointer and the ID of the target process. </td></tr>
    <tr><td class="paramname">taskParam</td><td>This argument is meaningless to the function. The value is just passed on to the started task function. The size is large enough to convey a pointer. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from a user process context only. Any attempt to use it in supervisor code will lead to a crash. </dd></dl>

</div>
</div>
<a id="a50aa791209542d3078b18c24acbb46c1" name="a50aa791209542d3078b18c24acbb46c1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50aa791209542d3078b18c24acbb46c1">&#9670;&nbsp;</a></span>rtos_terminateTask()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static _Noreturn void rtos_terminateTask </td>
          <td>(</td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>taskReturnValue</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >End/abort the calling task immediately. A user task may use this system call at any time and from any nested sub-routine. The task execution is immediately aborted. The function does not return. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">taskReturnValue</td><td>The task can return a value to its initiator, i.e., to the context who had applied <a class="el" href="rtos_8h.html#a545491943035300af3886c05538290de">rtos_osRunTask()</a> or <a class="el" href="rtos_8h.html#a2c1c26ac4a21ca0ce27df5484d87cdc2">rtos_runTask()</a> to create the task. The value is signed and (only) the sign is meaningful to the assembly code to create/abort a task:<br  />
 The requested task abortion is considered an error and counted in the owning process if the returned value is negative. In this case, the calling context won't receive the value but the error code <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a>.<br  />
 The requested task abortion is not considered an error if <em>taskReturnValue</em> is greater or equal to zero. The value is propagated to the task creating context. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>If the function is called from inside a critical section, which had been started using <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a>, then the critical section is implicitly ended by this function call. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. There's no equivalent of this function for OS code. An OS task can't be ended prematurely. </dd></dl>

</div>
</div>
<a id="ab154b2923ad0d102fa1515e89d42c898" name="ab154b2923ad0d102fa1515e89d42c898"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab154b2923ad0d102fa1515e89d42c898">&#9670;&nbsp;</a></span>rtos_osSuspendAllInterrupts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void rtos_osSuspendAllInterrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Disable all External Interrupts. This is done unconditionally, there's no nesting counter. </p><dl class="section remark"><dt>Remarks</dt><dd>Note, suspending all External Interrupts does not affect all other interrupts (effectively CPU traps), like Machine Check interrupt. </dd>
<dd>
This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd></dl>

</div>
</div>
<a id="ad580381efb7808b37da052d3a51a7901" name="ad580381efb7808b37da052d3a51a7901"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad580381efb7808b37da052d3a51a7901">&#9670;&nbsp;</a></span>rtos_osResumeAllInterrupts()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void rtos_osResumeAllInterrupts </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Enable all External Interrupts. This is done unconditionally, there's no nesting counter. </p><dl class="section remark"><dt>Remarks</dt><dd>This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd>
<dd>
This function can be called even from non safe-RTOS applications if they run in supervisor mode. </dd></dl>

</div>
</div>
<a id="a3876d0769f82d504e4f88c825461e315" name="a3876d0769f82d504e4f88c825461e315"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3876d0769f82d504e4f88c825461e315">&#9670;&nbsp;</a></span>rtos_osGetAllInterruptsSuspended()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool rtos_osGetAllInterruptsSuspended </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Get the current state of the MSR[EE] status bit. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the processing of External Interrupts is currently enabled and <em>false</em> otherwise. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be used from OS tasks and ISRs only. Calling it from a user task will cause a privileged instruction exception and an error is counted for the process. </dd>
<dd>
This function can be called even from non safe-RTOS applications if they run in supervisor mode. </dd></dl>

</div>
</div>
<a id="a4a9eb6b285b58c2e2f8f6f02e995bf59" name="a4a9eb6b285b58c2e2f8f6f02e995bf59"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4a9eb6b285b58c2e2f8f6f02e995bf59">&#9670;&nbsp;</a></span>rtos_osEnterCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> uint32_t rtos_osEnterCriticalSection </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Start the code of a critical section, thus code, which operates on data, that must not be touched from another execution context at the same time.<br  />
 The critical section is implemented by globally disabling all interrupts. </p><dl class="section return"><dt>Returns</dt><dd>The machine status register content of before disabling the interrupts is returned. The caller will safe it and pass it back to <a class="el" href="rtos_8h.html#ae6935dc959dd97bcbe04070a477c2ac3">rtos_osLeaveCriticalSection()</a> at the end of the critical section. This way the nestability is implemented. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The main difference of this function in comparison to <a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts()</a> is the possibility to nest the calls at different hierarchical code sub-function levels. </dd>
<dd>
This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd>
<dd>
This function can be called even from non safe-RTOS applications if they run in supervisor mode. </dd></dl>

</div>
</div>
<a id="ae6935dc959dd97bcbe04070a477c2ac3" name="ae6935dc959dd97bcbe04070a477c2ac3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae6935dc959dd97bcbe04070a477c2ac3">&#9670;&nbsp;</a></span>rtos_osLeaveCriticalSection()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void rtos_osLeaveCriticalSection </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>msr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >End the code of a critical section, thus code, which operates on data, that must not be touched from another execution context at the same time.<br  />
 The critical section is implemented by globally disabling all interrupts. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">msr</td><td>The machine status register content as it used to be at entry into the critical section. See <a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection()</a> for more. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from the OS context only. Any attempt to use it in user code will lead to a privileged exception. </dd>
<dd>
This function can be called even from non safe-RTOS applications if they run in supervisor mode. </dd></dl>

</div>
</div>
<a id="aa32c2851008be051b3a644e081da3298" name="aa32c2851008be051b3a644e081da3298"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa32c2851008be051b3a644e081da3298">&#9670;&nbsp;</a></span>rtos_sendEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rtos_sendEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uintptr_t&#160;</td>
          <td class="paramname"><em>taskParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Notify an event to an event processor to let it activate all associated tasks.<br  />
 This function must only be called from user tasks, which belong to a process with sufficient privileges. The operation is permitted only for tasks belonging to those processes, which have an ID that is greater of equal to the minimum specified for the event in question. Otherwise an exception is raised, which aborts the calling task.<br  />
 If the calling task belongs to the set of tasks associated with <em>idEventProc</em>, then it'll have no effect but a recorded activation loss; an event processor can re-triggered only after all associated activations have been completed. There is no activation queuing. The function returns <em>false</em> in this case.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the triggered event processor then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>There is no activation queuing. Consequently, notifying the event can fail if at least one of the associated tasks has not yet completed after the previous trigger of the event. The function returns <em>false</em> and the activation loss counter of the event processor is incremented. (See <a class="el" href="rtos_8h.html#ab1ec7855aa3c9d3d400011adab6c8893">rtos_getNoActivationLoss()</a>.) In this situation, the new trigger is entirely lost, i.e., none of the associated tasks will be activated by the event and <em>the</em> value of taskParam won't be seen by the task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos_8h.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos_8h.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">taskParam</td><td>All associated tasks will receive this value, when they are called because of this trigger.<br  />
 The value is ignored if the function returns <em>false</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodoc task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that an event activation loss is not unlikely in this case; the cyclic task may currently be busy. For this purpose, the use of countable events is probably the better choice. See <a class="el" href="rtos_8h.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. </dd>
<dd>
Events notified with this API is called "ordinary". In most situations, the use of countable events will perform better, see <a class="el" href="rtos_8h.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. An important exception from this are timer events for ordinary periodic tasks. </dd>
<dd>
It may look like an inconsistent API design if all associated tasks receive the same value <em>taskParam</em>. The service could easily offer an API, which provides an individual value to each associated task. The only reason not to do so is the additional overhead in combination with the very few imaginable use cases. In most cases an explicitly triggered event will have just one associated task; events with more than one task will mostly be regular timer tasks, which make rarely use of the task parameter. </dd>
<dd>
It is not forbidden but useless to let a task activate itself by triggering the event processor it is associated with with this API. This will have no effect besides incrementing the activation loss counter for that event processor. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
<a id="af2d385fa8723adabb76b583dad031438" name="af2d385fa8723adabb76b583dad031438"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af2d385fa8723adabb76b583dad031438">&#9670;&nbsp;</a></span>rtos_sendEventCountable()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rtos_sendEventCountable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Notify a countable event to activate all associated tasks. Event processors can be used with countable or ordinary events. Please note, the event processor as such is neither countable nor ordinary, but it can be triggered in either way. (For ordinary, see <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>.)<br  />
 For countable events, the multiplicity of notification is recorded and forwarded to the associated task functions by means of their task parameter. Effectively, this is a kind of activation queing, even if it doesn't mean that an associated task is guaranteed to become activated as often as this function is called.<br  />
 Up to a certain maximum, the number of invocations of this function is counted and stored. The stored number is handed over as task parameter to all associated tasks, when they are activated the next time. If the event processor is idle, when this function is called, then the count is one and this is what the task functions will get. If it is not idle then it depends. If the next call(s) of this function happen before the event processor becomes idle again then the stored multiplicity is 2, 3, 4, ... As soon as the event processor becomes idle, its tasks are activated and their task parameter will carry the 2, 3, 4, ..., respectively. In this example, if the event processor becomes idle after 4 calls, then the tasks will be activated not 4 times but just once with a reported multiplicity of 4 triggers. No activation loss is recorded for the event processor, as long as the counter for storing the multiplicity of the triggers doesn't overflow.<br  />
 Using this API for triggering an event, the associated tasks will strictly know, how many notifications of the event occurred - even if the number of task activations may be lesser.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the notified event then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>Notifying the countable event fails if the counter for the multiplicity of the event overflows. The implementation limit of this counter is determined by the mask <em>evMask</em>. If n bits are set in <em>evMask</em> then the function may be called up to 2^n-1 times while the event processor is not idle. The 2^n-th call will be first one returning <em>false</em> and only now, an activation loss will be recorded for the event processor.<br  />
 As long as the caller gets <em>true</em>, he can be sure that the multiplicity of all notifications so far will be properly delivered to the associated task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos_8h.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos_8h.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See above for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodic task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that a non-idle event processor is not unlikely in this case; <em>evMask</em> should spent a sufficient number of bits to temporarily store the multiplicity of notifications-while-non-idle. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
<a id="a9bb888dce5e1f9a94d8c77ce3e3395ec" name="a9bb888dce5e1f9a94d8c77ce3e3395ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9bb888dce5e1f9a94d8c77ce3e3395ec">&#9670;&nbsp;</a></span>rtos_sendEventMultiple()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rtos_sendEventMultiple </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A countable event can be notified with multiplicity greater than one. If the event processor is idle then the associated tasks are activated and they will receive the multiplicity <em>count</em> in their task parameter. If the event processor is not idle then the accumulator for the event will be incremented either by <em>count</em> or up to its implementation maximum, whatever comes first. The resulting, accumulated count will be forwarded to the task functions as soon as the processor becomes idle again. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> if the accumulator for the event overflows (and saturates at its maximum). Get <em>true</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos_8h.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos_8h.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See <a class="el" href="rtos_8h.html#af2d385fa8723adabb76b583dad031438">rtos_sendEventCountable()</a> for details. </td></tr>
    <tr><td class="paramname">count</td><td>The notified multiplicity of the event.<br  />
 The complexity of the operation is O(count), which means that it is intended for rather small multiplicities. To avoid undesired blocking of the function due to excessive high multiplicities, the implementation type for the argument has been chosen 8 Bit, which strictly limits the range of <em>count</em> to 1..255.<br  />
 <em>count</em> = 0 is not allowed and caught by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behavior of this function is similar to calling <a class="el" href="rtos_8h.html#af2d385fa8723adabb76b583dad031438">rtos_sendEventCountable()</a> for <em>count</em> times. The result of <a class="el" href="rtos_8h.html#a9bb888dce5e1f9a94d8c77ce3e3395ec">rtos_sendEventMultiple()</a> would then be the result of the very last call of <a class="el" href="rtos_8h.html#af2d385fa8723adabb76b583dad031438">rtos_sendEventCountable()</a>. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
<a id="aac7a5ed04ef56818262cd5288d327648" name="aac7a5ed04ef56818262cd5288d327648"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac7a5ed04ef56818262cd5288d327648">&#9670;&nbsp;</a></span>rtos_checkUserCodeReadPtr()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool rtos_checkUserCodeReadPtr </td>
          <td>(</td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>address</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>noBytes</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Helper function, mainly intended to support safe system call handler implementation: Check if a pointer value is valid for reading in the context of a given process.<br  />
 A system call handler must never trust a user code provided pointer; evidently not for write access but not even for read operation (a read into the address space of peripherals can have a side effect). The user code could make the system call handler overwrite some non-process owned data objects, cause an access violation in the supervisor code or manipulate some peripherals by side effect of a read-register operation.<br  />
 Normally, it's strongly disencouraged having pointers as arguments of system calls at all. If not avoidable, one can use this helper function to check that a pointer points into permitted address space and that all bytes of a data object pointed at are still in that address space. Here for read access.<br  />
 Permitted address space is anywhere, where supervisor code may read without causing an exception or any kind of side effect. In particular, these are the used portions of RAM and ROM. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if the pointer may be used for read access and <em>false</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">address</td><td>The pointer value, or the beginning of the chunk of memory, which needs to be entirely located in readable memory. </td></tr>
    <tr><td class="paramname">noBytes</td><td>The size of the chunk of memory to be checked. Must not be less than one. (Checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Use the counterpart function <a class="el" href="rtos_8h.html#a4f1f4dbf31cbe5dd7c48a1f4ea2d594f">rtos_checkUserCodeWritePtr()</a> if a system call handler should do a write access via a user code provided pointer. </dd>
<dd>
Although this function is intended for use inside a system call handler it can be safely used from user code, too. </dd></dl>

</div>
</div>
<a id="a50d3acde6c733f5dcf8decab6299e3ff" name="a50d3acde6c733f5dcf8decab6299e3ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a50d3acde6c733f5dcf8decab6299e3ff">&#9670;&nbsp;</a></span>rtos_suspendProcess()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void rtos_suspendProcess </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>PID</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >System call to suspend a process. All currently running tasks belonging to the process are aborted and the process is stopped forever (i.e., there won't be further task starts or I/O driver callback invocations).<br  />
 Suspending a process of PID i is permitted only to processes of PID j&gt;i. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">PID</td><td>The ID of the process to suspend. Needs to be not zero (OS process) and lower than the ID of the calling process. Otherwise the calling task is aborted with exception <a class="el" href="rtos_8h.html#a6e76056aa81bac40477ab9beecb6c9c4">RTOS_ERR_PRC_SYS_CALL_BAD_ARG</a>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Tasks of the suspended process can continue running for a short while until their abort conditions are checked the next time. The likelihood of such a continuation is little and the duration is in the magnitude of a Millisecond. </dd>
<dd>
This function must be called from the user task context only. Any attempt to use it from OS code will lead to a crash. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_9cd24f4fec2e6f6bedbcc5407321d78a.html">system</a></li><li class="navelem"><a class="el" href="dir_34effe5aae1be93d744f092611be46f1.html">RTOS</a></li><li class="navelem"><a class="el" href="rtos_8h.html">rtos.h</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
