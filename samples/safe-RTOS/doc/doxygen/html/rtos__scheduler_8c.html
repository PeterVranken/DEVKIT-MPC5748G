<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.3"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>safe-RTOS: rtos_scheduler.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">safe-RTOS<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">safe-RTOS - A simple RTOS with safety support for MPC5748G</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.3 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('rtos__scheduler_8c.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle"><div class="title">rtos_scheduler.c File Reference</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><code>#include &lt;stdint.h&gt;</code><br />
<code>#include &lt;stdbool.h&gt;</code><br />
<code>#include &lt;stdlib.h&gt;</code><br />
<code>#include &lt;stddef.h&gt;</code><br />
<code>#include &lt;limits.h&gt;</code><br />
<code>#include &lt;assert.h&gt;</code><br />
<code>#include &quot;MPC5748G.h&quot;</code><br />
<code>#include &quot;<a class="el" href="typ__types_8h_source.html">typ_types.h</a>&quot;</code><br />
<code>#include &quot;ccl_configureClocks.h&quot;</code><br />
<code>#include &quot;stm_systemTimer.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__process_8h_source.html">rtos_process.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__external_interrupt_8h_source.html">rtos_externalInterrupt.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__priority_ceiling_protocol_8h_source.html">rtos_priorityCeilingProtocol.h</a>&quot;</code><br />
<code>#include &quot;rtos_ivorHandler.h&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__system_memory_protection_unit_8h_source.html">rtos_systemMemoryProtectionUnit.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__scheduler__def_sys_calls_8h_source.html">rtos_scheduler_defSysCalls.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__scheduler_8h_source.html">rtos_scheduler.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__kernel_instance_data_8h_source.html">rtos_kernelInstanceData.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos__run_task_8h_source.html">rtos_runTask.h</a>&quot;</code><br />
<code>#include &quot;<a class="el" href="rtos_8h_source.html">rtos.h</a>&quot;</code><br />
</div><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="define-members" name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a8ae51f00ca834b6efcc9cedaf826fc14"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a8ae51f00ca834b6efcc9cedaf826fc14">EVENT_PROC_ID_INIT_TASK</a>&#160;&#160;&#160;(UINT_MAX)</td></tr>
<tr class="separator:a8ae51f00ca834b6efcc9cedaf826fc14"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a267ce3a89ec2f69b6a29643a33c01a28"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a267ce3a89ec2f69b6a29643a33c01a28">GET_CORE_VALUE</a>(macro,  idxCore)</td></tr>
<tr class="separator:a267ce3a89ec2f69b6a29643a33c01a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="func-members" name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a3f8edfdc590cd53f9c53002f0aaaf852"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a3f8edfdc590cd53f9c53002f0aaaf852">rtos_osProcessTriggeredEvProcs</a> (<a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *pEvProc)</td></tr>
<tr class="separator:a3f8edfdc590cd53f9c53002f0aaaf852"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a224f58de74e07d9586819cfb4ffc25f8"><td class="memItemLeft" align="right" valign="top">static const unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a224f58de74e07d9586819cfb4ffc25f8">RODATA</a> (rtos_idxRtosTimerAry)</td></tr>
<tr class="separator:a224f58de74e07d9586819cfb4ffc25f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac331cc76788c654b2757642d41c06c5a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ac331cc76788c654b2757642d41c06c5a">getEventProcByID</a> (unsigned int idEventProc)</td></tr>
<tr class="separator:ac331cc76788c654b2757642d41c06c5a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a00d1d1e331d1c6f75aa0edc5a677b7c4"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a00d1d1e331d1c6f75aa0edc5a677b7c4">getEventProcByIdx</a> (unsigned int idxEventProc)</td></tr>
<tr class="separator:a00d1d1e331d1c6f75aa0edc5a677b7c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad480064fc944a36ac0a601334153da24"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ad480064fc944a36ac0a601334153da24">advanceEvProcToSuccesorSamePrio</a> (<a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> **const ppEvProc)</td></tr>
<tr class="separator:ad480064fc944a36ac0a601334153da24"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ab16b873bd15d77375984187787e73a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a1ab16b873bd15d77375984187787e73a">advanceEvProcToSuccesorLowerPrio</a> (<a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> **const ppEvProc)</td></tr>
<tr class="separator:a1ab16b873bd15d77375984187787e73a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac696669054df02b4dc1f62fd70a2417d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ac696669054df02b4dc1f62fd70a2417d">incMaskedCounter</a> (uint32_t *const pWord, uint32_t mask, uint8_t inc)</td></tr>
<tr class="separator:ac696669054df02b4dc1f62fd70a2417d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110e0ded7ae192818e733c8c060216a1"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a110e0ded7ae192818e733c8c060216a1">osSendEvent</a> (<a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *const pEvProc, uint8_t noCountableTriggers, uint32_t evMaskOrTaskParam, const bool isInterrupt)</td></tr>
<tr class="separator:a110e0ded7ae192818e733c8c060216a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8df7dcfd985b3ab2261eb3d506b1d7dd"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a8df7dcfd985b3ab2261eb3d506b1d7dd">checkEventDue</a> (void)</td></tr>
<tr class="separator:a8df7dcfd985b3ab2261eb3d506b1d7dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab32585a08f32534d36ffffb1eb32adeb"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ab32585a08f32534d36ffffb1eb32adeb">launchAllTasksOfEvProc</a> (const <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *const pEvProc)</td></tr>
<tr class="separator:ab32585a08f32534d36ffffb1eb32adeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa619cb414884cbb1f9811966a9151cf8"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#aa619cb414884cbb1f9811966a9151cf8">initRTOSClockTick</a> (void)</td></tr>
<tr class="separator:aa619cb414884cbb1f9811966a9151cf8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae28a732a3918bcd90346b192bf46293"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor</a> (unsigned int *pEvProcId, unsigned int tiCycleInMs, unsigned int tiFirstActivationInMs, unsigned int priority, unsigned int minPIDToTriggerThisEvProc, bool timerUsesCountableEvents, uint32_t timerTaskTriggerParam)</td></tr>
<tr class="separator:aae28a732a3918bcd90346b192bf46293"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3b10ac33293a44882ccbc069f1c9af2a"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor</a> (unsigned int *pEvProcId, unsigned int priority, unsigned int minPIDToTriggerThisEvProc)</td></tr>
<tr class="separator:a3b10ac33293a44882ccbc069f1c9af2a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad638a1d6495b0948343a90257e6410d4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask</a> (int32_t(*initTaskFct)(uint32_t PID), unsigned int PID, unsigned int tiTaskMaxInUs)</td></tr>
<tr class="separator:ad638a1d6495b0948343a90257e6410d4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af7038ee6faaa29605b9129d4f0c9d840"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#af7038ee6faaa29605b9129d4f0c9d840">rtos_osRegisterUserTask</a> (unsigned int idEventProc, int32_t(*userModeTaskFct)(uint32_t PID, uint32_t taskParam), unsigned int PID, unsigned int tiTaskMaxInUs)</td></tr>
<tr class="separator:af7038ee6faaa29605b9129d4f0c9d840"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2cd8691016ac24135e19b2477008750e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask</a> (unsigned int idEventProc, void(*osTaskFct)(uint32_t taskParam))</td></tr>
<tr class="separator:a2cd8691016ac24135e19b2477008750e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel</a> (void)</td></tr>
<tr class="separator:ab24d0fa9208d5675e03cc931a08e52fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdb904958a596625132235635ab2a191"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent</a> (unsigned int idEventProc, uint32_t taskParam)</td></tr>
<tr class="separator:acdb904958a596625132235635ab2a191"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ac3edcc197ad85b1f309ad2efe03586"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable</a> (unsigned int idEventProc, uint32_t evMask)</td></tr>
<tr class="separator:a2ac3edcc197ad85b1f309ad2efe03586"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae428115e507b116469a1859cf20b4c5"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#aae428115e507b116469a1859cf20b4c5">rtos_osSendEventMultiple</a> (unsigned int idEventProc, uint32_t evMask, uint8_t count)</td></tr>
<tr class="separator:aae428115e507b116469a1859cf20b4c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a90505523c85decbc51c6835d425f861e"><td class="memItemLeft" align="right" valign="top">uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a90505523c85decbc51c6835d425f861e">rtos_osSuspendAllTasksByPriority</a> (uint32_t suspendUpToThisTaskPriority)</td></tr>
<tr class="separator:a90505523c85decbc51c6835d425f861e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority</a> (uint32_t resumeDownToThisTaskPriority)</td></tr>
<tr class="separator:a3edc62289271a4f7bcdbcc02b1680c8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1ec7855aa3c9d3d400011adab6c8893"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#ab1ec7855aa3c9d3d400011adab6c8893">rtos_getNoActivationLoss</a> (unsigned int idEventProc)</td></tr>
<tr class="separator:ab1ec7855aa3c9d3d400011adab6c8893"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a11b8aa11db60df29c343007d79157eef"><td class="memItemLeft" align="right" valign="top">unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="rtos__scheduler_8c.html#a11b8aa11db60df29c343007d79157eef">rtos_osGetTaskBasePriority</a> (void)</td></tr>
<tr class="separator:a11b8aa11db60df29c343007d79157eef"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p >This file implements a simple yet "safe" Real Time Operating System (RTOS) for the MPC5748G.<br  />
 The RTOS offers a strictly priority controlled scheduler. The user code is organized in processes and tasks. Any task belongs to one of the processes. Different processes have different privileges. The concept is to use the process with highest privileges for the safety tasks.<br  />
 A task is activated by events. Events are either produced on timer base by event processors or software notified to the processor; an application will repeatedly use the API <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> to define the conditions or points in time, when the tasks have to become due.<br  />
 Prior to the start of the scheduler (and thus prior to the beginning of the pseudo-parallel, concurrent execution of the tasks) all later used tasks are registered at the scheduler; an application will repeatedly use the APIs <a class="el" href="rtos__scheduler_8c.html#af7038ee6faaa29605b9129d4f0c9d840">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask()</a>.<br  />
 After all needed tasks are registered the application will start the RTOS' kernel by calling the API <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a> and task scheduling begins.<br  />
 A task is mainly characterized by the owning process, the task function and a priority; the C code function is invoked in the context of the process and at given priority level when the task is activated. The function is executed either until the task function is left or the task function or one of its sub-routines requests task termination by means of a system call or the task function is aborted by an exception.<br  />
 "Context of a process" mainly relates to the memory management concept. Any process has its private memory. This memory is either write-accessible only for the owning process or for the owning process and all other processes with higher privileges. The "or" in this statement is a matter of project configuration. A few more elements are process dependent; many system calls are restricted to processes of sufficient privileges.<br  />
 "Activated" does still not necessarily mean executing for a task; the more precise wording is that the activation makes a task immediately and unconditionally "ready" (i.e., ready for execution). If more than a single task are ready at a time then the function of the task with higher priority is executed first and the function of the other task will be served only after completion of the first. Several tasks can be simultaneously ready and one of them will be executed, this is the one and only "running" task.<br  />
 "Are ready at a time" does not necessarily mean that both tasks have been activated at the same point in time. If task A of priority Pa is activated first and as only task then it'll be executed regardless of its priority. If task B of priority Pb is activated later, but still before A has completed then we have two tasks which have been activated "at a time". The priority relation decides what happens:<br  />
 If Pa &gt;= Pb then A is completed and B will be started and executed only after A has completed.<br  />
 If Pb &gt; Pa then task A turns from state running back to state ready and B becomes the running task until it completes. Now A as remaining ready, yet uncompleted task becomes the running task again and it can complete.<br  />
 With other words, if a task is activated and it has a higher priority than the running task then it'll preempt the running task and it'll become the running task itself.<br  />
 If no task is ready at all then the scheduler continues the original code thread, which is the code thread starting in function main() and which first registers the tasks and then starts the kernel. (Everything in this code thread, which is placed behind the call of API <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a> is called the "idle task".)<br  />
 The implemented scheduling scheme leads to a strictly hierarchical execution order of tasks. This scheme is sometimes referred to as scheduling of tasks of Basic Conformance Class (BCC). It's simple, less than what most RTOSs offer, but still powerful enough for the majority of industrial use cases.<br  />
Basic conformance class means that a task cannot suspend intentionally and ahead of its normal termination, e.g., entering a system call to wait for an event. Once started, it needs to be entirely executed. Due to the strict priority scheme it'll temporarily suspend only for sake of tasks of higher priority (but not voluntarily or on own desire).<br  />
 The activation of a task can be done by software, using API function <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> or <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a> or it can be done by the scheduler on a regular time base. In the former case the task is called an event task, the latter is a cyclic task with fixed period time.<br  />
 The RTOS implementation is tightly connected to the implementation of interrupt services. Interrupt services, e.g., to implement I/O operations for the tasks, are registered with <a class="el" href="rtos_8h.html#accff5b6fe96e98a366aeab1442a3efe9">rtos_osRegisterInterruptHandler()</a>. There are a few services, which are available to ISRs:</p><ul>
<li>An ISR may use <a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection()</a>/rtos_osLeaveCriticalSection(), <a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts()</a>/rtos_osResumeAllInterrupts() or rtos_osSuspendAllInterruptsByPriority()/rtos_osResumeAllInterruptsByPriority() to shape critical sections with other ISRs or with OS tasks, which are based on interrupt locks and which are highly efficient. (Note, safety concerns forbid having an API to shape a critical section between ISRs and user tasks.)</li>
<li>An ISR may use <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> to trigger an event processor. The associated tasks will be scheduled after returning from the interrupt (and from any other interrupt it has possibly preempted)</li>
<li>An ISR may use rtos_osRunTask to implement a callback into another process. The callback is run under the constraints of the target process and can therefore be implemented as part of the application(s) in that process and still without breaking the safety concept</li>
</ul>
<p >Safety:<br  />
 The RTOS is based on its "unsafe" counterpart published at <a href="https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/RTOS-VLE">https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/RTOS-VLE</a>. Most explanations given there still hold. There are two major differences:<br  />
 In this project, we have replaced the hardware scheduler with a scheduler implemented in software. The behavior is nearly identical and the performance penalty is little in comparison to the advantage of now having an unlimited number of event processors, priorities and tasks.<br  />
 The second modification is the added safety concept. Such a concept starts with a specification of what we expect from a "safe" RTOS:<br  />
 "If the implementation of a task, which is meant the supervisory or safety task, is
itself free of faults then the RTOS shall guarantee that this task is correctly and
timely executed regardless of whatever imaginable failures are made by any other
process."<br  />
 This requirement serves at the same time as the definition of the term "safe", when used in the context of this RTOS. safe-RTOS promises no more than this requirement says. As a consequence, a software made with this RTOS is not necessarily safe and even if it is then the system using that software is still not necessarily safe.<br  />
 The implementation uses the CPU's "problem state" in conjunction with exception handlers and memory protection to meet the requirement. More details can be found at <a href="https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/safe-RTOS-VLE#3-the-safety-concept">https://github.com/PeterVranken/TRK-USB-MPC5643L/tree/master/LSM/safe-RTOS-VLE#3-the-safety-concept</a>.</p>
<p >Copyright (C) 2017-2024 Peter Vranken (<a href="#" onclick="location.href='mai'+'lto:'+'Pet'+'er'+'_Vr'+'an'+'ken'+'@Y'+'aho'+'o.'+'de'; return false;">Peter<span class="obfuscator">.nosp@m.</span>_Vra<span class="obfuscator">.nosp@m.</span>nken@<span class="obfuscator">.nosp@m.</span>Yaho<span class="obfuscator">.nosp@m.</span>o.de</a>)</p>
<p >This program is free software: you can redistribute it and/or modify it under the terms of the GNU Lesser General Public License as published by the Free Software Foundation, either version 3 of the License, or any later version.</p>
<p >This program is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Lesser General Public License for more details.</p>
<p >You should have received a copy of the GNU Lesser General Public License along with this program. If not, see <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Macro Definition Documentation</h2>
<a id="a8ae51f00ca834b6efcc9cedaf826fc14" name="a8ae51f00ca834b6efcc9cedaf826fc14"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8ae51f00ca834b6efcc9cedaf826fc14">&#9670;&nbsp;</a></span>EVENT_PROC_ID_INIT_TASK</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define EVENT_PROC_ID_INIT_TASK&#160;&#160;&#160;(UINT_MAX)</td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A pseudo event ID. Used to register a process initialization task using registerTask(). </p>

</div>
</div>
<a id="a267ce3a89ec2f69b6a29643a33c01a28" name="a267ce3a89ec2f69b6a29643a33c01a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a267ce3a89ec2f69b6a29643a33c01a28">&#9670;&nbsp;</a></span>GET_CORE_VALUE</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define GET_CORE_VALUE</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">macro, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">idxCore&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">            ((idxCore)==0? (macro##_CORE_0)                                     \</div>
<div class="line">                         : ((idxCore)==1? (macro##_CORE_1): (macro##_CORE_2))   \</div>
<div class="line">            )</div>
</div><!-- fragment --><p >Select the static configuration, which applies to the calling core. It's a simple selection from one out of three statically defined macros. Selection is done by name pattern. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a3f8edfdc590cd53f9c53002f0aaaf852" name="a3f8edfdc590cd53f9c53002f0aaaf852"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3f8edfdc590cd53f9c53002f0aaaf852">&#9670;&nbsp;</a></span>rtos_osProcessTriggeredEvProcs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osProcessTriggeredEvProcs </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *&#160;</td>
          <td class="paramname"><em>pEvProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Hook function for ISRs and system calls: Some tasks of triggered event processors are possibly to be executed (depending on priority rules).<br  />
 Note, this function is not publically declared although it is global. It is called externally only from the assembly code, which can't read public declarations in header files. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProc</td><td>The first event processor in global list, which is to be considered for scheduling. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a224f58de74e07d9586819cfb4ffc25f8" name="a224f58de74e07d9586819cfb4ffc25f8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a224f58de74e07d9586819cfb4ffc25f8">&#9670;&nbsp;</a></span>RODATA()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static const unsigned int RODATA </td>
          <td>(</td>
          <td class="paramtype">rtos_idxRtosTimerAry&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >A constant array holding the index of a PIT timer for each core on the chip. This is just the configuration data and it leaves it open, whether the core runs the RTOS and whether the index is used at all. </p>

</div>
</div>
<a id="ac331cc76788c654b2757642d41c06c5a" name="ac331cc76788c654b2757642d41c06c5a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac331cc76788c654b2757642d41c06c5a">&#9670;&nbsp;</a></span>getEventProcByID()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> * getEventProcByID </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Helper: Resolve the linear event processor index used at the API into the actual object. The mapping is not trivial since the event processors are internally ordered by priority. </p><dl class="section return"><dt>Returns</dt><dd>Get the event processor object by reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The linear index of the event processor as used at the API. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The mapping is not essential for the kernel. It implies avoidable run-time effort. The only reason for having the mapping is a user friendly configuration API. If we had a configuration tool (similar to OSEK OIL tool) or if we would put some documented restrictions on the configuration API then we could have a implicit one-by-one mapping without any loss of functionality. </dd>
<dd>
This function must be called from a supervisor context only. It makes use of priviledged instructions. </dd></dl>

</div>
</div>
<a id="a00d1d1e331d1c6f75aa0edc5a677b7c4" name="a00d1d1e331d1c6f75aa0edc5a677b7c4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a00d1d1e331d1c6f75aa0edc5a677b7c4">&#9670;&nbsp;</a></span>getEventProcByIdx()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> * getEventProcByIdx </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idxEventProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Helper: Resolve the linear, zero based, internally used array index into the actual event processor object. This function is trivial and intended more for completeness: it complements the other function <a class="el" href="rtos__scheduler_8c.html#ac331cc76788c654b2757642d41c06c5a">getEventProcByID()</a>. </p><dl class="section return"><dt>Returns</dt><dd>Get the event processor object by reference. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idxEventProc</td><td>Index of event processor object in the array <a class="el" href="rtos__kernel_instance_data_8h.html#a45152a06b62e42d556056341c8647011">rtos_getInstancePtr()</a>-&gt;eventProcAry. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function must be called from a supervisor context only. It makes use of priviledged instructions. </dd></dl>

</div>
</div>
<a id="ad480064fc944a36ac0a601334153da24" name="ad480064fc944a36ac0a601334153da24"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad480064fc944a36ac0a601334153da24">&#9670;&nbsp;</a></span>advanceEvProcToSuccesorSamePrio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void advanceEvProcToSuccesorSamePrio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> **const&#160;</td>
          <td class="paramname"><em>ppEvProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Helper: Advance the pointer to an event processor to its successor in the chain of all. Here, for processors of same priority and in a cyclic manner. If ** <em>ppEvProc</em> is the only one of given priority then the function result is the unmodified, same pointer. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppEvProc</td><td>The pointer to the event processor by reference. * <em>ppEvProc</em> is function argument and result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1ab16b873bd15d77375984187787e73a" name="a1ab16b873bd15d77375984187787e73a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ab16b873bd15d77375984187787e73a">&#9670;&nbsp;</a></span>advanceEvProcToSuccesorLowerPrio()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> void advanceEvProcToSuccesorLowerPrio </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> **const&#160;</td>
          <td class="paramname"><em>ppEvProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Helper: Advance the pointer to an event processor to its first follower in the chain of all, which has a lower priority. The operation is always defined due to the guard element at the end of the list, which has a priority lower than any true list element can have. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ppEvProc</td><td>The pointer to the event processor by reference. * <em>ppEvProc</em> is function argument and result. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac696669054df02b4dc1f62fd70a2417d" name="ac696669054df02b4dc1f62fd70a2417d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac696669054df02b4dc1f62fd70a2417d">&#9670;&nbsp;</a></span>incMaskedCounter()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int incMaskedCounter </td>
          <td>(</td>
          <td class="paramtype">uint32_t *const&#160;</td>
          <td class="paramname"><em>pWord</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>mask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>inc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >This function implements the increment of a counter, which consists of an arbitrary number of bits scattered over a 32 Bit word. Where the counter bits sit in the word is expressed by a mask. The significance of counter bits has the same ordering as for the bits in the word.<br  />
 All bits in the word, i.e., * <em>pWord</em>, which do not correspond to a bit set in the mask are not affected by the operation.<br  />
 The current value of the counter, denoted by the mask bits, is incremented by a small integral number <em>inc</em> if this is possible without overflow to zero. If the increment would overflow then the counter is not modified as far as possible, i.e., the counter in the word is saturated at its implementation maximum.<br  />
 Note, for single-bit masks, the operation is identical to:<br  />
 *pWord = *pWord | mask; </p><dl class="section return"><dt>Returns</dt><dd>Get zero if the operation succeeds, if the counter can be incremented by <em>inc</em>. A value greater than zero means the number of increments, which could not be executed because the counter reached its implementation limit before.<br  />
 If the function doesn't return zero then the counter is at its implementation limit but still to little by the returned value. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pWord</td><td>The word, i.e., the container of the counter, by reference. </td></tr>
    <tr><td class="paramname">mask</td><td>The bits in the mask denote the bits of the counter inside the word. </td></tr>
    <tr><td class="paramname">inc</td><td>A small integral number, which should be added to the counter. The operation is iterative, meaning O(inc). To avoid long blocking times, the operation is implicitly limited to inc &lt;= 255 by choosing an according data type. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a110e0ded7ae192818e733c8c060216a1" name="a110e0ded7ae192818e733c8c060216a1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a110e0ded7ae192818e733c8c060216a1">&#9670;&nbsp;</a></span>osSendEvent()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="typ__types_8h.html#aa1dec568e79152c892dcf63f445cbd7a">ALWAYS_INLINE</a> bool osSendEvent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *const&#160;</td>
          <td class="paramname"><em>pEvProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>noCountableTriggers</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMaskOrTaskParam</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const bool&#160;</td>
          <td class="paramname"><em>isInterrupt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Trigger an event processor to let it activate all associated tasks.<br  />
 This function implements the operation. It is called from different API functions, those for OS code and those for user code (the latter via system call). See, e.g., <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> and <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a> for more details. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>true</em> if event could be delivered, <em>false</em> otherwise.<br  />
 Note, for countable events, <em>true</em> means that all multiplicities of the event could be delivered but it does not necessarily mean that the event processor has already been triggered on exit from the function. The associated tasks may still be busy executing. However, the event has been recorded and will re-trigger the event processor immediately after returning to idle. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProc</td><td>The event processor to trigger by reference. </td></tr>
    <tr><td class="paramname">noCountableTriggers</td><td>The distinction between countable and ordinary events is made using this parameter. Zero means using the ordinary event. It triggers the event processor, but only if it is currently idle. It passes an argument of arbitrary value as task parameter to the next activation of the associated task functions.<br  />
 Values greater than zero mean to notify the event with according multiplicity. The associated task functions will receive the multiplicity of the event as task parameter. If the event processor is not idle then the multiplicity of the event is accumulated. As soon as the event processor becomes idle it'll be triggered and the associated task functions will get all the event counts accumulated meanwhile as task parameter (from this and maybe from later calls of this function).<br  />
 The accumulating variable has an implementation limit. As long as this limit is not exceeded it is guaranteed that the task functions will eventually get all multiplicities of the event. The function returns <em>false</em> if at least one multiplicity of the event is lost.<br  />
 For regular, timer triggered event processors, the value, which has been configured at event creation time, is re-used every time they become due. This way, a timer triggered event can use ordinary events or countable events. </td></tr>
    <tr><td class="paramname">evMaskOrTaskParam</td><td>In case of countable events, <em>evMaskOrTaskParam</em> is the mask that specifies the variable for accumulating the multiplicities of the event, which are still to be delivered to the associated task functions. The variable consists of all bits, which are set in <em>evMaskOrTaskParam</em>. (Normally, but this is not a must, this will be all neighbored bits.) If less than 32 bits are set then the implementation maximum of the counter drops but the unset bits become available to notifying other countable events to the same event processor and to the associated task functions.<br  />
 For example, using the masks 0xFF, 0xFF00, 0xFF0000 and 0xFF000000 one could trigger the event processor with four different countable events, each capable of temporarily storing a multiplicity of up to 255. The associated task functions receive the countable events in their task parameter and using the same bit masks for decoding the counts.<br  />
 For regular, timer triggered event processors and if the processor is currently idle, this is the task parameter for the next activation of the associated task functions. </td></tr>
    <tr><td class="paramname">isInterrupt</td><td>This function submits an immediate call of the scheduler if an event of accordingly high priority is triggered. However, this call is postponed if we are currently still inside an interrupt. This flag tells about.<br  />
 Note, this is an inline function. The complete is-interrupt decision code will be discarded if a Boolean literal can be passed in - as it is for the call from the timer ISR and the user task API. Only the OS API, which is shared between ISRs and OS tasks will really contain the run-time decision code. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8df7dcfd985b3ab2261eb3d506b1d7dd" name="a8df7dcfd985b3ab2261eb3d506b1d7dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8df7dcfd985b3ab2261eb3d506b1d7dd">&#9670;&nbsp;</a></span>checkEventDue()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void checkEventDue </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Process the conditions that trigger event processors. The event processors are checked for becoming meanwhile due and the associated tasks are made ready in case by setting the according state in the event processor object. However, no tasks are already started in this function. </p>

</div>
</div>
<a id="ab32585a08f32534d36ffffb1eb32adeb" name="ab32585a08f32534d36ffffb1eb32adeb"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab32585a08f32534d36ffffb1eb32adeb">&#9670;&nbsp;</a></span>launchAllTasksOfEvProc()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void launchAllTasksOfEvProc </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="structrtos__event_proc_desc__t.html">rtos_eventProcDesc_t</a> *const&#160;</td>
          <td class="paramname"><em>pEvProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Processing a triggered event processor means to execute all associated tasks. If the scheduler finds an event processor to be processed as next one, then it'll call this function to run the tasks. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProc</td><td>The event processor by reference, whose tasks are to be executed one after another. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa619cb414884cbb1f9811966a9151cf8" name="aa619cb414884cbb1f9811966a9151cf8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa619cb414884cbb1f9811966a9151cf8">&#9670;&nbsp;</a></span>initRTOSClockTick()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void initRTOSClockTick </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p >Initialize a timer and associate its wrap-around interrupt with the main clock tick function of the RTOS, onOsTimerTick(). The wrap-around cycle frequency of the timer determines the time resolution of the RTOS operations.<br  />
 The wrap-around cycle time is a compile-time configuration item, see <a class="el" href="rtos_8config_8h.html#a7bf97b46b6e438370c03ef73f06df753">RTOS_CLOCK_TICK_IN_MS_CORE_0</a> (_1, _2) for more details. </p>

</div>
</div>
<a id="aae28a732a3918bcd90346b192bf46293" name="aae28a732a3918bcd90346b192bf46293"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae28a732a3918bcd90346b192bf46293">&#9670;&nbsp;</a></span>rtos_osCreateEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiCycleInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiFirstActivationInMs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>timerUsesCountableEvents</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>timerTaskTriggerParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Creation of an event processor. The event processor can produce a periodic timer event or it can be software triggered. An event processor is needed to activate a user task. Therefore, any reasonable application will create at least one event processor.<br  />
 This function is repeatedly called by the application code for each required event processor. All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>.<br  />
 </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>All event processors are identified by a positive integer. Normally this ID is returned by reference in * <em>pEvProcId</em>. If the event processor cannot be created then <a class="el" href="rtos_8h.html#a6e59eb94bd87ab947627170aa96ba093">RTOS_INVALID_EVENT_PROC_ID</a> is returned in * <em>pEvProcId</em>.<br  />
 Note, it is guaranteed to the caller that the returned ID is not an arbitrary, meaningless number. Instead, the ID is counted from zero in order of creating event processors. The first call of this function will return 0, the second 1, and so on. This simplifies ID handling in the application code, constants can mostly be applied as the IDs are effectively known at compile time. </td></tr>
    <tr><td class="paramname">tiCycleInMs</td><td>The period time for regularly triggering events in ms.<br  />
 The permitted range is 0..2^30-1. 0 means no regular, timer controlled trigger and the event processor is enabled only for software trigger using <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a> (permitted for interrupts or other tasks). </td></tr>
    <tr><td class="paramname">tiFirstActivationInMs</td><td>The first trigger by timer event in ms after start of kernel. The permitted range is 0..2^30-1.<br  />
 Note, this setting is useless if a cycle time zero in <em>tiCycleInMs</em> specifies a non regular event. <em>tiFirstActivationInMs</em> needs to be zero in this case, too. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor in the range 1..UINT_MAX. Different event processors can share the same priority. The priority of an event processor is the priority of all associated tasks at the same time. The execution of tasks, which share the priority will be serialized when they are activated at same time or with overlap.<br  />
 Note the safety constraint that task priorities above <a class="el" href="rtos_8config_8h.html#a7c7e477ca4efe3a5b5502f91e0568d99">RTOS_MAX_LOCKABLE_TASK_PRIORITY</a> are available only to event processors, which solely have associated tasks that belong to the process with highest process ID in use. (Which is assumed to be the safety process.)<br  />
 Note, the order in which event processors are created can affect the priority in a certain sense. If two event processors are created with same priority and when they at runtime become due at the same OS time tick then the earlier created processor will activate its associated tasks before the later created. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Events can be notified by user code, e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>. However, tasks belonging to less privileged processes must not generally have permission to trigger event processors that may activate tasks of higher privileged processes. Since an event processor is not process related, we make the minimum process ID, which is required to notify the event to the processor, an explicitly configured property of the processor.<br  />
 Only tasks belonging to a process with PID &gt;= <em>minPIDToTriggerThisEvProc</em> are permitted to trigger this event processor.<br  />
 The range of <em>minPIDToTriggerThisEvProc</em> is 0 ... (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1). 0 and 1 both mean, all processes may trigger the event processor, (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) means only OS code can trigger it. (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>+1) is available as <a class="el" href="rtos_8h.html#a60b38f5e5b8a935733b453bfd6b18c2b">RTOS_EVENT_PROC_NOT_USER_TRIGGERABLE</a>, too. </td></tr>
    <tr><td class="paramname">timerUsesCountableEvents</td><td>When the OS timer triggers a due event processor then it needs to decide whether to use it as countable or ordinary event. This decision is configured per event but once for ever.<br  />
 <em>timerUsesCountableEvents</em> doesn't care for solely SW notified events, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
    <tr><td class="paramname">timerTaskTriggerParam</td><td>For timer triggered event processors, this is the argument of the trigger operation. For countable events, this is the mask specifying the variable storing the multiplicity of the notified event. Timer triggers always use multiplicity 1 per trigger, i.e., per due time. The number of bits set determine, how many triggers can be stored until a task overflow is reported. For example, with <em>timerTaskTriggerParam=3</em>, a task overflow would be recorded only, when the event has been found non-idle at four consecutive due times. For countable events, <em>timerTaskTriggerParam</em> must not be zero.<br  />
 If <em>timerUsesCountableEvents=false</em> then <em>timerTaskTriggerParam</em> will be used as task parameter that is delivered to all associated task functions on every successful trigger. <em>timerTaskTriggerParam</em> doesn't care for solely SW triggered event processors, i.e., if <em>tiCycleInMs</em> is zero. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>
<dl class="todo"><dt><b><a class="el" href="todo.html#_todo000014">Todo:</a></b></dt><dd>Effectively, this object can be considered the descriptor of the idle task. </dd></dl>

</div>
</div>
<a id="a3b10ac33293a44882ccbc069f1c9af2a" name="a3b10ac33293a44882ccbc069f1c9af2a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3b10ac33293a44882ccbc069f1c9af2a">&#9670;&nbsp;</a></span>rtos_osCreateSwTriggeredEventProcessor()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osCreateSwTriggeredEventProcessor </td>
          <td>(</td>
          <td class="paramtype">unsigned int *&#160;</td>
          <td class="paramname"><em>pEvProcId</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>priority</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>minPIDToTriggerThisEvProc</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A simplified call of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> to create an event processor, which won't be triggered by timer events. (The function internally calls <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> with <em>tiCycleInMs=0</em>.) Most of the function arguments of <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> are meaningless for event processors triggered by software only, which makes the use of this API more appropriate. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the event processor could be created. The maximum number of event processors is limited to <a class="el" href="rtos_8config_8h.html#a42c1961adb85fc5860c9244c45f62804">RTOS_MAX_NO_EVENT_PROCESSORS</a>. If the event processor cannot be created due to this constraint or if the function arguments are invalid or inconsistent then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pEvProcId</td><td>The event processor ID is returned by reference. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">priority</td><td>The priority of the event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
    <tr><td class="paramname">minPIDToTriggerThisEvProc</td><td>Privileges management for this event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> for details. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad638a1d6495b0948343a90257e6410d4" name="ad638a1d6495b0948343a90257e6410d4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad638a1d6495b0948343a90257e6410d4">&#9670;&nbsp;</a></span>rtos_osRegisterInitTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterInitTask </td>
          <td>(</td>
          <td class="paramtype">int32_t(*)(uint32_t PID)&#160;</td>
          <td class="paramname"><em>initTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registration of a process initialization task. This function is typically repeatedly called by the operating system initialization code as often as there are processes, which need initialization.<br  />
 Initialization functions are particularly useful for the user processes. They allow having user provided code, that is run prior to the start of the scheduler, in a still race condition free environment but already with full protection against runtime failures.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of initialization tasks is one per process and one for the OS. If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">initTaskFct</td><td>The initialization function, which is run once in process <em>PID</em>.<br  />
 The function gets the ID of the process it belongs to as argument.<br  />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process and the scheduler will not start up. </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>) plus the kernel process, which has ID 0. The range of process IDs to be used here is 0 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br  />
 At kernel initialization time, the registered user process initialization functions will be called in the order of rising PID, followed by the registered kernel process initialization function. </td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the function execution in Microseconds. The budget relates to deadline monitoring, i.e., it is a world time budget, not an execution time budget.<br  />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br  />
 A value of zero means that deadline monitoring is disabled for the run of the initialization function.<br  />
 There's no deadline monitoring for OS tasks. If <em>PID</em> is zero then <em>tiTaskMaxInUS</em> meeds to be zero, too. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="af7038ee6faaa29605b9129d4f0c9d840" name="af7038ee6faaa29605b9129d4f0c9d840"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af7038ee6faaa29605b9129d4f0c9d840">&#9670;&nbsp;</a></span>rtos_osRegisterUserTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterUserTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t(*)(uint32_t PID, uint32_t taskParam)&#160;</td>
          <td class="paramname"><em>userModeTaskFct</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>PID</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>tiTaskMaxInUs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registration of an event triggered user mode task. Normal, event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as user mode tasks are required.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8config_8h.html#a132fbde1ccf910d5a3ba069232db0709">RTOS_MAX_NO_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The task is activated by an event. This call associates the registered task with an already created event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a>.<br  />
 The order of registration of several tasks (both, OS and user mode) with one and the same event processor matters. The tasks will be acivated in order of registration whenever the event processor becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">userModeTaskFct</td><td>The task function, which is run in process <em>PID</em> every time the event processor <em>idEventProc</em> becomes due of is triggered by software.<br  />
 The function gets the ID of the process it belongs to as argument.<br  />
 The function returns a signed value. If the value is negative then it is considered an error, which is counted as error <a class="el" href="rtos_8h.html#a32453f0c8f6c8845c879a54e4288c2b4">RTOS_ERR_PRC_USER_ABORT</a> in the owning process. (And after a number of errors a supervisory task could force a shutdown of the process). </td></tr>
    <tr><td class="paramname">PID</td><td>The process the task belongs to by identifier. We have a fixed, limited number of four processes (<a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>). The range of process IDs to be used here is 1 .. <a class="el" href="rtos_8h.html#a18500a557ecd5ebbcefbacba22b58d7e">RTOS_NO_PROCESSES</a>.<br  />
</td></tr>
    <tr><td class="paramname">tiTaskMaxInUs</td><td>Time budget for the task in Microseconds. This budget is granted for each activation of the task, i.e., each run of <em>userModeTaskFct()</em>. The budget relates to deadline monitoring, i.e., it is a world time budget, not an execution time budget.<br  />
 Deadline monitoring is supported up to a maximum execution time of <a class="el" href="rtos_8h.html#a1f387767ac5768e23a4a7aa1ef5084f7">RTOS_TI_DEADLINE_MAX_IN_US</a> Microseconds.<br  />
 A value of zero means that deadline monitoring is disabled for the task.<br  />
 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="a2cd8691016ac24135e19b2477008750e" name="a2cd8691016ac24135e19b2477008750e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2cd8691016ac24135e19b2477008750e">&#9670;&nbsp;</a></span>rtos_osRegisterOSTask()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osRegisterOSTask </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void(*)(uint32_t taskParam)&#160;</td>
          <td class="paramname"><em>osTaskFct</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Registration of an event triggered operating system task. Event activated tasks can be registered for later execution. This function is repeatedly called by the application code as often as operating system tasks are required.<br  />
 All calls of this function need to be done prior to the start of the kernel using <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the task could be registered. The maximum number of tasks is limited to <a class="el" href="rtos_8config_8h.html#a132fbde1ccf910d5a3ba069232db0709">RTOS_MAX_NO_TASKS</a> (regardless, how they are distributed among processes). If the limit is exceeded or if the task specification is invalid then the function returns a non zero value from enumeration <em>rtos_errorCode_t</em>.<br  />
 An assertion in the calling code is considered appropriate to handle the error because it'll always be a static configuration error. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The task is activated by an event. This call associates the registered task with an already created event processor. See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a>.<br  />
 The order of registration of several tasks (both, OS and user mode) with one and the same event processor matters. The tasks will be acivated in order of registration whenever the event processor becomes due or is triggered by software. </td></tr>
    <tr><td class="paramname">osTaskFct</td><td>The task function, which is run in the OS context every time the event processor <em>idEventProc</em> becomes due or is triggered by software. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Never call this function after the call of <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>! </dd>
<dd>
This function must be called by trusted code in supervisor mode only. </dd></dl>

</div>
</div>
<a id="ab24d0fa9208d5675e03cc931a08e52fd" name="ab24d0fa9208d5675e03cc931a08e52fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab24d0fa9208d5675e03cc931a08e52fd">&#9670;&nbsp;</a></span>rtos_osInitKernel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="rtos_8h.html#ae6a79bdc418d571b34528a8d2c9f49d1">rtos_errorCode_t</a> rtos_osInitKernel </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Initialization and start of the RTOS kernel.<br  />
 The function initializes a hardware device to produce a regular clock tick and connects the OS schedule function onOsTimerTick() with the interrupt raised by this timer device. After return, the RTOS is running with a regular clock tick for scheduling the tasks. Period time is <a class="el" href="rtos_8config_8h.html#a7bf97b46b6e438370c03ef73f06df753">RTOS_CLOCK_TICK_IN_MS_CORE_0</a> (_1, _2) Milliseconds.<br  />
 The function can be called before or after the External Interrupts are enabled at the CPU (see <a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a>). Normal behavior is however, no to resume the interrupt processing before and let this be done by <a class="el" href="rtos__scheduler_8c.html#ab24d0fa9208d5675e03cc931a08e52fd">rtos_osInitKernel()</a>. </p><dl class="section return"><dt>Returns</dt><dd><em>rtos_err_noError</em> (zero) if the scheduler could be started. The function returns a non zero value from enumeration <em>rtos_errorCode_t</em> if a configuration error is detected. The software must not start up in this case. Since it is only about static configuration, the returned error may be appropriately handled by an assertion. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>The RTOS kernel applies the Periodic Interrupt Timer 0 (PIT0) as clock source. This timer is reserved to the RTOS and must not be used at all by some other code. </dd>
<dd>
All application tasks need to be registered before invoking this function, see <a class="el" href="rtos__scheduler_8c.html#ad638a1d6495b0948343a90257e6410d4">rtos_osRegisterInitTask()</a>, <a class="el" href="rtos__scheduler_8c.html#af7038ee6faaa29605b9129d4f0c9d840">rtos_osRegisterUserTask()</a> and <a class="el" href="rtos__scheduler_8c.html#a2cd8691016ac24135e19b2477008750e">rtos_osRegisterOSTask()</a>. </dd>
<dd>
This function must be called from the OS context only. The call of this function will end the operating system initialization phase. </dd></dl>

</div>
</div>
<a id="acdb904958a596625132235635ab2a191" name="acdb904958a596625132235635ab2a191"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acdb904958a596625132235635ab2a191">&#9670;&nbsp;</a></span>rtos_osSendEvent()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEvent </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>taskParam</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notify an event to an event processor to let it activate all associated tasks.<br  />
 This function can be called from any OS task or ISR. However, if the calling task belongs to the set of tasks associated with <em>idEventProc</em>, then it'll have no effect but a recorded activation loss; using this API, an event can be re-triggered only after all associated tasks have been completed. There is no activation queueing. The function returns <em>false</em> in this case.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the triggered event processor then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>There is no activation queuing. Consequently, notifying the event can fail if at least one of the associated tasks has not yet completed after the previous trigger of the event. The function returns <em>false</em> and the activation loss counter of the event processor is incremented. (See <a class="el" href="rtos__scheduler_8c.html#ab1ec7855aa3c9d3d400011adab6c8893">rtos_getNoActivationLoss()</a>.) In this situation, the new trigger is entirely lost, i.e., none of the associated tasks will be activated by the event and <em>the</em> value of taskParam won't be seen by the task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">taskParam</td><td>All associated tasks will receive this value, when they are called because of this trigger.<br  />
 The value is ignored if the function returns <em>false</em>. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodic task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that an event activation loss is not unlikely in this case; the cyclic task may currently be busy. For this purpose, the use of countable events is probably the better choice. See <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. </dd>
<dd>
Events notified with this API are called "ordinary". In most situations, the use of countable events will perform better, see <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. An important exception from this are timer events for ordinary periodic tasks. </dd>
<dd>
It may look like an inconsistent API design if all associated tasks receive the same value <em>taskParam</em>. The service could easily offer an API, which provides an individual value to each associated task. The only reason not to do so is the additional overhead in combination with the very few imaginable use cases. In most cases an explicitly triggered event will have just one associated task; events with more than one task will mostly be regular timer tasks, which make rarely use of the task parameter. </dd>
<dd>
It is not forbidden but useless to let a task activate itself by triggering the event processor it is associated with with this API. This will have no effect besides incrementing the activation loss counter for that event processor. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="a2ac3edcc197ad85b1f309ad2efe03586" name="a2ac3edcc197ad85b1f309ad2efe03586"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ac3edcc197ad85b1f309ad2efe03586">&#9670;&nbsp;</a></span>rtos_osSendEventCountable()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEventCountable </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Notify a countable event to activate all associated tasks. Event processors can be used with countable or ordinary events. Please note, the event processor as such is neither countable nor ordinary, but it can be triggered in either way. (For ordinary, see <a class="el" href="rtos__scheduler_8c.html#acdb904958a596625132235635ab2a191">rtos_osSendEvent()</a>.)<br  />
 For countable events, the multiplicity of notification is recorded and forwarded to the associated task functions by means of their task parameter. Effectively, this is a kind of activation queing, even if it doesn't mean that an associated task is guaranteed to become activated as often as this function is called.<br  />
 Up to a certain maximum, the number of invocations of this function is counted and stored. The stored number is handed over as task parameter to all associated tasks, when they are activated the next time. If the event processor is idle, when this function is called, then the count is one and this is what the task functions will get. If it is not idle then it depends. If the next call(s) of this function happen before the event processor becomes idle again then the stored multiplicity is 2, 3, 4, ... As soon as the event processor becomes idle, its tasks are activated and their task parameter will carry the 2, 3, 4, ..., respectively. In this example, if the event processor becomes idle after 4 calls, then the tasks will be activated not 4 times but just once with a reported multiplicity of 4 triggers. No activation loss is recorded for the event processor, as long as the counter for storing the multiplicity of the triggers doesn't overflow.<br  />
 Using this API for triggering an event, the associated tasks will strictly know, how many notifications of the event occurred - even if the number of task activations may be lesser.<br  />
 Note, the system respects the priorities of the activated tasks. If a task of priority higher than the activating task is activated by the notified event then the activating task is immediately preempted to the advantage of the activated task. Otherwise the activated task is chained and executed after the activating task. </p><dl class="section return"><dt>Returns</dt><dd>Notifying the countable event fails if the counter for the multiplicity of the event overflows. The implementation limit of this counter is determined by the mask <em>evMask</em>. If n bits are set in <em>evMask</em> then the function may be called up to 2^n-1 times while the event processor is not idle. The 2^n-th call will be first one returning <em>false</em> and only now, an activation loss will be recorded for the event processor.<br  />
 As long as the caller gets <em>true</em>, he can be sure that the multiplicity of all notifications so far will be properly delivered to the associated task functions. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See above for details. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The function is indented to start a non periodic task by application software trigger but can be applied to periodic timer tasks, too. In which case the task function of the cyclic task would be invoked once additionally. Note, that a non-idle event processor is not unlikely in this case; <em>evMask</em> should spent a sufficient number of bits to temporarily store the multiplicity of notifications-while-non-idle. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="aae428115e507b116469a1859cf20b4c5" name="aae428115e507b116469a1859cf20b4c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae428115e507b116469a1859cf20b4c5">&#9670;&nbsp;</a></span>rtos_osSendEventMultiple()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool rtos_osSendEventMultiple </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>evMask</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A countable event can be notified with multiplicity greater than one. If the event processor is idle then the associated tasks are activated and they will receive the multiplicity <em>count</em> in their task parameter. If the event processor is not idle then the accumulator for the event will be incremented either by <em>count</em> or up to its implementation maximum, whatever comes first. The resulting, accumulated count will be forwarded to the task functions as soon as the processor becomes idle again. </p><dl class="section return"><dt>Returns</dt><dd>Get <em>false</em> if the accumulator for the event overflows (and saturates at its maximum). Get <em>true</em> otherwise. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>The ID of the event processor to activate as it had been got by the creation call for that processor. (See <a class="el" href="rtos__scheduler_8c.html#aae28a732a3918bcd90346b192bf46293">rtos_osCreateEventProcessor()</a> and <a class="el" href="rtos__scheduler_8c.html#a3b10ac33293a44882ccbc069f1c9af2a">rtos_osCreateSwTriggeredEventProcessor()</a>.) </td></tr>
    <tr><td class="paramname">evMask</td><td>Definition of the bit mask designating the notified event. See <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a> for details. </td></tr>
    <tr><td class="paramname">count</td><td>The notified multiplicity of the event.<br  />
 The complexity of the operation is O(count), which means that it is intended for rather small multiplicities. To avoid undesired blocking of the function due to excessive high multiplicities, the implementation type for the argument has been chosen 8 Bit, which strictly limits the range of <em>count</em> to 1..255.<br  />
 <em>count</em> = 0 is not allowed and caught by assertion. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The behavior of this function is similar to calling <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a> for <em>count</em> times. The result of <a class="el" href="rtos__scheduler_8c.html#aae428115e507b116469a1859cf20b4c5">rtos_osSendEventMultiple()</a> would then be the result of the very last call of <a class="el" href="rtos__scheduler_8c.html#a2ac3edcc197ad85b1f309ad2efe03586">rtos_osSendEventCountable()</a>. </dd>
<dd>
This function must be called from the OS context only. It may be called from an ISR to implement delegation to a user task. </dd></dl>

</div>
</div>
<a id="a90505523c85decbc51c6835d425f861e" name="a90505523c85decbc51c6835d425f861e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a90505523c85decbc51c6835d425f861e">&#9670;&nbsp;</a></span>rtos_osSuspendAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">uint32_t rtos_osSuspendAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>suspendUpToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >Priority ceiling protocol (PCP), partial scheduler lock: All tasks up to the specified task priority level won't be handled by the CPU any more. This function is intended for implementing mutual exclusion of sub-sets of tasks.<br  />
 Note, the use of the other function pairs<br  />
</p><ul>
<li><a class="el" href="rtos_8h.html#a4a9eb6b285b58c2e2f8f6f02e995bf59">rtos_osEnterCriticalSection()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ae6935dc959dd97bcbe04070a477c2ac3">rtos_osLeaveCriticalSection()</a><br  />
or<br  />
</li>
<li><a class="el" href="rtos_8h.html#ab154b2923ad0d102fa1515e89d42c898">rtos_osSuspendAllInterrupts()</a> and<br  />
</li>
<li><a class="el" href="rtos_8h.html#ad580381efb7808b37da052d3a51a7901">rtos_osResumeAllInterrupts()</a><br  />
locks all interrupt processing and no other task (or interrupt handler) can become active while the task is inside the critical section code. With respect to behavior, using the PCP API is much better: Call this function with the highest priority of all tasks, which should be locked, i.e., which compete for the resource or critical section to protect. This may still lock other, non competing tasks, but at least all interrupts and all non competing tasks of higher priority will be served.<br  />
 The major drawback of using the PCP instead of the interrupt lock API is the significantly higher expense; particularly at the end of the critical section, when resuming the scheduling again: A recursive call of the scheduler is required to see if some tasks of higher priority had become ready during the lock time. Therefore, locking the interrupts is likely the better choice for very short critical sections.<br  />
 To release the protected resource or to leave the critical section, call the counterpart function <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>, which restores the original task priority level. <dl class="section return"><dt>Returns</dt><dd>The task priority level at entry into this function (and into the critical section) is returned. This level needs to be restored on exit from the critical section using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a>. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">suspendUpToThisTaskPriority</td><td>All tasks up to and including this priority will be locked, i.e., they won't be executed even if they'd become ready. The CPU will not handle them until the priority level is lowered again. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>The critical section shaped with this API from an OS task guarantees mutual exclusion with critical section code shaped with the other API <a class="el" href="rtos_8h.html#aa4e09fafaef05f7c20adb63eaefe0b29">rtos_suspendAllTasksByPriority()</a> from a user code task. </dd>
<dd>
To support the use case of nested calls of OSEK/VDX like GetResource/ReleaseResource functions, this function compares the stated value to the current priority level. If <em>suspendUpToThisTaskPriority</em> is less than the current value then the current value is not altered. The function still returns the current value and the calling code doesn't need to take care: It can unconditionally end a critical section with <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> stating the returned priority level value. (The resume function will have no effect in this case.) This makes the OSEK like functions usable without deep inside or full transparency of the priority levels behind the scene; just use the pairs of Get-/ResumeResource, be they nested or not. </dd>
<dd>
The use of this function to implement critical sections is usually quite static. For any protected entity (usually a data object or I/O device) the set of competing tasks normally is a compile time known. The priority level to set for entry into the critical section is the maximum of the priorities of all tasks in the set. The priority level to restore on exit from the critical section is the priority of the calling task. All of this static knowledge would typically be put into encapsulating macros that actually invoke this function. (OSEK/VDX like environments would use this function pair to implement the GetResource/ReleaseResource concept.) </dd>
<dd>
Any change of the current priority level made with this function needs to be undone using <a class="el" href="rtos__scheduler_8c.html#a3edc62289271a4f7bcdbcc02b1680c8e">rtos_osResumeAllTasksByPriority()</a> and still inside the same task. It is not possible to consider this function a mutex, which can be acquired in one task activation and which can be released in an arbitrary later task activation or from another task.<br  />
 Moreover, different to the user mode variant of the PCP function pair, there is no restoration of the current priority level at task termination time.<br  />
 An assertion in the scheduler will likely fire if the two PCP APIs are not properly used in pairs. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>
</li>
</ul>

</div>
</div>
<a id="a3edc62289271a4f7bcdbcc02b1680c8e" name="a3edc62289271a4f7bcdbcc02b1680c8e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3edc62289271a4f7bcdbcc02b1680c8e">&#9670;&nbsp;</a></span>rtos_osResumeAllTasksByPriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void rtos_osResumeAllTasksByPriority </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>resumeDownToThisTaskPriority</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >This function is called to end a critical section of code, which requires mutual exclusion of two or more tasks. It is the counterpart of function rtos_osSuspendAllInterruptsByPriority(), refer to that function for more details.<br  />
</p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">resumeDownToThisTaskPriority</td><td>All tasks/interrupts above this priority level are resumed again. All tasks/interrupts up to and including this priority remain locked.<br  />
 You will normally pass in the value got from the related call of rtos_osSuspendAllInterruptsByPriority(). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>Caution, this function lowers the current task priority level to the stated value regardless of the initial value for the task. Accidentally lowering the task priority level below the configured task priority (i.e., the priority inherited from the triggering event processor) will have unpredictable consequences. </dd>
<dd>
Different to the user mode variant of the function, <a class="el" href="rtos_8h.html#ab749e1296f04521109c29ce521ea770e">rtos_resumeAllTasksByPriority()</a>, there is no restoration of the current priority level at task termination time. For OS tasks, there's no option to omit the resume operation if a critical section should last till the end of the task - and there's no need to attempt this neither: The OS variant of the function doesn't involve the overhead of a system call and no execution time would be saved as for the user variant. </dd>
<dd>
This function must be called from OS tasks only. Any attempt to use it from either an ISR or in user mode code will lead to either a failure or privileged exception, respectively. </dd>
<dd>
This function requires that msr[EE]=1 on entry. </dd></dl>

</div>
</div>
<a id="ab1ec7855aa3c9d3d400011adab6c8893" name="ab1ec7855aa3c9d3d400011adab6c8893"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1ec7855aa3c9d3d400011adab6c8893">&#9670;&nbsp;</a></span>rtos_getNoActivationLoss()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_getNoActivationLoss </td>
          <td>(</td>
          <td class="paramtype">unsigned int&#160;</td>
          <td class="paramname"><em>idEventProc</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >An event processor, which becomes due may not be able to activate all its associated tasks because they didn't terminate yet after their previous activation. It doesn't matter if this happens because a cyclic task becomes due or because the event processor has been triggered by software (e.g., using <a class="el" href="rtos_8h.html#aa32c2851008be051b3a644e081da3298">rtos_sendEvent()</a>). The scheduler counts the failing activations on a per event processor base. The current value can be queried with this function. </p><dl class="section return"><dt>Returns</dt><dd>Get the current number of triggers of the given event processor, which have failed since start of the RTOS scheduler. The counter is saturated and will not wrap around.<br  />
 The returned count can be understood as number of task overrun events for all associated tasks. </dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">idEventProc</td><td>Each event processor has its own counter. The value is returned for the given processor. The range is 0 .. number of registered event processors minus one (double-checked by assertion). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from both, the OS context and a user task. </dd></dl>

</div>
</div>
<a id="a11b8aa11db60df29c343007d79157eef" name="a11b8aa11db60df29c343007d79157eef"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a11b8aa11db60df29c343007d79157eef">&#9670;&nbsp;</a></span>rtos_osGetTaskBasePriority()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">unsigned int rtos_osGetTaskBasePriority </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p >A cyclic or event task can query its base priority. </p><dl class="section return"><dt>Returns</dt><dd>Get the base priority of the task, which calls this function. It's the priority of the event processor it is associated with. </dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>This function can be called from an OS task only. Any attempt to call it from a user task will cause a privileged exception. </dd>
<dd>
The function must not be called from an ISR. The result would be undefined as there is no event processor, which such a handler function would be associated with. However, with respect to safety or stability, there's no problem in doing this. </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_050edd66366d13764f98250ef6db77f6.html">code</a></li><li class="navelem"><a class="el" href="dir_9cd24f4fec2e6f6bedbcc5407321d78a.html">system</a></li><li class="navelem"><a class="el" href="dir_34effe5aae1be93d744f092611be46f1.html">RTOS</a></li><li class="navelem"><a class="el" href="rtos__scheduler_8c.html">rtos_scheduler.c</a></li>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.3 </li>
  </ul>
</div>
</body>
</html>
